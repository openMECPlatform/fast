diff --git a/.gitignore b/.gitignore
index d59a62b..378eac2 100644
--- a/.gitignore
+++ b/.gitignore
@@ -1,2 +1 @@
 build
-tmp
diff --git a/README b/README
index c837afa..fecdb67 100644
--- a/README
+++ b/README
@@ -19,3 +19,13 @@ Vern Paxson & Robin Sommer,
 International Computer Science Institute &
 Lawrence Berkeley National Laboratory
 vern@icir.org / robin@icir.org
+
+============================
+OpenNF Support
+============================
+
+This code base has been modified by researchers at the University of 
+Wisconsin-Madison to support OpenNF. See the OpenNF home page for more 
+information:
+
+    http://pages.cs.wisc.edu/~agember/opennf
diff --git a/bro.patch b/bro.patch
new file mode 100644
index 0000000..b4a3c07
--- /dev/null
+++ b/bro.patch
@@ -0,0 +1,6864 @@
+diff -urN bro-2.1/.gitignore bro-2.1-sdmbn/.gitignore
+--- bro-2.1/.gitignore	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/.gitignore	2014-02-17 17:20:00.000000003 -0600
+@@ -1,2 +1 @@
+ build
+-tmp
+diff -urN bro-2.1/README bro-2.1-sdmbn/README
+--- bro-2.1/README	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/README	2014-02-17 17:20:00.000000003 -0600
+@@ -19,3 +19,13 @@
+ International Computer Science Institute &
+ Lawrence Berkeley National Laboratory
+ vern@icir.org / robin@icir.org
++
++============================
++OpenNF Support
++============================
++
++This code base has been modified by researchers at the University of 
++Wisconsin-Madison to support OpenNF. See the OpenNF home page for more 
++information:
++
++    http://pages.cs.wisc.edu/~agember/opennf
+diff -urN bro-2.1/sdmbn_build.sh bro-2.1-sdmbn/sdmbn_build.sh
+--- bro-2.1/sdmbn_build.sh	1969-12-31 18:00:00.000000000 -0600
++++ bro-2.1-sdmbn/sdmbn_build.sh	2014-02-17 17:20:06.000000003 -0600
+@@ -0,0 +1,11 @@
++#!/bin/bash
++
++export LDFLAGS="-lsdmbn -ljson-c -lboost_serialization"
++
++./configure
++sed -e 's/-lsdmbn -ljson-c -lboost_serialization//' -i build/src/CMakeFiles/bro.dir/link.txt
++sed -e 's/-lcrypto/-lcrypto -lsdmbn -ljson-c -lboost_serialization/' -i build/src/CMakeFiles/bro.dir/link.txt
++sed -e 's/-lsdmbn -ljson-c -lboost_serialization//' -i build/src/CMakeFiles/bro.dir/relink.txt
++sed -e 's/-lcrypto/-lcrypto -lsdmbn -ljson-c -lboost_serialization/' -i build/src/CMakeFiles/bro.dir/relink.txt
++make
++make install
+diff -urN bro-2.1/src/Analyzer.cc bro-2.1-sdmbn/src/Analyzer.cc
+--- bro-2.1/src/Analyzer.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Analyzer.cc	2014-02-17 17:20:06.000000003 -0600
+@@ -40,6 +40,11 @@
+ #include "Syslog-binpac.h"
+ #include "Teredo.h"
+ #include "ConnSizeAnalyzer.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include <boost/serialization/list.hpp>
++#include "SDMBNlocal.h"
+ 
+ // Keep same order here as in AnalyzerTag definition!
+ const Analyzer::Config Analyzer::analyzer_configs[] = {
+@@ -203,6 +208,27 @@
+ 	Ref(analyzer->Conn());
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(AnalyzerTimer,"AnalyzerTimer")
++template<class Archive>
++void AnalyzerTimer::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:AnalyzerTimer:%d",__FILE__,__LINE__);
++        // Serialize Timer
++        ar & boost::serialization::base_object<Timer>(*this);
++
++        ar & analyzer;
++       
++        //ar & timer; //FIXME
++
++        ar & do_expire;
++    }
++template void AnalyzerTimer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void AnalyzerTimer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ AnalyzerID Analyzer::id_counter = 0;;
+ 
+ Analyzer* Analyzer::InstantiateAnalyzer(AnalyzerTag::Tag tag, Connection* c)
+@@ -248,11 +274,13 @@
+ 	resp_supporters = 0;
+ 	signature = 0;
+ 	output_handler = 0;
++    timers_canceled = false;
++    moved = false;
+ 	}
+ 
+ Analyzer::~Analyzer()
+ 	{
+-	assert(finished);
++	//assert(moved || finished); // SDMBN-FIXME
+ 
+ 	LOOP_OVER_CHILDREN(i)
+ 		delete *i;
+@@ -272,6 +300,9 @@
+ 		}
+ 
+ 	delete output_handler;
++
++    if (moved)
++    { CancelTimers(); }
+ 	}
+ 
+ void Analyzer::Init()
+@@ -291,6 +322,9 @@
+ 
+ void Analyzer::Done()
+ 	{
++    if (moved)
++    { return; }
++
+ 	assert(!finished);
+ 
+ 	if ( ! skip )
+@@ -863,6 +897,86 @@
+ 		(*i)->UpdateConnVal(conn_val);
+ 	}
+ 
++void Analyzer::Moved()
++    {
++    moved = true;
++	
++	for ( SupportAnalyzer* a = orig_supporters; a; a = a->sibling )
++    { a->Moved(); }
++
++	for ( SupportAnalyzer* a = resp_supporters; a; a = a->sibling )
++    { a->Moved(); }
++
++    for (std::list<Analyzer*>::iterator it = children.begin(); 
++              it != children.end(); it++)
++    { (*it)->Moved(); }
++        
++    for (std::list<Analyzer*>::iterator it = new_children.begin(); 
++            it != new_children.end(); it++)
++    { (*it)->Moved(); }
++    }
++
++BOOST_CLASS_EXPORT_GUID(Analyzer,"Analyzer")
++template<class Archive>
++void Analyzer::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:Analyzer:%d",__FILE__,__LINE__);
++
++        ar & tag;
++        ar & id;
++        ar & conn; 
++
++        // Special check for analyzer serializability
++        if (!Archive::is_loading::value)
++        {
++            if (parent != NULL)
++            { assert(sdmbn_can_serialize(parent->GetTag())); }
++        }
++        SERIALIZE_PRINT("\t\tAnalyzer:%d",__LINE__);
++        ar & parent;
++        //ar & signature; //Include? Does not seem to be used
++        if (Archive::is_loading::value) { signature = NULL; }
++        //ar & output_handler //Include? Only used in HTTP.cc:190
++        if (Archive::is_loading::value) { output_handler = NULL; }
++        
++        // Special check for analyzer serializability
++        if (!Archive::is_loading::value)
++        {
++            for (std::list<Analyzer*>::iterator it = children.begin(); 
++                    it != children.end(); it++)
++            { assert(sdmbn_can_serialize((*it)->GetTag())); }
++
++            if (orig_supporters != NULL)
++            { assert(sdmbn_can_serialize(orig_supporters->GetTag())); }
++        
++            if (resp_supporters != NULL)
++            { assert(sdmbn_can_serialize(resp_supporters->GetTag())); }
++        
++            for (std::list<Analyzer*>::iterator it = new_children.begin(); 
++                    it != new_children.end(); it++)
++            { assert(sdmbn_can_serialize((*it)->GetTag())); }
++        }
++        ar & children;
++        ar & orig_supporters;
++        ar & resp_supporters;
++        ar & new_children;
++
++        SERIALIZE_PRINT("\t\tAnalyzer:%d",__LINE__);
++        ar & protocol_confirmed;
++        //ar & timers; //FIXME //Should include?
++        ar & timers_canceled;
++        ar & skip;
++        ar & finished;
++        ar & removing;
++        SERIALIZE_PRINT("\t\tAnalyzer:Done");
++    }
++template void Analyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar,
++        const unsigned int file_version);
++template void Analyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar,
++        const unsigned int file_version);
++
+ void SupportAnalyzer::ForwardPacket(int len, const u_char* data, bool is_orig,
+ 					int seq, const IP_Hdr* ip, int caplen)
+ 	{
+@@ -906,6 +1020,26 @@
+ 		Parent()->Undelivered(seq, len, is_orig);
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(SupportAnalyzer,"SupportAnalyzer")
++template<class Archive>
++void SupportAnalyzer::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:SupportAnalyzer:%d",__FILE__,__LINE__);
++
++        // Serialize Analyzer
++        ar & boost::serialization::base_object<Analyzer>( *this );
++
++        SERIALIZE_PRINT("\t\tSupportAnalyzer:%d",__LINE__);
++        ar & orig;
++        ar & sibling;
++        SERIALIZE_PRINT("\t\tSupportAnalyzer:Done");
++    }
++template void SupportAnalyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar,
++        const unsigned int file_version);
++template void SupportAnalyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar,
++        const unsigned int file_version);
+ 
+ void TransportLayerAnalyzer::Done()
+ 	{
+@@ -934,3 +1068,23 @@
+ 		}
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(TransportLayerAnalyzer,"TransportLayerAnalyzer")
++template<class Archive>
++void TransportLayerAnalyzer::serialize(Archive & ar, 
++        const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:TransportLayerAnalyzer:%d",__FILE__,__LINE__);
++
++        // Serialize Analyzer
++        ar & boost::serialization::base_object<Analyzer>(*this);
++
++        SERIALIZE_PRINT("\t\tTransportLayerAnalyzer:%d",__LINE__);
++        ar & pia;
++        SERIALIZE_PRINT("\t\tTransportLayerAnalyzer:Done");
++    }
++template void TransportLayerAnalyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar,
++        const unsigned int file_version);
++template void TransportLayerAnalyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar,
++        const unsigned int file_version);
+diff -urN bro-2.1/src/Analyzer.h bro-2.1-sdmbn/src/Analyzer.h
+--- bro-2.1/src/Analyzer.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Analyzer.h	2014-02-17 17:20:06.000000003 -0600
+@@ -8,6 +8,7 @@
+ #include "AnalyzerTags.h"
+ #include "Conn.h"
+ #include "Obj.h"
++#include <boost/serialization/access.hpp>
+ 
+ class DPM;
+ class PIA;
+@@ -36,6 +37,10 @@
+ 	Analyzer* analyzer;
+ 	analyzer_timer_func timer;
+ 	int do_expire;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ 
+@@ -253,6 +258,9 @@
+ 
+ 	// Factory function to instantiate new analyzers.
+ 	static Analyzer* InstantiateAnalyzer(AnalyzerTag::Tag tag, Connection* c);
++    
++    void Moved();
++    bool HasMoved() { return moved; }
+ 
+ protected:
+ 	friend class DPM;
+@@ -260,7 +268,7 @@
+ 	friend class AnalyzerTimer;
+ 	friend class TCP_ApplicationAnalyzer;
+ 
+-	Analyzer()	{ }
++	Analyzer()	{ moved = false; }
+ 
+ 	// Associates a connection with this analyzer.  Must be called if
+ 	// we're using the default ctor.
+@@ -326,6 +334,11 @@
+ 	// Table of analyzers.
+ 	static const Config analyzer_configs[];
+ 
++    bool moved;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ #define ADD_ANALYZER_TIMER(timer, t, do_expire, type) \
+@@ -373,8 +386,11 @@
+ 	// Points to next support analyzer in chain.  The list is managed by
+ 	// parent analyzer.
+ 	SupportAnalyzer* sibling;
+-};
+ 
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++};
+ 
+ class TransportLayerAnalyzer : public Analyzer {
+ public:
+@@ -398,6 +414,10 @@
+ 
+ private:
+ 	PIA* pia;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/Attr.cc bro-2.1-sdmbn/src/Attr.cc
+--- bro-2.1/src/Attr.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Attr.cc	2014-02-17 17:20:06.000000003 -0600
+@@ -6,6 +6,10 @@
+ #include "Expr.h"
+ #include "Serializer.h"
+ #include "threading/SerialTypes.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include "SDMBNlocal.h"
+ 
+ const char* attr_name(attr_tag t)
+ 	{
+@@ -548,3 +552,21 @@
+ 	return true;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(Attributes,"Attributes")
++template<class Archive>
++void Attributes::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:Attributes:%d",__FILE__,__LINE__);
++        // Serialize BroObj
++        ar & boost::serialization::base_object<BroObj>(*this);
++
++        ar & type;
++        ar & attrs;
++        ar & in_record;
++    }
++template void Attributes::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void Attributes::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/Attr.h bro-2.1-sdmbn/src/Attr.h
+--- bro-2.1/src/Attr.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Attr.h	2014-02-17 17:20:06.000000003 -0600
+@@ -4,6 +4,7 @@
+ #define attr_h
+ 
+ #include "Obj.h"
++#include <boost/serialization/access.hpp>
+ 
+ class Expr;
+ 
+@@ -107,6 +108,10 @@
+ 	BroType* type;
+ 	attr_list* attrs;
+ 	bool in_record;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/Base64.cc bro-2.1-sdmbn/src/Base64.cc
+--- bro-2.1/src/Base64.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Base64.cc	2014-02-17 17:20:06.000000003 -0600
+@@ -1,5 +1,10 @@
+ #include "config.h"
+ #include "Base64.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include <boost/serialization/binary_object.hpp>
++#include "SDMBNlocal.h"
+ 
+ int Base64Decoder::default_base64_table[256];
+ const string Base64Decoder::default_alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+@@ -163,6 +168,46 @@
+ 	return 0;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(Base64Decoder,"Base64Decoder")
++template<class Archive>
++void Base64Decoder::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:Base64Decoder:%d",__FILE__,__LINE__);
++
++        ar & error_msg;
++        ar & base64_group;
++        ar & base64_group_next;
++        ar & base64_padding;
++        ar & base64_after_padding;
++        ar & errored;
++
++        // Special check for analyzer serializability
++        if (!Archive::is_loading::value)
++        {
++            if (analyzer != NULL)
++            { assert(sdmbn_can_serialize(analyzer->GetTag())); }
++        }
++        ar & analyzer;
++
++        // Special handling of base64_table
++        if (!Archive::is_loading::value)
++        { 
++            ar & boost::serialization::make_binary_object(base64_table,
++                    256*sizeof(int)); 
++        }
++        if (Archive::is_loading::value)
++        {
++            base64_table = new int[256];
++            ar & boost::serialization::make_binary_object(base64_table,
++                    256*sizeof(int));
++        }
++    }
++template void Base64Decoder::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void Base64Decoder::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+ 
+ BroString* decode_base64(const BroString* s, const BroString* a)
+ 	{
+diff -urN bro-2.1/src/Base64.h bro-2.1-sdmbn/src/Base64.h
+--- bro-2.1/src/Base64.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Base64.h	2014-02-17 17:20:06.000000003 -0600
+@@ -8,6 +8,7 @@
+ #include "util.h"
+ #include "BroString.h"
+ #include "Analyzer.h"
++#include <boost/serialization/access.hpp>
+ 
+ // Maybe we should have a base class for generic decoders?
+ 
+@@ -62,6 +63,12 @@
+ 	static int* InitBase64Table(const string& alphabet);
+ 	static int default_base64_table[256];
+ 	static const string default_alphabet;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    Base64Decoder() {}; // Dummy default constructor for serialization
+ };
+ 
+ BroString* decode_base64(const BroString* s, const BroString* a = 0);
+diff -urN bro-2.1/src/BroString.cc bro-2.1-sdmbn/src/BroString.cc
+--- bro-2.1/src/BroString.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/BroString.cc	2014-02-17 17:20:06.000000003 -0600
+@@ -10,6 +10,11 @@
+ #include "BroString.h"
+ #include "Var.h"
+ #include "Reporter.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include <boost/serialization/binary_object.hpp>
++#include "SDMBNlocal.h"
+ 
+ #ifdef DEBUG
+ #define DEBUG_STR(msg) DBG_LOG(DBG_STRING, msg)
+@@ -61,6 +66,7 @@
+ 	{
+ 	b = 0;
+ 	n = 0;
++	final_NUL = 0;
+ 	use_free_to_delete = 0;
+ 	*this = bs;
+ 	}
+@@ -408,6 +414,51 @@
+ 	return strdup(result.c_str());
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(BroString,"BroString")
++template<class Archive>
++void BroString::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:BroString:%d",__FILE__,__LINE__);
++
++        // Special handling of bit fields
++        unsigned int bitfields = 0;
++        if (!Archive::is_loading::value)
++        {
++            bitfields |= (final_NUL << 0);
++        }
++        ar & bitfields;
++        if (Archive::is_loading::value)
++        {
++            final_NUL = (bitfields >> 0) & 0x1;
++        }
++
++        ar & n;
++
++        // Special handling of buffer
++        if (!Archive::is_loading::value)
++        {
++            if (n > 0)
++            { ar & boost::serialization::make_binary_object(b, n+final_NUL); }
++        }
++        if (Archive::is_loading::value)
++        {
++            if (n > 0)
++            {
++                b = new u_char[n + final_NUL];
++                ar & boost::serialization::make_binary_object(b, n+final_NUL);
++                use_free_to_delete = 0;
++            }
++            else
++            { b = 0; }
++        }
++    }
++template void BroString::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void BroString::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ bool BroStringLenCmp::operator()(BroString * const& bst1,
+ 				 BroString * const& bst2)
+ 	{
+@@ -500,6 +551,12 @@
+ 	return concatenate(cv);
+ 	}
+ 
++void delete_strings(std::vector<BroString*>& v)
++	{
++	for ( unsigned int i = 0; i < v.size(); ++i )
++		delete v[i];
++	v.clear();
++	}
+ void delete_strings(std::vector<const BroString*>& v)
+ 	{
+ 	for ( unsigned int i = 0; i < v.size(); ++i )
+diff -urN bro-2.1/src/BroString.h bro-2.1-sdmbn/src/BroString.h
+--- bro-2.1/src/BroString.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/BroString.h	2014-02-17 17:20:06.000000003 -0600
+@@ -8,6 +8,7 @@
+ #include <iostream>
+ #include <stdlib.h>
+ #include <sys/types.h>
++#include <boost/serialization/access.hpp>
+ using namespace std;
+ 
+ #include "util.h"
+@@ -150,6 +151,10 @@
+ 	int n;
+ 	unsigned int final_NUL:1;	// whether we have added a final NUL
+ 	unsigned int use_free_to_delete:1;	// free() vs. operator delete
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ // A comparison class that sorts pointers to BroString's according to
+@@ -186,6 +191,7 @@
+ extern BroString* concatenate(std::vector<data_chunk_t>& v);
+ extern BroString* concatenate(BroString::Vec& v);
+ extern BroString* concatenate(BroString::CVec& v);
++extern void delete_strings(std::vector<BroString*>& v);
+ extern void delete_strings(std::vector<const BroString*>& v);
+ 
+ #endif
+diff -urN bro-2.1/src/CMakeLists.txt bro-2.1-sdmbn/src/CMakeLists.txt
+--- bro-2.1/src/CMakeLists.txt	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/CMakeLists.txt	2014-02-17 17:20:06.000000003 -0600
+@@ -378,6 +378,7 @@
+     RuleCondition.cc
+     RuleMatcher.cc
+     ScriptAnaly.cc
++    SDMBNlocal.cc
+     SmithWaterman.cc
+     SMB.cc
+     SMTP.cc
+diff -urN bro-2.1/src/code.tmp bro-2.1-sdmbn/src/code.tmp
+--- bro-2.1/src/code.tmp	1969-12-31 18:00:00.000000000 -0600
++++ bro-2.1-sdmbn/src/code.tmp	2014-02-17 17:20:07.000000003 -0600
+@@ -0,0 +1,45 @@
++        if (Archive::is_loading::value) {  = NULL; } //TMPHACK
++
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include <SDMBN.h>
++#include "SDMBNlocal.h"
++
++#include <boost/serialization/list.hpp>
++
++BOOST_CLASS_EXPORT_GUID(,"")
++template<class Archive>
++void ::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s::%d",__FILE__,__LINE__);
++        // Serialize 
++        ar & boost::serialization::base_object<>(*this);
++    }
++template void ::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void ::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
++#include <boost/serialization/binary_object.hpp>
++
++        // Special handling of buffer
++        if (!Archive::is_loading::value)
++        { ar & boost::serialization::make_binary_object(buf, buf_len); }
++        if (Archive::is_loading::value)
++        {
++            buf = new u_char[buf_len];
++            ar & boost::serialization::make_binary_object(buf, buf_len);
++        }
++
++#include <boost/serialization/access.hpp>
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    () {}; // Dummy default constructor for serialization
++
++
+diff -urN bro-2.1/src/CompHash.cc bro-2.1-sdmbn/src/CompHash.cc
+--- bro-2.1/src/CompHash.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/CompHash.cc	2014-02-17 17:20:06.000000003 -0600
+@@ -6,6 +6,11 @@
+ #include "Val.h"
+ #include "Reporter.h"
+ #include "Func.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include <boost/serialization/binary_object.hpp>
++#include "SDMBNlocal.h"
+ 
+ CompositeHash::CompositeHash(TypeList* composite_type)
+ 	{
+@@ -917,3 +922,38 @@
+ 
+ 	return kp1;
+ 	}
++
++BOOST_CLASS_EXPORT_GUID(CompositeHash,"Compositehash")
++template<class Archive>
++void CompositeHash::serialize(Archive & ar, const unsigned int version)
++    {
++        ar & type;
++        ar & size;
++
++        // Special handling of key 
++        if (!Archive::is_loading::value)
++        { 
++            if (size > 0)
++            { ar & boost::serialization::make_binary_object(key, size); }
++        }
++        if (Archive::is_loading::value)
++        {
++            if (size > 0)
++            {
++                key = new char[size];
++                ar & boost::serialization::make_binary_object(key, size);
++            }
++            else
++            { key = NULL; }
++        }
++
++        ar & is_singleton;
++        ar & is_complex_type;
++        ar & singleton_tag;
++    }
++template void CompositeHash::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void CompositeHash::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/CompHash.h bro-2.1-sdmbn/src/CompHash.h
+--- bro-2.1/src/CompHash.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/CompHash.h	2014-02-17 17:20:06.000000003 -0600
+@@ -5,6 +5,7 @@
+ 
+ #include "Hash.h"
+ #include "Type.h"
++#include <boost/serialization/access.hpp>
+ 
+ class ListVal;
+ 
+@@ -88,6 +89,12 @@
+ 	int is_complex_type;
+ 
+ 	InternalTypeTag singleton_tag;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    CompositeHash() {}; // Dummy default constructor for serialization
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/Conn.cc bro-2.1-sdmbn/src/Conn.cc
+--- bro-2.1/src/Conn.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Conn.cc	2014-02-17 17:20:06.000000003 -0600
+@@ -14,6 +14,10 @@
+ #include "PIA.h"
+ #include "binpac.h"
+ #include "TunnelEncapsulation.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include "SDMBNlocal.h"
+ 
+ void ConnectionTimer::Init(Connection* arg_conn, timer_func arg_timer,
+ 				int arg_do_expire)
+@@ -106,6 +110,62 @@
+ 	return true;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(ConnectionTimer,"ConnectionTimer")
++template<class Archive>
++void ConnectionTimer::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:ConnectionTimer:%d",__FILE__,__LINE__);
++        // Serialize Timer
++        ar & boost::serialization::base_object<Timer>(*this);
++
++        ar & conn;
++
++        // Special handling of timer
++        char type = 0;
++        if (!Archive::is_loading::value)
++        {
++            if ( timer == timer_func(&Connection::DeleteTimer) )
++                type = 'D';
++            else if ( timer == timer_func(&Connection::InactivityTimer) )
++                type = 'I';
++            else if ( timer == timer_func(&Connection::StatusUpdateTimer) )
++                type = 'S';
++            else if ( timer == timer_func(&Connection::RemoveConnectionTimer) )
++                type = 'R';
++            else
++                assert("Unkown timer type" && false);
++        }
++        ar & type;
++        if (Archive::is_loading::value)
++        {
++            switch(type)
++            {
++            case 'D':
++                timer = timer_func(&Connection::DeleteTimer);
++                break;
++            case'I':
++                timer = timer_func(&Connection::InactivityTimer);
++                break;
++            case 'S':
++                timer = timer_func(&Connection::StatusUpdateTimer);
++                break;
++            case 'R':
++                timer = timer_func(&Connection::RemoveConnectionTimer);
++                break;
++            default:
++                assert("Unkown timer type" && false);
++            }
++        }
++
++        ar & do_expire;
++    }
++template void ConnectionTimer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void ConnectionTimer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ unsigned int Connection::total_connections = 0;
+ unsigned int Connection::current_connections = 0;
+ unsigned int Connection::external_connections = 0;
+@@ -175,13 +235,29 @@
+ 		ADD_TIMER(&Connection::RemoveConnectionTimer, 1e20, 1,
+ 				TIMER_REMOVE_CONNECTION);
+ 		}
++
++    moved = false; // Flag to indicate object has moved
++
++    // initialize pthread here
++    assert(0 == pthread_mutex_init(&lock, NULL));
+ 	}
+ 
++Connection::Connection()
++    {
++        persistent = 0;
++        moved = false; // Flag to indicate object has moved
++        // initialize pthread here
++        assert(0 == pthread_mutex_init(&lock, NULL));
++    }
++
+ Connection::~Connection()
+ 	{
+-	if ( ! finished )
++	if ( ! finished && !moved )
+ 		reporter->InternalError("Done() not called before destruction of Connection");
+ 
++    // destroy mutex
++    pthread_mutex_destroy(&lock);
++
+ 	CancelTimers();
+ 
+ 	if ( conn_val )
+@@ -966,3 +1042,120 @@
+ 	else
+ 		saw_first_resp_packet = 1;
+ 	}
++
++void Connection::Moved()
++    {
++    moved = true;
++    if (root_analyzer)
++    { root_analyzer->Moved(); }
++    }
++
++BOOST_CLASS_EXPORT_GUID(Connection,"Connection")
++template<class Archive>
++void Connection::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:Connection:%d",__FILE__,__LINE__);
++
++        // Serialize BroObj
++        ar & boost::serialization::base_object<BroObj>(*this);
++
++        // Special handling of sessions field
++        if (Archive::is_loading::value)
++        { sessions = ::sessions; }
++
++        ar & key; 
++
++        // Special handling of conn_timer_mgr
++        if (!Archive::is_loading::value)
++        {
++            if (conn_timer_mgr)
++            {
++                // Use local conn_timer_mgr
++            }
++            else
++            {
++                // Use global conn_timer_mgr
++            }
++        }
++        //ar & conn_timer_mgr; // Not sure if this should be included
++        if (Archive::is_loading::value) { conn_timer_mgr = NULL; } //TMPHACK
++        //ar & timers; // Not sure if this should be included
++        ar &  orig_addr;
++        ar &  resp_addr;
++        ar &  orig_port; 
++        ar &  resp_port; 
++        ar &  proto;
++        ar &  orig_flow_label; 
++        ar &  resp_flow_label; 
++        ar &  start_time; 
++        ar &  last_time; 
++        ar &  inactivity_timeout; 
++
++        // Special handling of conn_val field
++        if (Archive::is_loading::value) 
++        { 
++            // Set conn_val to NULL, so it is rebuilt if needed
++            conn_val = NULL; 
++        } 
++    
++        // Special handling of login_conn field
++        bool has_login_conn = false;
++        if (!Archive::is_loading::value)
++        { has_login_conn = (true && login_conn); }
++        ar & has_login_conn;
++        if (Archive::is_loading::value)
++        { login_conn = has_login_conn ? (LoginConn*) this : 0; }
++
++//        ar &  encapsulation; //Beware: this is a vector of related conns //REINCLUDE
++        if (Archive::is_loading::value) { encapsulation = NULL; } //TMPHACK
++        ar &  suppress_event; 
++
++        // Special handling of bit fields
++        unsigned int bitfields = 0;
++        if (!Archive::is_loading::value)
++        {
++            bitfields |= (installed_status_timer << 0);
++            bitfields |= (timers_canceled << 1);
++            bitfields |= (is_active << 2); 
++            bitfields |= (skip << 3);
++            bitfields |= (weird << 4);
++            bitfields |= (finished << 5);
++            bitfields |= (record_packets << 6);
++            bitfields |= (record_contents << 7);
++            bitfields |= (persistent << 8);
++            bitfields |= (record_current_packet << 9);
++            bitfields |= (record_current_content << 10);
++            bitfields |= (saw_first_orig_packet << 11);
++            bitfields |= (saw_first_resp_packet << 12);
++        }
++        ar & bitfields;
++        if (Archive::is_loading::value)
++        {
++            installed_status_timer = (bitfields >> 0) & 0x1;
++            timers_canceled = (bitfields >> 1) & 0x1;
++            is_active = (bitfields >> 2) & 0x1; 
++            skip = (bitfields >> 3) & 0x1;
++            weird = (bitfields >> 4) & 0x1;
++            finished = (bitfields >> 5) & 0x1;
++            record_packets = (bitfields >> 6) & 0x1;
++            record_contents = (bitfields >> 7) & 0x1;
++            persistent = (bitfields >> 8) & 0x1;
++            record_current_packet = (bitfields >> 9) & 0x1;
++            record_current_content = (bitfields >> 10) & 0x1;
++            saw_first_orig_packet = (bitfields >> 11) & 0x1;
++            saw_first_resp_packet = (bitfields >> 12) & 0x1;
++        }
++
++        ar & history;
++        ar & hist_seen;
++        ar & root_analyzer;
++        ar & primary_PIA;
++        ar & uid;
++        SERIALIZE_PRINT("\t\tConnection:Done");
++    }
++template void Connection::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void Connection::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/Conn.h bro-2.1-sdmbn/src/Conn.h
+--- bro-2.1/src/Conn.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Conn.h	2014-02-17 17:20:06.000000003 -0600
+@@ -14,6 +14,7 @@
+ #include "AnalyzerTags.h"
+ #include "IPAddr.h"
+ #include "TunnelEncapsulation.h"
++#include <boost/serialization/access.hpp>
+ 
+ class Connection;
+ class ConnectionTimer;
+@@ -23,6 +24,7 @@
+ class Specific_RE_Matcher;
+ class TransportLayerAnalyzer;
+ class RuleEndpointState;
++class PIA;
+ 
+ typedef enum {
+ 	NUL_IN_LINE,
+@@ -256,10 +258,25 @@
+ 		{ return encapsulation; }
+ 
+ 	void CheckFlowLabel(bool is_orig, uint32 flow_label);
++	
++    Connection();
+ 
+-protected:
++    void Moved();
++    bool HasMoved() { return moved; }
++
++    // manipulation methods for dirty marker
++    bool isDirty() { return dirty; }
++    void setDirty(bool dirtyVal) { dirty = dirtyVal; }
++    int dirtyBackoff() { return dirty_backoff; }
++    void setDirtyBackoff(int dirtyBackoff) { dirty_backoff = dirtyBackoff; } 
++    int getGetOpId() { return getOpId; }
++    void setGetOpId(int opId) { getOpId = opId; }
++    void initLock() { assert(0 == pthread_mutex_init(&lock, NULL)); /* = PTHREAD_MUTEX_INITIALIZER; */ }
++	uint32_t getOpId; /* last SDMBN get call that returned this */
++    // keep a lock per connection
++    pthread_mutex_t lock;
+ 
+-	Connection()	{ persistent = 0; }
++protected:
+ 
+ 	// Add the given timer to expire at time t.  If do_expire
+ 	// is true, then the timer is also evaluated when Bro terminates,
+@@ -318,6 +335,16 @@
+ 	PIA* primary_PIA;
+ 
+ 	uint64 uid;	// Globally unique connection ID.
++
++    bool moved;
++
++    // mark a connection as dirty
++    bool dirty;
++    int dirty_backoff;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class ConnectionTimer : public Timer {
+@@ -340,6 +367,10 @@
+ 	Connection* conn;
+ 	timer_func timer;
+ 	int do_expire;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ #define ADD_TIMER(timer, t, do_expire, type) \
+diff -urN bro-2.1/src/ConnSizeAnalyzer.cc bro-2.1-sdmbn/src/ConnSizeAnalyzer.cc
+--- bro-2.1/src/ConnSizeAnalyzer.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/ConnSizeAnalyzer.cc	2014-02-17 17:20:06.000000003 -0600
+@@ -5,6 +5,9 @@
+ 
+ #include "ConnSizeAnalyzer.h"
+ #include "TCP.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
+ 
+ 
+ 
+@@ -86,3 +89,21 @@
+ 	resp_pkts = tmp;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(ConnSize_Analyzer,"ConnSize_Analyzer")
++template<class Archive>
++void ConnSize_Analyzer::serialize(Archive & ar, const unsigned int version)
++    {
++        // Serialize Analyzer
++        ar & boost::serialization::base_object<Analyzer>(*this);
++
++        ar & orig_bytes;
++        ar & resp_bytes;
++        ar & orig_pkts;
++        ar & resp_pkts;
++    }
++template void ConnSize_Analyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void ConnSize_Analyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/ConnSizeAnalyzer.h bro-2.1-sdmbn/src/ConnSizeAnalyzer.h
+--- bro-2.1/src/ConnSizeAnalyzer.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/ConnSizeAnalyzer.h	2014-02-17 17:20:06.000000003 -0600
+@@ -6,6 +6,7 @@
+ 
+ #include "Analyzer.h"
+ #include "NetVar.h"
++#include <boost/serialization/access.hpp>
+ 
+ 
+ class ConnSize_Analyzer : public Analyzer {
+@@ -34,6 +35,12 @@
+ 	uint64_t resp_bytes;
+ 	uint64_t orig_pkts;
+ 	uint64_t resp_pkts;
++    
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    ConnSize_Analyzer() {}; // Dummy default constructor for serialization
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/ContentLine.cc bro-2.1-sdmbn/src/ContentLine.cc
+--- bro-2.1/src/ContentLine.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/ContentLine.cc	2014-02-17 17:20:06.000000003 -0600
+@@ -2,6 +2,11 @@
+ 
+ #include "ContentLine.h"
+ #include "TCP.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include <boost/serialization/binary_object.hpp>
++#include "SDMBNlocal.h"
+ 
+ ContentLine_Analyzer::ContentLine_Analyzer(Connection* conn, bool orig)
+ : TCP_SupportAnalyzer(AnalyzerTag::ContentLine, conn, orig)
+@@ -23,6 +28,9 @@
+ 	skip_deliveries = 0;
+ 	skip_partial = 0;
+ 	buf = 0;
++    offset = 0;
++    buf_len = 0;
++    last_char = 0;
+ 	seq_delivered_in_lines = 0;
+ 	skip_pending = 0;
+ 	seq = 0;
+@@ -332,3 +340,61 @@
+ 	seq_to_skip = SeqDelivered() + length;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(ContentLine_Analyzer,"ContentLine_Analyzer")
++template<class Archive>
++void ContentLine_Analyzer::serialize(Archive & ar, const unsigned int version)
++    {
++        // Serialize TCP_SupportAnalyzer
++        ar & boost::serialization::base_object<TCP_SupportAnalyzer>(*this);
++
++        ar & buf_len;
++
++        // Special handling of buffer
++        if (!Archive::is_loading::value)
++        { 
++            if (buf_len > 0)
++            { ar & boost::serialization::make_binary_object(buf, buf_len); }
++        }
++        if (Archive::is_loading::value)
++        {
++            if (buf_len > 0)
++            {
++                buf = new u_char[buf_len];
++                ar & boost::serialization::make_binary_object(buf, buf_len);
++            }
++            else
++            { buf = 0; }
++        }
++
++        ar & offset;
++        ar & last_char;
++        ar & seq;
++        ar & seq_to_skip;
++        ar & seq_delivered_in_lines;
++        ar & skip_pending;
++        ar & plain_delivery_length;
++        ar & is_plain;
++        ar & skip_deliveries;
++
++        // Special handling of bit fields
++        unsigned int bitfields = 0;
++        if (!Archive::is_loading::value)
++        {
++            bitfields |= (flag_NULs << 0);
++            bitfields |= (CR_LF_as_EOL << 1);
++            bitfields |= (skip_partial << 3);
++        }
++        ar & bitfields;
++        if (Archive::is_loading::value)
++        {
++            flag_NULs = (bitfields >> 0) & 0x1;
++            CR_LF_as_EOL = (bitfields >> 1) & 0x3;
++            skip_partial = (bitfields >> 3) & 0x1;
++        }
++    }
++template void ContentLine_Analyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void ContentLine_Analyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/ContentLine.h bro-2.1-sdmbn/src/ContentLine.h
+--- bro-2.1/src/ContentLine.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/ContentLine.h	2014-02-17 17:20:06.000000003 -0600
+@@ -4,6 +4,7 @@
+ #define CONTENTLINE_H
+ 
+ #include "TCP.h"
++#include <boost/serialization/access.hpp>
+ 
+ #define CR_as_EOL 1
+ #define LF_as_EOL 2
+@@ -102,6 +103,28 @@
+ 
+ 	// Whether to skip partial conns.
+ 	unsigned int skip_partial:1;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    ContentLine_Analyzer() 
++    {
++        buf_len = 0;
++        offset = 0;
++        last_char = 0;
++        flag_NULs = 0;
++        CR_LF_as_EOL = (CR_as_EOL | LF_as_EOL);
++        skip_deliveries = 0;
++        skip_partial = 0;
++        buf = 0;
++        seq_delivered_in_lines = 0;
++        skip_pending = 0;
++        seq = 0;
++        seq_to_skip = 0;
++        plain_delivery_length = 0;
++        is_plain = 0;
++    }; // Dummy default constructor for serialization
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/DNS.cc bro-2.1-sdmbn/src/DNS.cc
+--- bro-2.1/src/DNS.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/DNS.cc	2014-02-17 17:20:06.000000003 -0600
+@@ -11,6 +11,11 @@
+ #include "DNS.h"
+ #include "Sessions.h"
+ #include "Event.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include <boost/serialization/binary_object.hpp>
++#include "SDMBNlocal.h"
+ 
+ DNS_Interpreter::DNS_Interpreter(Analyzer* arg_analyzer)
+ 	{
+@@ -859,6 +864,18 @@
+ 	analyzer->ConnectionEvent(event, vl);
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(DNS_Interpreter,"DNS_Interpreter")
++template<class Archive>
++void DNS_Interpreter::serialize(Archive & ar, const unsigned int version)
++    {
++        ar & analyzer; 
++    }
++template void DNS_Interpreter::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void DNS_Interpreter::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+ 
+ DNS_MsgInfo::DNS_MsgInfo(DNS_RawMsgHdr* hdr, int arg_is_query)
+ 	{
+@@ -1079,6 +1096,37 @@
+ 		DeliverStream(len - n, data + n, orig);
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(Contents_DNS,"Contents_DNS")
++template<class Archive>
++void Contents_DNS::serialize(Archive & ar, const unsigned int version)
++    {
++        // Serialize TCP_SupportAnalyzer
++        ar & boost::serialization::base_object<TCP_SupportAnalyzer>(*this);
++
++        ar & interp;
++        ar & buf_n;
++        ar & buf_len;
++
++        // Special handling of buffer
++        if (!Archive::is_loading::value)
++        { ar & boost::serialization::make_binary_object(msg_buf, buf_len); }
++        if (Archive::is_loading::value)
++        {
++            msg_buf = (u_char*)malloc(buf_len);
++            assert(msg_buf != NULL);
++            ar & boost::serialization::make_binary_object(msg_buf, buf_len);
++        }
++
++        ar & msg_size;
++        ar & state;
++    }
++template void Contents_DNS::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void Contents_DNS::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ DNS_Analyzer::DNS_Analyzer(Connection* conn)
+ : TCP_ApplicationAnalyzer(AnalyzerTag::DNS, conn)
+ 	{
+@@ -1165,3 +1213,25 @@
+ 		ADD_ANALYZER_TIMER(&DNS_Analyzer::ExpireTimer,
+ 				t + dns_session_timeout, 1, TIMER_DNS_EXPIRE);
+ 	}
++
++BOOST_CLASS_EXPORT_GUID(DNS_Analyzer,"DNS_Analyzer")
++template<class Archive>
++void DNS_Analyzer::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:DNS_Analyzer:%d",__FILE__,__LINE__);
++
++        // Serialize TransportLayerAnalyzer
++        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
++
++        ar & interp;
++        ar & contents_dns_orig;
++        ar & contents_dns_resp;
++        ar & did_session_done;
++        SERIALIZE_PRINT("DNS_Analyzer:Done");
++    }
++template void DNS_Analyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar,
++        const unsigned int file_version);
++template void DNS_Analyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar,
++        const unsigned int file_version);
+diff -urN bro-2.1/src/DNS.h bro-2.1-sdmbn/src/DNS.h
+--- bro-2.1/src/DNS.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/DNS.h	2014-02-17 17:20:06.000000003 -0600
+@@ -5,6 +5,7 @@
+ 
+ #include "TCP.h"
+ #include "binpac_bro.h"
++#include <boost/serialization/access.hpp>
+ 
+ typedef enum {
+ 	DNS_OP_QUERY = 0,		///< standard query
+@@ -218,6 +219,12 @@
+ 					BroString* question_name);
+ 
+ 	Analyzer* analyzer;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    DNS_Interpreter() {}; // Dummy default constructor for serialization
+ };
+ 
+ 
+@@ -248,6 +255,12 @@
+ 	int buf_len;		///< size of msg_buf
+ 	int msg_size;		///< expected size of message
+ 	TCP_DNS_state state;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    Contents_DNS() {}; // Dummy default constructor for serialization
+ };
+ 
+ // Works for both TCP and UDP.
+@@ -280,6 +293,12 @@
+ 	Contents_DNS* contents_dns_orig;
+ 	Contents_DNS* contents_dns_resp;
+ 	int did_session_done;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    DNS_Analyzer() {}; // Dummy default constructor for serialization
+ };
+ 
+ // FIXME: Doesn't really fit into new analyzer structure. What to do?
+diff -urN bro-2.1/src/FileAnalyzer.cc bro-2.1-sdmbn/src/FileAnalyzer.cc
+--- bro-2.1/src/FileAnalyzer.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/FileAnalyzer.cc	2014-02-17 17:20:06.000000003 -0600
+@@ -2,6 +2,9 @@
+ 
+ #include "FileAnalyzer.h"
+ #include "Reporter.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
+ 
+ magic_t File_Analyzer::magic = 0;
+ magic_t File_Analyzer::magic_mime = 0;
+@@ -76,3 +79,20 @@
+ 		*magic = 0;
+ 		}
+ 	}
++
++BOOST_CLASS_EXPORT_GUID(File_Analyzer,"File_Analyzer")
++template<class Archive>
++void File_Analyzer::serialize(Archive & ar, const unsigned int version)
++    {
++        // Serialize TCP_ApplicationAnalyzer
++        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
++
++        ar & buffer;
++        ar & buffer_len;
++    }
++template void File_Analyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void File_Analyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/FileAnalyzer.h bro-2.1-sdmbn/src/FileAnalyzer.h
+--- bro-2.1/src/FileAnalyzer.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/FileAnalyzer.h	2014-02-17 17:20:06.000000003 -0600
+@@ -4,6 +4,7 @@
+ #define FILEANALYZER_H
+ 
+ #include "TCP.h"
++#include <boost/serialization/access.hpp>
+ 
+ #include <magic.h>
+ 
+@@ -33,6 +34,10 @@
+ 
+ 	static magic_t magic;
+ 	static magic_t magic_mime;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/File.cc bro-2.1-sdmbn/src/File.cc
+--- bro-2.1/src/File.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/File.cc	2014-02-17 17:20:06.000000003 -0600
+@@ -29,6 +29,11 @@
+ #include "Serializer.h"
+ #include "Event.h"
+ #include "Reporter.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include <boost/serialization/binary_object.hpp>
++#include "SDMBNlocal.h"
+ 
+ // Timer which on dispatching rotates the file.
+ class RotateTimer : public Timer {
+@@ -708,6 +713,7 @@
+ 
+ 	int buf_size = MIN_BUFFER_SIZE + EVP_CIPHER_block_size(cipher_type);
+ 	cipher_buffer = new unsigned char[buf_size];
++    cipher_size = buf_size;
+ 	}
+ 
+ void BroFile::FinishEncrypt()
+@@ -974,3 +980,122 @@
+ 
+ 	return true;
+ 	}
++
++BOOST_CLASS_EXPORT_GUID(BroFile,"BroFile")
++template<class Archive>
++void BroFile::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:BroFile:%d",__FILE__,__LINE__);
++        // Serialize BroObj
++        ar & boost::serialization::base_object<BroObj>(*this);
++
++        //ar & f; //FIXME
++        if (Archive::is_loading::value) { f = NULL; } //TMPHACK
++        ar & t;
++
++        // Special handling of name
++        int name_size;
++        if (!Archive::is_loading::value)
++        {
++            if (name)
++            { name_size = strlen(name); }
++            else
++            { name_size = 0; }
++        }
++        ar & name_size;
++        if (!Archive::is_loading::value)
++        { 
++            if (name_size > 0)
++            { ar & boost::serialization::make_binary_object(name, name_size); }
++        }
++        if (Archive::is_loading::value)
++        {
++            if (name_size > 0)
++            {
++                name = new char[name_size];
++                ar & boost::serialization::make_binary_object(name, name_size);
++            }
++            else
++            { name = NULL; }
++        }
++
++        // Special handling of access
++        int access_size;
++        if (!Archive::is_loading::value)
++        {
++            if (access)
++            { access_size = strlen(access); }
++            else
++            { access_size = 0; }
++        }
++        ar & access_size;
++        if (!Archive::is_loading::value)
++        { 
++            if (access_size > 0)
++            { 
++                ar & boost::serialization::make_binary_object(access,
++                        access_size); 
++            }
++        }
++        if (Archive::is_loading::value)
++        {
++            if (access_size > 0)
++            {
++                access = new char[access_size];
++                ar & boost::serialization::make_binary_object(access,
++                       access_size);
++            }
++            else
++            { access = NULL; }
++        }
++
++        ar & is_in_cache;
++        ar & is_open;
++        ar & okay_to_manage;
++        ar & position;
++        ar & next;
++        ar & prev;
++        ar & attrs;
++        ar & rotate_interval;
++        ar & buffered;
++        ar & rotate_size;
++        ar & current_size;
++        //ar & rotate_timer; //FIXME
++        if (Archive::is_loading::value) { rotate_timer = NULL; } //TMPHACK
++        ar & open_time;
++        ar & dont_rotate;
++        ar & print_hook;
++        ar & raw_output;
++        //ar & pub_key; //FIXME
++        if (Archive::is_loading::value) { pub_key = NULL; } //TMPHACK
++        //ar & cipher_ctx; //FIXME
++        if (Archive::is_loading::value) { cipher_ctx = NULL; } //TMPHACK
++
++        // Special handling of cipher_buffer
++        ar & cipher_size;
++        if (!Archive::is_loading::value)
++        { 
++            if (cipher_size > 0)
++            { 
++                ar & boost::serialization::make_binary_object(cipher_buffer,
++                        cipher_size); 
++            }
++        }
++        if (Archive::is_loading::value)
++        {
++            if (cipher_size > 0)
++            {
++                cipher_buffer = new u_char[cipher_size];
++                ar & boost::serialization::make_binary_object(cipher_buffer,
++                       cipher_size);
++            }
++            else
++            { cipher_buffer = NULL; }
++        }
++    }
++template void BroFile::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void BroFile::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/File.h bro-2.1-sdmbn/src/File.h
+--- bro-2.1/src/File.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/File.h	2014-02-17 17:20:06.000000003 -0600
+@@ -7,6 +7,7 @@
+ #include "util.h"
+ #include "Obj.h"
+ #include "Attr.h"
++#include <boost/serialization/access.hpp>
+ 
+ # ifdef NEED_KRB5_H
+ #  include <krb5.h>
+@@ -159,7 +160,11 @@
+ 
+ 	static const int MIN_BUFFER_SIZE = 1024;
+ 	unsigned char* cipher_buffer;
++    int cipher_size;
+ 
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/FTP.cc bro-2.1-sdmbn/src/FTP.cc
+--- bro-2.1/src/FTP.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/FTP.cc	2014-02-17 17:20:06.000000003 -0600
+@@ -8,6 +8,9 @@
+ #include "FTP.h"
+ #include "NVT.h"
+ #include "Event.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
+ 
+ FTP_Analyzer::FTP_Analyzer(Connection* conn)
+ : TCP_ApplicationAnalyzer(AnalyzerTag::FTP, conn)
+@@ -166,3 +169,21 @@
+ 	ConnectionEvent(f, vl);
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(FTP_Analyzer,"FTP_Analyzer")
++template<class Archive>
++void FTP_Analyzer::serialize(Archive & ar, const unsigned int version)
++    {
++        // Serialize TCP_ApplicationAnalyzer 
++        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
++
++        ar & nvt_orig;
++        ar & nvt_resp;
++        ar & pending_reply;
++        ar & auth_requested;
++    }
++template void FTP_Analyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void FTP_Analyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/FTP.h bro-2.1-sdmbn/src/FTP.h
+--- bro-2.1/src/FTP.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/FTP.h	2014-02-17 17:20:06.000000003 -0600
+@@ -5,6 +5,7 @@
+ 
+ #include "NVT.h"
+ #include "TCP.h"
++#include <boost/serialization/access.hpp>
+ 
+ class FTP_Analyzer : public TCP_ApplicationAnalyzer {
+ public:
+@@ -28,6 +29,10 @@
+ 	NVT_Analyzer* nvt_resp;
+ 	uint32 pending_reply;	// code associated with multi-line reply, or 0
+ 	string auth_requested;	// AUTH method requested
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/Hash.cc bro-2.1-sdmbn/src/Hash.cc
+--- bro-2.1/src/Hash.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Hash.cc	2014-02-17 17:20:06.000000003 -0600
+@@ -18,6 +18,10 @@
+ #include "config.h"
+ 
+ #include "Hash.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include <boost/serialization/binary_object.hpp>
+ 
+ #include "H3.h"
+ const H3<hash_t, UHASH_KEY_SIZE>* h3;
+@@ -36,6 +40,7 @@
+ 	size = sizeof(i);
+ 	hash = HashBytes(key, size);
+ 	is_our_dynamic = 0;
++    type = HASH_KEY_TYPE_INT;
+ 	}
+ 
+ HashKey::HashKey(bro_uint_t u)
+@@ -45,6 +50,7 @@
+ 	size = sizeof(u);
+ 	hash = HashBytes(key, size);
+ 	is_our_dynamic = 0;
++    type = HASH_KEY_TYPE_INT;
+ 	}
+ 
+ HashKey::HashKey(uint32 u)
+@@ -54,6 +60,7 @@
+ 	size = sizeof(u);
+ 	hash = HashBytes(key, size);
+ 	is_our_dynamic = 0;
++    type = HASH_KEY_TYPE_UINT;
+ 	}
+ 
+ HashKey::HashKey(const uint32 u[], int n)
+@@ -62,6 +69,7 @@
+ 	key = (void*) u;
+ 	hash = HashBytes(key, size);
+ 	is_our_dynamic = 0;
++    type = HASH_KEY_TYPE_NONE;
+ 	}
+ 
+ HashKey::HashKey(double d)
+@@ -76,6 +84,7 @@
+ 	size = sizeof(d);
+ 	hash = HashBytes(key, size);
+ 	is_our_dynamic = 0;
++    type = HASH_KEY_TYPE_DOUBLE;
+ 	}
+ 
+ HashKey::HashKey(const void* p)
+@@ -85,6 +94,7 @@
+ 	size = sizeof(p);
+ 	hash = HashBytes(key, size);
+ 	is_our_dynamic = 0;
++    type = HASH_KEY_TYPE_PTR;
+ 	}
+ 
+ HashKey::HashKey(const char* s)
+@@ -93,6 +103,7 @@
+ 	key = (void*) s;
+ 	hash = HashBytes(key, size);
+ 	is_our_dynamic = 0;
++    type = HASH_KEY_TYPE_NONE;
+ 	}
+ 
+ HashKey::HashKey(const BroString* s)
+@@ -101,6 +112,7 @@
+ 	key = (void*) s->Bytes();
+ 	hash = HashBytes(key, size);
+ 	is_our_dynamic = 0;
++    type = HASH_KEY_TYPE_NONE;
+ 	}
+ 
+ HashKey::HashKey(int copy_key, void* arg_key, int arg_size)
+@@ -117,6 +129,7 @@
+ 		key = arg_key;
+ 
+ 	hash = HashBytes(key, size);
++    type = HASH_KEY_TYPE_NONE;
+ 	}
+ 
+ HashKey::HashKey(const void* arg_key, int arg_size, hash_t arg_hash)
+@@ -125,6 +138,7 @@
+ 	hash = arg_hash;
+ 	key = CopyKey(arg_key, size);
+ 	is_our_dynamic = 1;
++    type = HASH_KEY_TYPE_NONE;
+ 	}
+ 
+ HashKey::HashKey(const void* arg_key, int arg_size, hash_t arg_hash,
+@@ -134,6 +148,7 @@
+ 	hash = arg_hash;
+ 	key = const_cast<void*>(arg_key);
+ 	is_our_dynamic = 0;
++    type = HASH_KEY_TYPE_NONE;
+ 	}
+ 
+ HashKey::HashKey(const void* bytes, int arg_size)
+@@ -142,6 +157,7 @@
+ 	key = CopyKey(bytes, size);
+ 	hash = HashBytes(key, size);
+ 	is_our_dynamic = 1;
++    type = HASH_KEY_TYPE_NONE;
+ 	}
+ 
+ void* HashKey::TakeKey()
+@@ -175,3 +191,72 @@
+ 	hmac_md5(size, (const unsigned char*) bytes, (unsigned char*) digest);
+ 	return digest[0];
+ 	}
++
++BOOST_CLASS_EXPORT_GUID(HashKey,"HashKey")
++template<class Archive>
++void HashKey::serialize(Archive & ar, const unsigned int version)
++    {
++        ar & size;
++        ar & type;
++
++        // Special handling of void * pointer to key
++        if (!Archive::is_loading::value)
++        {
++            switch(type)
++            {
++            case HASH_KEY_TYPE_INT:
++                ar & key_u.i;
++                break;
++            case HASH_KEY_TYPE_UINT:
++                ar & key_u.u32;
++                break;
++            case HASH_KEY_TYPE_DOUBLE:
++                ar & key_u.d;
++                break;
++            case HASH_KEY_TYPE_PTR:
++            case HASH_KEY_TYPE_NONE:
++                char *ptr = (char *)key;
++                ar & boost::serialization::make_binary_object(ptr, size);
++                break;
++            }
++        }
++        if (Archive::is_loading::value)
++        {
++            switch(type)
++            {
++            case HASH_KEY_TYPE_INT:
++                ar & key_u.i;
++                key = (void*) &key_u;
++                break;
++            case HASH_KEY_TYPE_UINT:
++                ar & key_u.u32;
++                key = (void*) &key_u;
++                break;
++            case HASH_KEY_TYPE_DOUBLE:
++                ar & key_u.d;
++                key = (void*) &key_u;
++                break;
++            case HASH_KEY_TYPE_PTR:
++            case HASH_KEY_TYPE_NONE:
++                char *ptr = new char[size];
++                is_our_dynamic = true; // Force deallocation when destroyed
++                ar & boost::serialization::make_binary_object(ptr, size);
++                if (HASH_KEY_TYPE_PTR == type)
++                { 
++                    key_u.p = (void *)ptr; 
++                    key = (void*) &key_u;
++                }
++                else if (HASH_KEY_TYPE_NONE == type)
++                { key = (void *)ptr; }
++                break;
++            }
++        }
++        
++        ar & hash;
++    }
++template void HashKey::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void HashKey::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/Hash.h bro-2.1-sdmbn/src/Hash.h
+--- bro-2.1/src/Hash.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Hash.h	2014-02-17 17:20:06.000000003 -0600
+@@ -7,6 +7,8 @@
+ 
+ #include "BroString.h"
+ 
++#include <boost/serialization/access.hpp>
++
+ #define UHASH_KEY_SIZE 36
+ 
+ typedef uint64 hash_t;
+@@ -18,6 +20,14 @@
+ #define NUM_HASH_KEYS (int(HASH_KEY_STRING) + 1)
+ } HashKeyTag;
+ 
++typedef enum {
++    HASH_KEY_TYPE_INT,
++    HASH_KEY_TYPE_UINT,
++    HASH_KEY_TYPE_DOUBLE,
++    HASH_KEY_TYPE_PTR,
++    HASH_KEY_TYPE_NONE
++} HashKeyType;
++
+ class HashKey {
+ public:
+ 	HashKey(bro_int_t i);
+@@ -82,6 +92,14 @@
+ 	void* key;
+ 	int is_our_dynamic;
+ 	int size, hash;
++
++    HashKeyType type;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    HashKey() {}; // Dummy default constructor for serialization
+ };
+ 
+ extern void init_hash_function();
+diff -urN bro-2.1/src/HTTP.cc bro-2.1-sdmbn/src/HTTP.cc
+--- bro-2.1/src/HTTP.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/HTTP.cc	2014-02-17 17:20:06.000000003 -0600
+@@ -12,6 +12,11 @@
+ #include "HTTP.h"
+ #include "Event.h"
+ #include "MIME.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include <boost/serialization/vector.hpp>
++#include "SDMBNlocal.h"
+ 
+ const bool DEBUG_http = false;
+ 
+@@ -462,6 +467,32 @@
+ 		}
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(HTTP_Entity,"HTTP_Entity")
++template<class Archive>
++void HTTP_Entity::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:HTTP_Entity:%d\n",__FILE__,__LINE__);
++        // Serialize MIME_Entity
++        ar & boost::serialization::base_object<MIME_Entity>(*this);
++
++        ar & http_message;
++        ar & chunked_transfer_state;
++        ar & content_length;
++        ar & expect_data_length;
++        ar & expect_body;
++        ar & body_length;
++        ar & header_length;
++        ar & deliver_body;
++        ar & encoding;
++        ar & zip;
++    }
++template void HTTP_Entity::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void HTTP_Entity::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ HTTP_Message::HTTP_Message(HTTP_Analyzer* arg_analyzer,
+ 				ContentLine_Analyzer* arg_cl, bool arg_is_orig,
+ 				int expect_body, int64_t init_header_length)
+@@ -475,6 +506,8 @@
+ 	top_level = new HTTP_Entity(this, 0, expect_body);
+ 	BeginEntity(top_level);
+ 
++    buffer_offset = 0;
++    buffer_size = 0;
+ 	data_buffer = 0;
+ 	total_buffer_size = 0;
+ 
+@@ -704,7 +737,7 @@
+ 	{
+ 	if ( http_entity_data )
+ 		{
+-		const BroString* entity_data = 0;
++		BroString* entity_data = 0;
+ 
+ 		if ( data_buffer && buffer_offset > 0 )
+ 			{
+@@ -786,6 +819,43 @@
+ 	analyzer->Weird(msg);
+ 	}
+ 
++
++BOOST_CLASS_EXPORT_GUID(HTTP_Message,"HTTP_Message")
++template<class Archive>
++void HTTP_Message::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:HTTP_Message:%d\n",__FILE__,__LINE__);
++
++        // (De)serialize buffers first, otherwise we run into problems 
++        // deserializing data_buf_data in MIME_Entity due to circular
++        // dependencies between HTTP_Message, MIME_Message, HTTP_Entity, and
++        // MIME_Entit.
++        ar & buffers;
++        ar & data_buffer;
++
++        // Serialize MIME_Message
++        ar & boost::serialization::base_object<MIME_Message>(*this);
++
++        ar & analyzer;
++        ar & content_line;
++        //ar & buffers;
++        ar & total_buffer_size;
++        ar & buffer_offset;
++        ar & buffer_size;
++        //ar & data_buffer;
++        ar & start_time;
++        ar & body_length;
++        ar & header_length;
++        ar & content_gap_length;
++        ar & current_entity;
++    }
++template void HTTP_Message::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void HTTP_Message::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ HTTP_Analyzer::HTTP_Analyzer(Connection* conn)
+ 	: TCP_ApplicationAnalyzer(AnalyzerTag::HTTP, conn)
+ 	{
+@@ -800,7 +870,8 @@
+ 	reply_state = EXPECT_REPLY_LINE;
+ 
+ 	request_ongoing = 0;
+-	request_method = request_URI = 0;
++	request_method = 0;
++    request_URI = 0;
+ 	unescaped_URI = 0;
+ 
+ 	reply_ongoing = 0;
+@@ -1338,7 +1409,9 @@
+ 	Unref(unescaped_URI);
+ 	Unref(request_URI);
+ 
+-	request_method = request_URI = unescaped_URI = 0;
++	request_method = 0;
++    request_URI = 0;
++    unescaped_URI = 0;
+ 
+ 	num_request_lines = 0;
+ 
+@@ -1713,6 +1786,43 @@
+ 		msg->SkipEntityData();
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(HTTP_Analyzer,"HTTP_Analyzer")
++template<class Archive>
++void HTTP_Analyzer::serialize(Archive & ar, const unsigned int version)
++    {
++        // Serialize TCP_ApplicationAnalyzer 
++        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
++
++        ar & request_state;
++        ar & reply_state;
++        ar & num_requests;
++        ar & num_replies;
++        ar & num_request_lines;
++        ar & num_reply_lines;
++        ar & request_version;
++        ar & reply_version;
++        ar & keep_alive;
++        ar & connection_close;
++        ar & request_ongoing;
++        ar & reply_ongoing;
++        ar & request_method;
++        ar & request_URI;
++        ar & unescaped_URI;
++        //ar & unanswered_requests; //FIXME
++        ar & reply_code;
++        ar & reply_reason_phrase;
++        ar & content_line_orig;
++        ar & content_line_resp;
++        ar & request_message;
++        ar & reply_message;
++    }
++template void HTTP_Analyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void HTTP_Analyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ int is_reserved_URI_char(unsigned char ch)
+ 	{ // see RFC 2396 (definition of URI)
+ 	return strchr(";/?:@&=+$,", ch) != 0;
+diff -urN bro-2.1/src/HTTP.h bro-2.1-sdmbn/src/HTTP.h
+--- bro-2.1/src/HTTP.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/HTTP.h	2014-02-17 17:20:06.000000003 -0600
+@@ -9,6 +9,7 @@
+ #include "binpac_bro.h"
+ #include "ZIP.h"
+ #include "IPAddr.h"
++#include <boost/serialization/access.hpp>
+ 
+ enum CHUNKED_TRANSFER_STATE {
+ 	NON_CHUNKED_TRANSFER,
+@@ -20,6 +21,8 @@
+ 	EXPECT_NOTHING,
+ };
+ 
++typedef enum { IDENTITY, GZIP, COMPRESS, DEFLATE } HTTPEncoding;
++
+ class HTTP_Entity;
+ class HTTP_Message;
+ class HTTP_Analyzer;
+@@ -53,7 +56,7 @@
+ 	int64_t body_length;
+ 	int64_t header_length;
+ 	int deliver_body;
+-	enum { IDENTITY, GZIP, COMPRESS, DEFLATE } encoding;
++	HTTPEncoding encoding;
+ 	ZIP_Analyzer* zip;
+ 
+ 	MIME_Entity* NewChildEntity() { return new HTTP_Entity(http_message, this, 1); }
+@@ -67,6 +70,12 @@
+ 
+ 	void SubmitHeader(MIME_Header* h);
+ 	void SubmitAllHeaders();
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    HTTP_Entity() {}; // Dummy default constructor for serialization
+ };
+ 
+ enum {
+@@ -115,12 +124,33 @@
+ 	void Weird(const char* msg);
+ 	bool IsOrig()	{ return is_orig; }
+ 
++    int GetBufferDiff(char *buf) 
++    { 
++        if (0 == data_buffer)
++            {
++            if (0 == buffers.size())
++            { return -1; }
++            return buf - (char *)buffers.back()->Bytes();
++            }
++        return buf - (char *)data_buffer->Bytes();
++    }
++    char* GetBuffer(int diff)
++    { 
++        if (0 == data_buffer)
++            {
++            if (0 == buffers.size())
++            { return NULL; }
++            return (char *)buffers.back()->Bytes() + diff;
++            }
++        return (char *)data_buffer->Bytes() + diff; 
++    }
++
+ protected:
+ 	HTTP_Analyzer* analyzer;
+ 	ContentLine_Analyzer* content_line;
+ 	bool is_orig;
+ 
+-	vector<const BroString*> buffers;
++	vector<BroString*> buffers;
+ 
+ 	// Controls the total buffer size within http_entity_data_delivery_size.
+ 	int total_buffer_size;
+@@ -143,6 +173,25 @@
+ 	void DeliverEntityData();
+ 
+ 	Val* BuildMessageStat(const int interrupted, const char* msg);
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    HTTP_Message() { 
++        analyzer = 0;
++        content_line = 0;
++        is_orig = 0;
++        total_buffer_size = 0;
++        buffer_offset = 0;
++        buffer_size = 0;
++    //    data_buffer = 0; 
++        start_time = 0;
++        body_length = 0;
++        header_length = 0;
++        content_gap_length = 0;
++        current_entity = 0; 
++    }; // Dummy default constructor for serialization
+ };
+ 
+ class HTTP_Analyzer : public TCP_ApplicationAnalyzer {
+@@ -227,7 +276,7 @@
+ 	int connection_close;
+ 	int request_ongoing, reply_ongoing;
+ 
+-	Val* request_method;
++	StringVal* request_method;
+ 
+ 	// request_URI is in the original form (may contain '%<hex><hex>'
+ 	// sequences).
+@@ -246,6 +295,12 @@
+ 
+ 	HTTP_Message* request_message;
+ 	HTTP_Message* reply_message;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    HTTP_Analyzer() {}; // Dummy default constructor for serialization
+ };
+ 
+ extern int is_reserved_URI_char(unsigned char ch);
+diff -urN bro-2.1/src/ICMP.cc bro-2.1-sdmbn/src/ICMP.cc
+--- bro-2.1/src/ICMP.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/ICMP.cc	2014-02-17 17:20:06.000000003 -0600
+@@ -10,6 +10,9 @@
+ #include "ICMP.h"
+ 
+ #include <netinet/icmp6.h>
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
+ 
+ ICMP_Analyzer::ICMP_Analyzer(Connection* c)
+ : TransportLayerAnalyzer(AnalyzerTag::ICMP, c)
+@@ -835,6 +838,29 @@
+ 	return vv;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(ICMP_Analyzer,"ICMP_Analyzer")
++template<class Archive>
++void ICMP_Analyzer::serialize(Archive & ar, const unsigned int version)
++    {
++        printf("%s:ICMP_Analyzer:%d",__FILE__,__LINE__);
++
++        // Serialize TransportLayerAnalyzer
++        ar & boost::serialization::base_object<TransportLayerAnalyzer>(*this);
++
++        ar & icmp_conn_val;
++        ar & type;
++        ar & code;
++        ar & request_len;
++        ar & reply_len;
++//        //ar & matcher_state; //FIXME
++    }
++template void ICMP_Analyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void ICMP_Analyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ int ICMP4_counterpart(int icmp_type, int icmp_code, bool& is_one_way)
+ 	{
+ 	is_one_way = false;
+diff -urN bro-2.1/src/ICMP.h bro-2.1-sdmbn/src/ICMP.h
+--- bro-2.1/src/ICMP.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/ICMP.h	2014-02-17 17:20:06.000000003 -0600
+@@ -4,6 +4,7 @@
+ #define icmp_h
+ 
+ #include "Analyzer.h"
++#include <boost/serialization/access.hpp>
+ 
+ typedef enum {
+ 	ICMP_INACTIVE,	// no packet seen
+@@ -87,6 +88,10 @@
+ 
+ private:
+ 	void UpdateEndpointVal(RecordVal* endp, int is_orig);
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ // Returns the counterpart type to the given type (e.g., the counterpart
+diff -urN bro-2.1/src/ID.cc bro-2.1-sdmbn/src/ID.cc
+--- bro-2.1/src/ID.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/ID.cc	2014-02-17 17:20:06.000000003 -0600
+@@ -14,6 +14,11 @@
+ #include "PersistenceSerializer.h"
+ #include "Scope.h"
+ #include "Traverse.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include <boost/serialization/binary_object.hpp>
++#include "SDMBNlocal.h"
+ 
+ ID::ID(const char* arg_name, IDScope arg_scope, bool arg_is_export)
+ 	{
+@@ -767,3 +772,59 @@
+ 	}
+ #endif
+ 
++BOOST_CLASS_EXPORT_GUID(ID,"ID")
++template<class Archive>
++void ID::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:ID:%d",__FILE__,__LINE__);
++        // Serialize BroObj
++        ar & boost::serialization::base_object<BroObj>(*this);
++
++        // Special handling of name
++        int name_len; 
++        if (!Archive::is_loading::value)
++        {
++            if (NULL == name)
++            { name_len = 0; }
++            else
++            { name_len = strlen(name) + 1; }
++        }
++        ar & name_len;
++        if (!Archive::is_loading::value)
++        { 
++            if (name_len > 0)
++            { 
++                ar & boost::serialization::make_binary_object((void *)name,
++                        name_len); 
++            }
++        }
++        if (Archive::is_loading::value)
++        {
++            if (name_len > 0)
++            {
++                name = new char[name_len];
++                ar & boost::serialization::make_binary_object(
++                        const_cast<char * &>(name), name_len);
++            }
++            else
++            { name = NULL; }
++        }
++
++        ar & scope;
++        ar & is_export;
++        ar & type;
++        ar & is_const;
++        ar & is_enum_const;
++        ar & is_type;
++        ar & offset;
++        ar & val;
++        ar & attrs;
++        ar & infer_return_type;
++        ar & weak_ref;
++    }
++template void ID::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void ID::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/ID.h bro-2.1-sdmbn/src/ID.h
+--- bro-2.1/src/ID.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/ID.h	2014-02-17 17:20:06.000000003 -0600
+@@ -8,6 +8,7 @@
+ #include "StateAccess.h"
+ #include "TraverseTypes.h"
+ #include <string>
++#include <boost/serialization/access.hpp>
+ 
+ class Val;
+ class SerialInfo;
+@@ -118,6 +119,10 @@
+ 
+ 	bool infer_return_type;
+ 	bool weak_ref;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/IPAddr.cc bro-2.1-sdmbn/src/IPAddr.cc
+--- bro-2.1/src/IPAddr.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/IPAddr.cc	2014-02-17 17:20:06.000000003 -0600
+@@ -7,6 +7,9 @@
+ #include "Conn.h"
+ #include "DPM.h"
+ #include "bro_inet_ntop.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
+ 
+ const uint8_t IPAddr::v4_mapped_prefix[12] = { 0, 0, 0, 0,
+                                                0, 0, 0, 0,
+@@ -230,6 +233,19 @@
+ 		}
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(IPAddr,"IPAddr")
++template<class Archive>
++void IPAddr::serialize(Archive & ar, const unsigned int version)
++    {
++        ar & in6.s6_addr;
++    }
++template void IPAddr::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void IPAddr::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ IPPrefix::IPPrefix(const in4_addr& in4, uint8_t length)
+ 	: prefix(in4), length(96 + length)
+ 	{
+@@ -284,3 +300,16 @@
+ 	return prefix.AsString() +"/" + l;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(IPPrefix,"IPPrefix")
++template<class Archive>
++void IPPrefix::serialize(Archive & ar, const unsigned int version)
++    {
++        ar & prefix;
++        ar & length; 
++    }
++template void IPPrefix::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void IPPrefix::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/IPAddr.h bro-2.1-sdmbn/src/IPAddr.h
+--- bro-2.1/src/IPAddr.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/IPAddr.h	2014-02-17 17:20:06.000000003 -0600
+@@ -12,6 +12,7 @@
+ #include "util.h"
+ #include "Type.h"
+ #include "threading/SerialTypes.h"
++#include <boost/serialization/access.hpp>
+ 
+ struct ConnID;
+ class ExpectedConn;
+@@ -351,6 +352,8 @@
+ 	friend HashKey* BuildExpectedConnHashKey(const ExpectedConn& c);
+ 
+ 	unsigned int MemoryAllocation() const { return padded_sizeof(*this); }
++	
++    in6_addr in6; // IPv6 or v4-to-v6-mapped address
+ 
+ private:
+ 	friend class IPPrefix;
+@@ -363,9 +366,10 @@
+ 	 */
+ 	void Init(const std::string& s);
+ 
+-	in6_addr in6; // IPv6 or v4-to-v6-mapped address
+-
+ 	static const uint8_t v4_mapped_prefix[12]; // top 96 bits of v4-mapped-addr
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ inline IPAddr::IPAddr(Family family, const uint32_t* bytes, ByteOrder order)
+@@ -603,6 +607,10 @@
+ private:
+ 	IPAddr prefix;	// We store it as an address with the non-prefix bits masked out via Mask().
+ 	uint8_t length;	// The bit length of the prefix relative to full IPv6 addr.
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/List.cc bro-2.1-sdmbn/src/List.cc
+--- bro-2.1/src/List.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/List.cc	2014-02-17 17:20:06.000000003 -0600
+@@ -5,6 +5,10 @@
+ 
+ #include "List.h"
+ #include "util.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include "SDMBNlocal.h"
+ 
+ static const int DEFAULT_CHUNK_SIZE = 10;
+ 
+@@ -230,3 +234,23 @@
+ 
+ 	return (i == length()) ? -1 : i;
+ 	}
++
++BOOST_CLASS_EXPORT_GUID(BaseList,"BaseList")
++template<class Archive>
++void BaseList::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:BaseList:%d",__FILE__,__LINE__);
++
++        // Do not serialize ent -- this is handled by classes which inherit 
++        // from BaseList 
++
++        ar & chunk_size;
++        ar & max_entries;
++        ar & num_entries;
++    }
++template void BaseList::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void BaseList::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/List.h bro-2.1-sdmbn/src/List.h
+--- bro-2.1/src/List.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/List.h	2014-02-17 17:20:06.000000003 -0600
+@@ -22,6 +22,7 @@
+ 
+ #include <stdarg.h>
+ #include "util.h"
++#include <boost/serialization/access.hpp>
+ 
+ typedef void* ent;
+ typedef int (*list_cmp_func)(const void* v1, const void* v2);
+@@ -82,6 +83,10 @@
+ 	int chunk_size;		// increase size by this amount when necessary
+ 	int max_entries;
+ 	int num_entries;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ 	};
+ 
+ 
+@@ -178,7 +183,38 @@
+ 	      ep = va_arg(ap,type*) )					\
+ 		append(ep);						\
+ 	resize();							\
+-	}
++	}   \
++\
++BOOST_CLASS_EXPORT_GUID(PList(type),"PList(type)")  \
++template<class Archive> \
++void PList(type)::serialize(Archive & ar, const unsigned int version)   \
++    {   \
++        SERIALIZE_PRINT("%s:PList(type):%d",__FILE__,__LINE__); \
++        ar & boost::serialization::base_object<BaseList>(*this);    \
++        if (!Archive::is_loading::value)    \
++        {   \
++            for (int i = 0; i < num_entries; i++)   \
++            {   \
++                type *item = (type *)(entry[i]);    \
++                ar & item;  \
++            }   \
++        }   \
++        if (Archive::is_loading::value) \
++        {   \
++            for (int i = 0; i < num_entries; i++)   \
++            {   \
++                type *item; \
++                ar & item;  \
++                enttry[i] = (ent)(item);    \
++            }   \
++        }   \
++    }   \
++template void BaseList::serialize<boost::archive::text_oarchive>(   \
++        boost::archive::text_oarchive & ar,     \
++        const unsigned int file_version);   \
++template void BaseList::serialize<boost::archive::text_iarchive>(   \
++        boost::archive::text_iarchive & ar,     \
++        const unsigned int file_version);
+ 
+ 
+ #define declare(metatype,type) metatype ## declare (type)
+diff -urN bro-2.1/src/main.cc bro-2.1-sdmbn/src/main.cc
+--- bro-2.1/src/main.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/main.cc	2014-04-15 13:53:57.000000003 -0500
+@@ -59,6 +59,16 @@
+ #include "logging/writers/Ascii.h"
+ 
+ #include "binpac_bro.h"
++extern "C" {
++#include <SDMBN.h>
++}
++#include "SDMBNlocal.h"
++#include <fstream>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/archive/text_oarchive.hpp>
++
++#define STATE_TMP_OUTFILE "stateout.tmp"
++#define STATE_TMP_INFILE "statein.tmp"
+ 
+ Brofiler brofiler;
+ 
+@@ -339,6 +349,8 @@
+ 	delete reporter;
+ 
+ 	reporter = 0;
++
++    sdmbn_cleanup();
+ 	}
+ 
+ void termination_signal()
+@@ -494,13 +506,15 @@
+ 	opterr = 0;
+ 
+ 	char opts[256];
+-	safe_strncpy(opts, "B:D:e:f:I:i:K:l:n:p:R:r:s:T:t:U:w:x:X:y:Y:z:CFGLOPSWbdghvZ",
++	safe_strncpy(opts, "B:D:e:f:I:i:K:l:n:p:R:r:s:T:t:U:w:x:X:y:Y:z:CFGLOPSWbdghvZJ:",
+ 		     sizeof(opts));
+ 
+ #ifdef USE_PERFTOOLS_DEBUG
+ 	strncat(opts, "mM", 2);
+ #endif
+ 
++    char *device = NULL;
++
+ 	int op;
+ 	while ( (op = getopt_long(argc, argv, opts, long_opts, &long_optsind)) != EOF )
+ 		switch ( op ) {
+@@ -527,6 +541,7 @@
+ 
+ 		case 'i':
+ 			interfaces.append(optarg);
++            device = optarg;
+ 			break;
+ 
+ 		case 'p':
+@@ -701,6 +716,15 @@
+ 	atexit(atexit_handler);
+ 	set_processing_status("INITIALIZING", "main");
+ 
++    // Initialize SDMBN
++    SDMBNLocals locals;
++    bzero(&locals, sizeof(locals));
++    locals.get_perflow = &local_get_perflow;
++    locals.put_perflow = &local_put_perflow;
++    locals.device = device;
++    sdmbn_init(&locals);
++		
++
+ 	bro_start_time = current_time(true);
+ 
+ 	reporter = new Reporter();
+@@ -1094,3 +1118,249 @@
+ 
+ 	return 0;
+ 	}
++
++static Connection *sdmbn_boost_decode(char *state)
++{	
++	long state_size = strlen(state);
++    FILE *file;
++    file = fopen(STATE_TMP_INFILE,"w+b");
++    if (!file) 
++    { 
++        ERROR_PRINT("Could not open serialization file");
++        return NULL;
++    }
++
++    if (int result = fwrite(state, state_size, 1, file) != 1)
++    { 
++        ERROR_PRINT("Could not write serialized state: %d", result);
++        fclose(file);
++        return NULL;
++    }
++    fclose(file);
++
++    // Unserialize connection from temporary archive file
++    Connection *conn;
++    std::ifstream filestream(STATE_TMP_INFILE);
++    {
++        boost::archive::text_iarchive ar(filestream);
++        try
++        {
++            ar & conn;
++        }
++        catch(const std::exception & ex)
++        {
++            ERROR_PRINT("Exception during unserialize: %s",ex.what());
++        }
++    }
++    filestream.close();
++	return conn;
++}
++
++int local_put_perflow(int hashkey, PerflowKey *key, char *state)
++{
++	if (NULL == key || NULL == state)
++	{ return -1; }
++	Connection *conn = sdmbn_boost_decode(state);
++	conn->setGetOpId(0);
++	if (NULL == conn)
++    {
++            ERROR_PRINT("Failed to parse connection");
++            return 0;
++    }
++	sessions->Insert(conn);
++	INFO_PRINT("Connection inserted");
++    return 1;
++}
++
++static char *sdmbn_boost_encode(Connection *conn)
++{
++    // Serialize connection to temporary archive file
++//    try
++//    {
++        std::ofstream filestream(STATE_TMP_OUTFILE);
++        {
++            boost::archive::text_oarchive ar(filestream);
++            ar & conn;
++        }
++        filestream.close();
++//    }
++//    catch(const std::exception & ex)
++//    catch(const boost::archive::archive_exception & ex)
++//    {
++//        ERROR_PRINT("Exception during serialize: %s",ex.what());
++//        assert(false);
++//    }
++
++    // Read serialized connection from temporary archive file
++    FILE *file;
++    long state_size;
++    char *state;
++    file = fopen(STATE_TMP_OUTFILE,"rb");
++    if (!file) 
++    { 
++        ERROR_PRINT("Could not open serialization file");
++        return NULL;
++    }
++    fseek(file,0L,SEEK_END);
++    state_size = ftell(file);
++    rewind(file);
++    state = (char *)malloc(state_size+1);
++    if (!state)
++    { 
++        ERROR_PRINT("Could not allocate space for serialized state");
++        fclose(file);
++        return NULL;
++    }
++    if (int result = fread(state, state_size, 1, file) != 1)
++    { 
++        ERROR_PRINT("Could not read serialized state: %d", result);
++        fclose(file);
++        free(state);
++        return NULL;
++    }
++    fclose(file);
++    state[state_size] = '\0';
++    return state;
++}
++
++static int handle_get_proto(PerflowKey *key, int proto, int id, int raiseEvents)
++{
++	// Match based on nw_proto
++    Dictionary *d = NULL;
++    switch(proto)
++    {
++    case IPPROTO_TCP:
++        d = &(sessions->tcp_conns);
++        break;
++    case IPPROTO_UDP:
++        d = &(sessions->udp_conns);
++        break;
++    case IPPROTO_ICMP:
++    case IPPROTO_ICMPV6:
++        d = &(sessions->icmp_conns);
++        break;
++    case IPPROTO_IPV4:
++    case IPPROTO_IPV6:
++    default:
++        ERROR_PRINT("Cannot handle proto %d", proto);
++        return 0;
++    }
++	
++	IterCookie *cookie = d->InitForIteration();
++    d->MakeRobustCookie(cookie);
++    int count = 0;
++	while (1)
++    {
++		HashKey *hashkey;
++        Connection *conn = (Connection *)(d->NextEntry(hashkey, 
++                    cookie, 0));
++        if (NULL == conn)
++        { break; }
++
++        if (conn->HasMoved())
++        { continue; }
++        
++        // Check tp_src
++        if (!(key->wildcards & WILDCARD_TP_SRC) &&
++                !(conn->OrigPort() == key->tp_src
++                    || (key->tp_flip && conn->RespPort() == key->tp_src)))
++        { continue; }
++
++        // Check tp_dst
++        if (!(key->wildcards & WILDCARD_TP_DST) &&
++                !(conn->RespPort() == key->tp_dst
++                    || (key->tp_flip && conn->OrigPort() == key->tp_dst)))
++        { continue; }
++
++        int nw_src_mask = 0xFFFFFFFF;
++        if (!(key->wildcards & WILDCARD_NW_SRC_MASK))
++        { nw_src_mask = nw_src_mask << (32 - key->nw_src_mask); }
++
++        // Check nw_src
++        if (!(key->wildcards & WILDCARD_NW_SRC) &&
++                (nw_src_mask & conn->OrigAddr().in6.s6_addr32[0]) 
++                    != key->nw_src)
++        { continue; }
++
++        int nw_dst_mask = 0xFFFFFFFF;
++        if (!(key->wildcards & WILDCARD_NW_DST_MASK))
++        { nw_dst_mask = nw_dst_mask << (32 - key->nw_dst_mask); }
++
++        // Check nw_dst
++        if (!(key->wildcards & WILDCARD_NW_DST) &&
++                (nw_dst_mask & conn->RespAddr().in6.s6_addr32[0]) 
++                    != key->nw_dst)
++        { continue; }
++
++		// treat the matched connections
++
++        // send conn now 
++		// Create supporting field from Connection object
++        pthread_mutex_lock(&conn->lock);
++        char *state = sdmbn_boost_encode(conn);
++        conn->setGetOpId(id);
++	if (raiseEvents)
++        	conn->Moved();
++
++        if (NULL == state)
++        {
++            ERROR_PRINT("Failed to serialize connection");
++            continue;
++        }
++
++        // Save hash for use later
++        int hash = conn->Key()->Hash();
++
++        // Get the UID
++        // char uid[20];
++        // uitoa_n(conn->GetUID(), uid, sizeof(uid), 62);
++
++        // Create Perflow key field from connection identification information
++        PerflowKey connkey;
++        connkey.wildcards = WILDCARD_DL_TYPE;
++        in_addr tmpaddr;
++        conn->OrigAddr().CopyIPv4(&tmpaddr);
++        connkey.nw_src = tmpaddr.s_addr;
++        conn->RespAddr().CopyIPv4(&tmpaddr);
++        connkey.nw_dst = tmpaddr.s_addr;
++        connkey.tp_src = conn->OrigPort();
++        connkey.tp_dst = conn->RespPort();
++        switch (conn->ConnTransport())
++        {
++        case TRANSPORT_TCP:
++            connkey.nw_proto = IPPROTO_TCP;
++            break;
++        case TRANSPORT_UDP:
++            connkey.nw_proto = IPPROTO_UDP;
++            break;
++        case TRANSPORT_ICMP:
++            connkey.nw_proto = IPPROTO_ICMP;
++            break;
++        default:
++            connkey.wildcards |= WILDCARD_NW_PROTO;
++            break;
++        }
++        pthread_mutex_unlock(&conn->lock);
++		int result = sdmbn_send_perflow(id, &connkey, state, hash, count);
++		count++;
++		free(state);
++	}
++	return count;
++}
++
++int local_get_perflow(PerflowKey *key, int id, int raiseEvents, SDMBNExt *unused)
++{
++	if (NULL == key)
++	{ return -1; }
++
++	int count = 0;
++    if (0 == key->nw_proto)
++    {
++        count += handle_get_proto(key, IPPROTO_TCP, id, raiseEvents);
++        count += handle_get_proto(key, IPPROTO_UDP, id, raiseEvents);
++        count += handle_get_proto(key, IPPROTO_ICMP, id, raiseEvents);
++    }
++    else
++    { count = handle_get_proto(key, key->nw_proto, id, raiseEvents); }
++	return count;
++}
+diff -urN bro-2.1/src/MIME.cc bro-2.1-sdmbn/src/MIME.cc
+--- bro-2.1/src/MIME.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/MIME.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -5,6 +5,11 @@
+ #include "Event.h"
+ #include "Reporter.h"
+ #include "digest.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include <boost/serialization/vector.hpp>
++#include <boost/serialization/binary_object.hpp>
+ 
+ // Here are a few things to do:
+ //
+@@ -157,6 +162,19 @@
+ 	return line;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(MIME_Multiline,"MIME_Multiline")
++template<class Archive>
++void MIME_Multiline::serialize(Archive & ar, const unsigned int version)
++    {
++        ar & buffer;
++        ar & line; 
++    }
++template void MIME_Multiline::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void MIME_Multiline::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+ 
+ MIME_Header::MIME_Header(MIME_Multiline* hl)
+ 	{
+@@ -225,6 +243,23 @@
+ 	return rest_value;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(MIME_Header,"MIME_Header")
++template<class Archive>
++void MIME_Header::serialize(Archive & ar, const unsigned int version)
++    {
++        ar & lines;
++        //ar & name; //FIXME
++        //ar & value; //FIXME
++        //ar & value_token; //FIXME
++        //ar & rest_value; //FIXME
++    }
++template void MIME_Header::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void MIME_Header::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ MIME_Entity::MIME_Entity(MIME_Message* output_message, MIME_Entity* parent_entity)
+ 	{
+ 	init();
+@@ -939,6 +974,56 @@
+ #endif
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(MIME_Entity,"MIME_Entity")
++template<class Archive>
++void MIME_Entity::serialize(Archive & ar, const unsigned int version)
++    {
++        ar & in_header;
++        ar & end_of_data;
++        ar & current_header_line; 
++        ar & current_field_type;
++        ar & need_to_parse_parameters;
++        ar & content_type_str;
++        ar & content_subtype_str;
++        ar & content_encoding_str;
++        ar & multipart_boundary;
++        ar & content_type;
++        ar & content_subtype;
++        ar & content_encoding;
++        ar & headers;
++        ar & parent;
++        ar & current_child_entity;
++        ar & base64_decoder;
++        ar & data_buf_length;
++        ar & data_buf_offset;
++        ar & message;
++
++        // Special handling of data_buf_data
++        int diff;
++        if (!Archive::is_loading::value)
++        { 
++            if (0 == data_buf_data || 0 == message)
++            { diff = -1; }
++            else
++            { diff = message->GetBufferDiff(data_buf_data); }
++        }
++        ar & diff;
++        if (Archive::is_loading::value)
++        {
++            if (diff < 0)
++            { data_buf_data = 0; }
++            else
++            { data_buf_data = message->GetBuffer(diff); }
++        }
++
++    }
++template void MIME_Entity::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void MIME_Entity::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ RecordVal* MIME_Message::BuildHeaderVal(MIME_Header* h)
+ 	{
+ 	RecordVal* header_record = new RecordVal(mime_header_rec);
+@@ -966,6 +1051,21 @@
+ 	return t;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(MIME_Message,"MIME_Message")
++template<class Archive>
++void MIME_Message::serialize(Archive & ar, const unsigned int version)
++    {
++        ar & analyzer;
++        ar & top_level;
++        ar & finished;
++    }
++template void MIME_Message::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void MIME_Message::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ MIME_Mail::MIME_Mail(Analyzer* mail_analyzer, int buf_size)
+ : MIME_Message(mail_analyzer)
+ 	{
+@@ -985,7 +1085,7 @@
+ 		length = max_chunk_length;
+ 
+ 	buffer_start = data_start = 0;
+-	data_buffer = new BroString(1, new u_char[length+1], length);
++	data_buffer = new BroString(1, new u_char[length+1], length); // FIXME?
+ 
+ 	if ( mime_content_hash )
+ 		{
+@@ -1014,7 +1114,7 @@
+ 		val_list* vl = new val_list;
+ 		vl->append(analyzer->BuildConnVal());
+ 		vl->append(new Val(content_hash_length, TYPE_COUNT));
+-		vl->append(new StringVal(new BroString(1, digest, 16)));
++		vl->append(new StringVal(new BroString(1, digest, 16))); // FIXME?
+ 		analyzer->ConnectionEvent(mime_content_hash, vl);
+ 		}
+ 
+@@ -1193,6 +1293,31 @@
+ 		}
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(MIME_Mail,"MIME_Mail")
++template<class Archive>
++void MIME_Mail::serialize(Archive & ar, const unsigned int version)
++    {
++        // Serialize MIME_Message
++        ar & boost::serialization::base_object<MIME_Message>(*this);
++
++        ar & min_overlap_length;
++        ar & max_chunk_length;
++        ar & buffer_start;
++        ar & data_start;
++        ar & buffer_offset;
++        ar & compute_content_hash;
++        ar & content_hash_length;
++        //ar & md5_hash; //FIXME
++        ar & entity_content; 
++        ar & all_content;
++        ar & data_buffer;
++    }
++template void MIME_Mail::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void MIME_Mail::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+ 
+ int strcasecmp_n(data_chunk_t s, const char* t)
+ 	{
+diff -urN bro-2.1/src/MIME.h bro-2.1-sdmbn/src/MIME.h
+--- bro-2.1/src/MIME.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/MIME.h	2014-02-17 17:20:07.000000003 -0600
+@@ -11,6 +11,7 @@
+ #include "Base64.h"
+ #include "BroString.h"
+ #include "Analyzer.h"
++#include <boost/serialization/access.hpp>
+ 
+ // MIME: Multipurpose Internet Mail Extensions
+ // Follows RFC 822 & 2822 (Internet Mail), 2045-2049 (MIME)
+@@ -57,8 +58,12 @@
+ 	BroString* get_concatenated_line();
+ 
+ protected:
+-	vector<const BroString*> buffer;
++	vector<BroString*> buffer;
+ 	BroString* line;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class MIME_Header {
+@@ -79,6 +84,12 @@
+ 	data_chunk_t name;
+ 	data_chunk_t value;
+ 	data_chunk_t value_token, rest_value;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    MIME_Header() {}; // Dummy default constructor for serialization
+ };
+ 
+ 
+@@ -170,6 +181,33 @@
+ 	int data_buf_offset;
+ 
+ 	MIME_Message* message;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    MIME_Entity() 
++    {
++        in_header = 0;
++        end_of_data = 0;
++        current_header_line = 0;
++        current_field_type = 0;
++        need_to_parse_parameters = 0;
++        content_type_str = 0;
++        content_subtype_str = 0;
++        content_encoding_str = 0;
++        multipart_boundary = 0;
++        content_type = 0;
++        content_subtype = 0;
++        content_encoding = 0;
++        parent = 0;
++        current_child_entity = 0;
++        base64_decoder = 0;
++        data_buf_length = 0;
++        data_buf_data = 0;
++        data_buf_offset = 0;
++        message = 0;
++    }; // Dummy default constructor for serialization
+ };
+ 
+ // The reason I separate MIME_Message as an abstract class is to
+@@ -214,6 +252,9 @@
+ 	virtual int RequestBuffer(int* plen, char** pbuf) = 0;
+ 	virtual void SubmitEvent(int event_type, const char* detail) = 0;
+ 
++    virtual int GetBufferDiff(char *buf) = 0;
++    virtual char* GetBuffer(int diff) = 0;
++
+ protected:
+ 	Analyzer* analyzer;
+ 
+@@ -222,6 +263,12 @@
+ 
+ 	RecordVal* BuildHeaderVal(MIME_Header* h);
+ 	TableVal* BuildHeaderTable(MIME_HeaderList& hlist);
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    MIME_Message() {}; // Dummy default constructor for serialization
+ };
+ 
+ class MIME_Mail : public MIME_Message {
+@@ -239,6 +286,9 @@
+ 	void SubmitAllData();
+ 	void SubmitEvent(int event_type, const char* detail);
+ 
++    int GetBufferDiff(char *buf) { return (0 == data_buffer ? -1 : buf - (char *)data_buffer->Bytes()); }
++    char* GetBuffer(int diff) { return (char *)data_buffer->Bytes() + diff; }
++
+ protected:
+ 	int min_overlap_length;
+ 	int max_chunk_length;
+@@ -248,10 +298,18 @@
+ 	int compute_content_hash;
+ 	int content_hash_length;
+ 	MD5_CTX md5_hash;
+-	vector<const BroString*> entity_content;
+-	vector<const BroString*> all_content;
++//	vector<const BroString*> entity_content;
++	vector<BroString*> entity_content;
++//	vector<const BroString*> all_content;
++	vector<BroString*> all_content;
+ 
+ 	BroString* data_buffer;
++    
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    MIME_Mail() {}; // Dummy default constructor for serialization
+ };
+ 
+ 
+diff -urN bro-2.1/src/NVT.cc bro-2.1-sdmbn/src/NVT.cc
+--- bro-2.1/src/NVT.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/NVT.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -8,6 +8,9 @@
+ #include "NetVar.h"
+ #include "Event.h"
+ #include "TCP.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
+ 
+ #define IS_3_BYTE_OPTION(c) (c >= 251 && c <= 254)
+ 
+@@ -701,3 +704,28 @@
+ 	Event(bad_option_termination);
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(NVT_Analyzer,"NVT_Analyzer")
++template<class Archive>
++void NVT_Analyzer::serialize(Archive & ar, const unsigned int version)
++    {
++        // Serialize ContentLine_Analyzer
++        ar & boost::serialization::base_object<ContentLine_Analyzer>(*this);
++
++        ar & peer;
++        ar & pending_IAC;
++        ar & IAC_pos;
++        ar & is_suboption;
++        ar & last_was_IAC;
++        ar & binary_mode;
++        ar & encrypting_mode;
++        ar & authentication_has_been_accepted;
++        //ar & auth_name; //FIXME
++        //ar & options; //FIXME
++        ar & num_options;
++    }
++template void NVT_Analyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void NVT_Analyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/NVT.h bro-2.1-sdmbn/src/NVT.h
+--- bro-2.1/src/NVT.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/NVT.h	2014-02-17 17:20:07.000000003 -0600
+@@ -4,6 +4,7 @@
+ #define nvt_h
+ 
+ #include "ContentLine.h"
++#include <boost/serialization/access.hpp>
+ 
+ 
+ #define TELNET_OPTION_BINARY 0
+@@ -168,6 +169,12 @@
+ 
+ 	TelnetOption* options[NUM_TELNET_OPTIONS];
+ 	int num_options;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    NVT_Analyzer() {}; // Dummy default constructor for serialization
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/Obj.cc bro-2.1-sdmbn/src/Obj.cc
+--- bro-2.1/src/Obj.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Obj.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -7,6 +7,11 @@
+ #include "Obj.h"
+ #include "Serializer.h"
+ #include "File.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include <boost/serialization/binary_object.hpp>
++#include "SDMBNlocal.h"
+ 
+ Location no_location("<no location>", 0, 0, 0, 0);
+ Location start_location("<start uninitialized>", 0, 0, 0, 0);
+@@ -85,6 +90,74 @@
+ 		return false;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(Location,"Location")
++template<class Archive>
++void Location::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:Location:%d",__FILE__,__LINE__);
++        // Serialize SerialObj?
++        //ar & boost::serialization::base_object<>(*this);
++        
++        // Special handling of filename & delete_data
++        int filename_len;
++        if (!Archive::is_loading::value)
++        { filename_len = strlen(filename)+1; }
++        ar & filename_len;
++        if (!Archive::is_loading::value)
++        { 
++            ar & boost::serialization::make_binary_object((void *)filename, 
++                    filename_len); 
++        }
++        if (Archive::is_loading::value)
++        {
++            filename = new char[filename_len];
++            ar & boost::serialization::make_binary_object(
++                    const_cast<char* &>(filename), filename_len);
++            delete_data = true;
++        }
++
++        SERIALIZE_PRINT("\t\tLocation:%d",__LINE__);
++        ar & first_line;
++        ar & last_line;
++        ar & first_column;
++        ar & last_column;
++        ar & timestamp;
++
++        // Special handling of text 
++        int text_len;
++        if (!Archive::is_loading::value)
++        {
++            if (text)
++            { text_len = strlen(text); }
++            else
++            { text_len = 0; }
++        }
++        ar & text_len;
++        if (!Archive::is_loading::value)
++        { 
++            if (text_len > 0)
++            { ar & boost::serialization::make_binary_object(text, text_len); }
++        }
++        if (Archive::is_loading::value)
++        {
++            if (text_len > 0)
++            {
++                text = new char[text_len];
++                ar & boost::serialization::make_binary_object(text, text_len);
++            }
++            else
++            { text = NULL; }
++        }
++
++        SERIALIZE_PRINT("\t\tLocation:Done");
++    }
++template void Location::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void Location::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ int BroObj::suppress_errors = 0;
+ 
+ BroObj::~BroObj()
+@@ -237,6 +310,28 @@
+ 	return true;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(BroObj,"BroObj")
++template<class Archive>
++void BroObj::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:BroObj:%d",__FILE__,__LINE__);
++        // Serialize SerialObj?
++        //ar & boost::serialization::base_object<>(*this);
++    
++        // Mark object as not in serialization cache
++        if (Archive::is_loading::value) { in_ser_cache = false; }
++
++        ar & location;
++        ar & ref_cnt;
++        SERIALIZE_PRINT("\t\t:BroObj:Done");
++    }
++template void BroObj::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void BroObj::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ void print(const BroObj* obj)
+ 	{
+ 	static BroFile fstderr(stderr);
+diff -urN bro-2.1/src/Obj.h bro-2.1-sdmbn/src/Obj.h
+--- bro-2.1/src/Obj.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Obj.h	2014-02-17 17:20:07.000000003 -0600
+@@ -8,6 +8,7 @@
+ #include "input.h"
+ #include "Desc.h"
+ #include "SerialObj.h"
++#include <boost/serialization/access.hpp>
+ 
+ class Serializer;
+ class SerialInfo;
+@@ -61,6 +62,10 @@
+ 	char* text;
+ protected:
+ 	DECLARE_SERIAL(Location);
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ #define YYLTYPE yyltype
+@@ -186,6 +191,10 @@
+ 	// If non-zero, do not print runtime errors.  Useful for
+ 	// speculative evaluation.
+ 	static int suppress_errors;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ // Prints obj to stderr, primarily for debugging.
+diff -urN bro-2.1/src/PIA.cc bro-2.1-sdmbn/src/PIA.cc
+--- bro-2.1/src/PIA.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/PIA.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -1,6 +1,10 @@
+ #include "PIA.h"
+ #include "RuleMatcher.h"
+ #include "TCP_Reassembler.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include "SDMBNlocal.h"
+ 
+ PIA::PIA(Analyzer* arg_as_analyzer)
+ 	{
+@@ -129,6 +133,40 @@
+ 				bol, eol, clear_state);
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(PIA,"PIA")
++template<class Archive>
++void PIA::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:PIA:%d",__FILE__,__LINE__);
++
++        // Serialize RuleMatcherState
++        ar & boost::serialization::base_object<RuleMatcherState>(*this);
++
++        //ar & pkt_buffer.head //FIXME
++        //ar & pkt_buffer.tail //FIXME
++        ar & pkt_buffer.size;
++        ar & pkt_buffer.state;
++
++        // Special check for analyzer serializability
++        if (!Archive::is_loading::value)
++        {
++            if (as_analyzer != NULL)
++            { assert(sdmbn_can_serialize(as_analyzer->GetTag())); }
++        }
++        SERIALIZE_PRINT("PIA:%d",__LINE__);
++        ar & as_analyzer;
++
++        ar & conn;
++        //ar & current_packet; //FIXME
++        SERIALIZE_PRINT("\t\tPIA:Done");
++    }
++template void PIA::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void PIA::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ void PIA_UDP::ActivateAnalyzer(AnalyzerTag::Tag tag, const Rule* rule)
+ 	{
+ 	if ( pkt_buffer.state == MATCHING_ONLY )
+@@ -154,6 +192,25 @@
+ 	reporter->InternalError("PIA_UDP::Deact not implemented yet");
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(PIA_UDP,"PIA_UDP")
++template<class Archive>
++void PIA_UDP::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:PIA_UDP:%d",__FILE__,__LINE__);
++
++        // Serialize PIA
++        ar & boost::serialization::base_object<PIA>(*this);
++        // Serialize Analyzer
++        ar & boost::serialization::base_object<Analyzer>(*this);
++        SERIALIZE_PRINT("\t\tPIA_UDP:Done");
++    }
++template void PIA_UDP::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void PIA_UDP::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ //// TCP PIA
+ 
+ PIA_TCP::~PIA_TCP()
+@@ -388,3 +445,29 @@
+ 			analyzer->NextUndelivered(b->seq, b->len, b->is_orig);
+ 		}
+ 	}
++
++BOOST_CLASS_EXPORT_GUID(PIA_TCP,"PIA_TCP")
++template<class Archive>
++void PIA_TCP::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:PIA_TCP:%d",__FILE__,__LINE__);
++
++        // Serialize PIA
++        ar & boost::serialization::base_object<PIA>(*this);
++        // Serialize TCP_ApplicationAnalyzer
++        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
++
++        //ar & stream_buffer.head; //FIXME
++        //ar & stream_buffer.tail; //FIXME
++        SERIALIZE_PRINT("\t\tPIA_TCP:%d",__LINE__);
++        ar & stream_buffer.size;
++        ar & stream_buffer.state;
++        ar & stream_mode;
++        SERIALIZE_PRINT("\t\tPIA_TCP:Done");
++    }
++template void PIA_TCP::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void PIA_TCP::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/PIA.h bro-2.1-sdmbn/src/PIA.h
+--- bro-2.1/src/PIA.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/PIA.h	2014-02-17 17:20:07.000000003 -0600
+@@ -5,6 +5,8 @@
+ 
+ #include "Analyzer.h"
+ #include "TCP.h"
++#include <boost/serialization/access.hpp>
++#include <boost/serialization/export.hpp>
+ 
+ class RuleEndpointState;
+ 
+@@ -80,10 +82,16 @@
+ 
+ 	Buffer pkt_buffer;
+ 
++    PIA() {}; // Dummy default constructor for serialization
++
+ private:
+ 	Analyzer* as_analyzer;
+ 	Connection* conn;
+ 	DataBlock current_packet;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ // PIA for UDP.
+@@ -113,6 +121,12 @@
+ 
+ 	virtual void ActivateAnalyzer(AnalyzerTag::Tag tag, const Rule* rule);
+ 	virtual void DeactivateAnalyzer(AnalyzerTag::Tag tag);
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++    
++    PIA_UDP() {}; // Dummy default constructor for serialization
+ };
+ 
+ // PIA for TCP.  Accepts both packet and stream input (and reassembles
+@@ -169,6 +183,12 @@
+ 	Buffer stream_buffer;
+ 
+ 	bool stream_mode;
++    
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    PIA_TCP() {}; // Dummy default constructor for serialization
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/PktSrc.cc bro-2.1-sdmbn/src/PktSrc.cc
+--- bro-2.1/src/PktSrc.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/PktSrc.cc	2014-04-15 13:53:57.000000003 -0500
+@@ -10,7 +10,7 @@
+ #include "Hash.h"
+ #include "Net.h"
+ #include "Sessions.h"
+-
++#include "SDMBNlocal.h"
+ 
+ // ### This needs auto-confing.
+ #ifdef HAVE_PCAP_INT_H
+@@ -614,6 +614,7 @@
+ 	append = arg_append;
+ 	dumper = 0;
+ 
++#ifndef WRITEIFACE
+ 	// We need a pcap_t with a reasonable link-layer type. We try to get it
+ 	// from the packet sources. If not available, we fall back to Ethernet.
+ 	// FIXME: Perhaps we should make this configurable?
+@@ -631,6 +632,7 @@
+ 		Error("error for pcap_open_dead");
+ 		return;
+ 		}
++#endif
+ 
+ 	if ( arg_filename )
+ 		Open(arg_filename);
+@@ -646,13 +648,18 @@
+ 
+ 	if ( arg_filename )
+ 		{
++#ifndef WRITEIFACE
+ 		if ( dumper && streq(arg_filename, filename) )
++#else
++		if ( live && streq(arg_filename, filename) )
++#endif
+ 			// Already open.
+ 			return true;
+ 
+ 		safe_strncpy(filename, arg_filename, FNBUF_LEN);
+ 		}
+ 
++#ifndef WRITEIFACE
+ 	if ( dumper )
+ 		Close();
+ 
+@@ -681,7 +688,6 @@
+ 			return false;
+ 			}
+ 		}
+-
+ 	else
+ 		{
+ 		// Old file and we need to append, which, unfortunately,
+@@ -695,6 +701,15 @@
+ 			return false;
+ 			}
+ 		}
++#else
++    errbuf[0] = 0;
++    live =  pcap_open_live(filename, 0, 1, 10, errbuf);
++    if ( ! live )
++        {
++        Error(errbuf);
++        return false;
++        }
++#endif
+ 
+ 	open_time = network_time;
+ 	is_error = false;
+@@ -703,25 +718,43 @@
+ 
+ bool PktDumper::Close()
+ 	{
++#ifndef WRITEIFACE
+ 	if ( dumper )
+ 		{
+ 		pcap_dump_close(dumper);
+ 		dumper = 0;
+ 		is_error = false;
+ 		}
++#else
++    if ( live )
++        {
++        pcap_close(live);
++        live = 0;
++        is_error = false;
++        }
++#endif
+ 
+ 	return true;
+ 	}
+ 
+ bool PktDumper::Dump(const struct pcap_pkthdr* hdr, const u_char* pkt)
+ 	{
++#ifndef WRITEIFACE
+ 	if ( ! dumper )
++#else
++    if ( ! live )
++#endif
+ 		return false;
+ 
+ 	if ( ! open_time )
+ 		open_time = network_time;
+ 
++#ifndef WRITEIFACE
+ 	pcap_dump((u_char*) dumper, hdr, pkt);
++#else
++	if (pcap_inject(live, pkt, hdr->caplen) < 0)
++        return false;
++#endif
+ 
+ 	return true;
+ 	}
+diff -urN bro-2.1/src/PktSrc.h bro-2.1-sdmbn/src/PktSrc.h
+--- bro-2.1/src/PktSrc.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/PktSrc.h	2014-04-15 13:53:57.000000003 -0500
+@@ -249,7 +249,13 @@
+ 	bool append;
+ 	pcap_dumper_t* dumper;
+ 	pcap_t* pd;
+-	double open_time;
++    double open_time;
++
++    // The "live" field is only needed if WRITEIFACE is defined, but 
++    // including the header where it's defined causes compilation errors,
++    // so we just always include the field
++	pcap_t* live;
++
+ 
+ 	bool is_error;
+ 	char errbuf[BRO_PCAP_ERRBUF_SIZE];
+diff -urN bro-2.1/src/Reassem.cc bro-2.1-sdmbn/src/Reassem.cc
+--- bro-2.1/src/Reassem.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Reassem.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -6,6 +6,11 @@
+ 
+ #include "Reassem.h"
+ #include "Serializer.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include <boost/serialization/binary_object.hpp>
++#include "SDMBNlocal.h"
+ 
+ const bool DEBUG_reassem = false;
+ 
+@@ -41,6 +46,42 @@
+ 	Reassembler::total_size += pad_size(size) + padded_sizeof(DataBlock);
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(DataBlock,"DataBlock")
++template<class Archive>
++void DataBlock::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:DataBlock:%d",__FILE__,__LINE__);
++
++        ar & next;
++        ar & prev;
++        ar & seq;
++        ar & upper;
++
++        // Special handling of block
++        int size = upper-seq;
++        if (!Archive::is_loading::value)
++        { 
++            if (size > 0)
++            { ar & boost::serialization::make_binary_object(block, size); }
++        }
++        if (Archive::is_loading::value)
++        {
++            if (size > 0)
++            {
++                block = new u_char[size];
++                ar & boost::serialization::make_binary_object(block, size);
++            }
++            else
++            { block = 0; }
++        }
++    }
++template void DataBlock::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void DataBlock::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ unsigned int Reassembler::total_size = 0;
+ 
+ Reassembler::Reassembler(int init_seq, ReassemblerType arg_type)
+@@ -310,3 +351,21 @@
+ 
+ 	return  true;
+ 	}
++
++BOOST_CLASS_EXPORT_GUID(Reassembler,"Reassembler")
++template<class Archive>
++void Reassembler::serialize(Archive & ar, const unsigned int version)
++    {
++        //FIXME: Serialize parent BroObj?
++        
++        ar & blocks;
++        ar & last_block;
++        ar & last_reassem_seq;
++        ar & trim_seq;
++    }
++template void Reassembler::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void Reassembler::serialize<boost::archive::text_iarchive>(
++boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/Reassem.h bro-2.1-sdmbn/src/Reassem.h
+--- bro-2.1/src/Reassem.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Reassem.h	2014-02-17 17:20:07.000000003 -0600
+@@ -5,6 +5,7 @@
+ 
+ #include "Obj.h"
+ #include "IPAddr.h"
++#include <boost/serialization/access.hpp>
+ 
+ class DataBlock {
+ public:
+@@ -19,6 +20,12 @@
+ 	DataBlock* prev;	// previous block with lower seq #
+ 	int seq, upper;
+ 	u_char* block;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    DataBlock() {}; // Dummy default constructor for serialization
+ };
+ 
+ 
+@@ -72,6 +79,11 @@
+ 	int trim_seq;	// how far we've trimmed
+ 
+ 	static unsigned int total_size;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
+ };
+ 
+ inline DataBlock::~DataBlock()
+diff -urN bro-2.1/src/RuleMatcher.cc bro-2.1-sdmbn/src/RuleMatcher.cc
+--- bro-2.1/src/RuleMatcher.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/RuleMatcher.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -9,6 +9,9 @@
+ #include "Scope.h"
+ #include "File.h"
+ #include "Reporter.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
+ 
+ // FIXME: Things that are not fully implemented/working yet:
+ //
+@@ -159,6 +162,28 @@
+ 		delete matched_text[j];
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(RuleEndpointState,"RuleEndpointState")
++template<class Archive>
++void RuleEndpointState::serialize(Archive & ar, const unsigned int version)
++    {
++        ar & is_orig;
++        ar & analyzer;
++        ar & opposite;
++        //ar & pia; //FIXME
++        //ar & matchers; //FIXME
++        //ar & hdr_tests; //FIXME
++        //ar & matched_by_patterns; //FIXME
++        //ar & matched_test; //FIXME
++        ar & payload_size;
++        //ar & matched_rules; //FIXME
++    }
++template void RuleEndpointState::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void RuleEndpointState::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ RuleMatcher::RuleMatcher(int arg_RE_level)
+ 	{
+ 	root = new RuleHdrTest(RuleHdrTest::NOPROT, 0, 0, RuleHdrTest::EQ,
+@@ -1244,3 +1269,17 @@
+ 	if ( resp_match_state )
+ 		rule_matcher->ClearEndpointState(resp_match_state);
+ 	}
++
++BOOST_CLASS_EXPORT_GUID(RuleMatcherState,"RuleMatcherState")
++template<class Archive>
++void RuleMatcherState::serialize(Archive & ar, const unsigned int version)
++    {
++        ar & orig_match_state;
++        ar & resp_match_state;
++    }
++template void RuleMatcherState::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void RuleMatcherState::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/RuleMatcher.h bro-2.1-sdmbn/src/RuleMatcher.h
+--- bro-2.1/src/RuleMatcher.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/RuleMatcher.h	2014-02-17 17:20:07.000000003 -0600
+@@ -13,6 +13,7 @@
+ #include "Rule.h"
+ #include "RuleAction.h"
+ #include "RuleCondition.h"
++#include <boost/serialization/access.hpp>
+ 
+ //#define MATCHER_PRINT_STATS
+ 
+@@ -182,6 +183,12 @@
+ 	int payload_size;
+ 
+ 	int_list matched_rules;		// Rules for which all conditions have matched
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++    
++    RuleEndpointState() {}; // Dummy default constructor for serialization
+ };
+ 
+ 
+@@ -322,6 +329,10 @@
+ private:
+ 	RuleEndpointState* orig_match_state;
+ 	RuleEndpointState* resp_match_state;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/SDMBNlocal.cc bro-2.1-sdmbn/src/SDMBNlocal.cc
+--- bro-2.1/src/SDMBNlocal.cc	1969-12-31 18:00:00.000000000 -0600
++++ bro-2.1-sdmbn/src/SDMBNlocal.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -0,0 +1,30 @@
++#include "SDMBNlocal.h"
++
++int sdmbn_can_serialize(AnalyzerTag::Tag check)
++{
++    switch(check)
++    {
++    case AnalyzerTag::PIA_TCP: //1
++    case AnalyzerTag::PIA_UDP: //2
++    case AnalyzerTag::ICMP: //3
++    case AnalyzerTag::TCP: //4
++    case AnalyzerTag::UDP: //5
++    case AnalyzerTag::DNS: //9
++    case AnalyzerTag::FTP: //11
++    case AnalyzerTag::HTTP: //13
++    case AnalyzerTag::SMTP: //27
++    case AnalyzerTag::SSH: //28
++    case AnalyzerTag::SSL: //34
++    case AnalyzerTag::Teredo: //38
++    case AnalyzerTag::File: //39
++    case AnalyzerTag::ConnSize: //44
++    case AnalyzerTag::ContentLine: //46
++    case AnalyzerTag::NVT: //47
++    case AnalyzerTag::Zip: //48
++        return 1;
++        break;
++    default:
++        fprintf(stderr,"UNHANDLED ANALYZER: %d\n", check);
++        return 0;
++    }
++}
+diff -urN bro-2.1/src/SDMBNlocal.h bro-2.1-sdmbn/src/SDMBNlocal.h
+--- bro-2.1/src/SDMBNlocal.h	1969-12-31 18:00:00.000000000 -0600
++++ bro-2.1-sdmbn/src/SDMBNlocal.h	2014-04-15 13:53:57.000000003 -0500
+@@ -0,0 +1,48 @@
++#ifndef _SDMBNLocal_H_
++#define _SDMBNLocal_H_
++
++#include <stdio.h>
++#include "Conn.h"
++#include "AnalyzerTags.h"
++#include <SDMBN.h>
++
++// Enable the define below to output to a device when using the -w option and // a device name (instead of a filename)
++#define WRITEIFACE
++
++///// DEBUGGING MACROS ///////////////////////////////////////////////////////
++//#define SDMBN_SERIALIZE
++
++#define SDMBN_INFO
++//#define SDMBN_ERROR
++
++#ifdef SDMBN_SERIALIZE
++    #define SERIALIZE_PRINT(...) printf(__VA_ARGS__); printf("\n");
++#else
++    #define SERIALIZE_PRINT(...)
++#endif
++
++#ifdef SDMBN_INFO
++    #define INFO_PRINT(...) printf(__VA_ARGS__); printf("\n");
++    #ifndef SDMBN_ERROR
++        #define SDMBN_ERROR
++    #endif
++#else
++    #define INFO_PRINT(...)
++#endif
++
++#ifdef SDMBN_ERROR
++    #define ERROR_PRINT(...) printf(__VA_ARGS__); printf("\n");
++#else
++    #define ERROR_PRINT(...)
++#endif
++
++///// TYPEDEFS ///////////////////////////////////////////////////////////////
++int sdmbn_can_serialize(AnalyzerTag::Tag check);
++
++///// FUNCTION PROTOTYPES ////////////////////////////////////////////////////
++int local_get_perflow(PerflowKey *key, int id, int raiseEvents, SDMBNExt *unused);
++int local_put_perflow(int hashkey, PerflowKey *key, char *state);
++int local_get_shared(int id);
++int local_put_shared(int hashkey, char *state);
++
++#endif
+diff -urN bro-2.1/src/Sessions.cc bro-2.1-sdmbn/src/Sessions.cc
+--- bro-2.1/src/Sessions.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Sessions.cc	2014-05-26 20:58:50.000000003 -0500
+@@ -32,6 +32,12 @@
+ #include "PacketSort.h"
+ #include "TunnelEncapsulation.h"
+ 
++extern "C" {
++#include <SDMBN.h>
++}
++#include "SDMBNlocal.h"
++#include <sys/time.h>
++
+ // These represent NetBIOS services on ephemeral ports.  They're numbered
+ // so that we can use a single int to hold either an actual TCP/UDP server
+ // port or one of these.
+@@ -164,8 +170,8 @@
+ 	}
+ 
+ void NetSessions::DispatchPacket(double t, const struct pcap_pkthdr* hdr,
+-			const u_char* pkt, int hdr_size,
+-			PktSrc* src_ps, PacketSortElement* pkt_elem)
++    const u_char* pkt, int hdr_size,
++    PktSrc* src_ps, PacketSortElement* pkt_elem)
+ 	{
+ 	const struct ip* ip_hdr = 0;
+ 	const u_char* ip_data = 0;
+@@ -264,7 +270,31 @@
+ 		}
+ 
+ 	if ( dump_this_packet && ! record_all_packets )
++#ifndef WRITEIFACE
+ 		DumpPacket(hdr, pkt);
++#else
++		{
++		// Force packet to be dumped    
++		unsigned char writeablepkt[1514];
++		if (hdr->caplen > 1514)
++			{ 
++			printf("Packet of length %d (%d) is too large\n", hdr->caplen,
++				hdr->len);
++			}
++		else
++			{
++			memcpy(writeablepkt, pkt, hdr->caplen);
++			writeablepkt[6] = 0xAA;
++			writeablepkt[7] = 0xBB;
++			writeablepkt[8] = 0xCC;
++			writeablepkt[9] = 0xDD;
++			writeablepkt[10] = 0xEE;
++			writeablepkt[11] = 0xFF;
++
++			DumpPacket(hdr, writeablepkt);
++			}
++		}
++#endif
+ 	}
+ 
+ void NetSessions::NextPacketSecondary(double /* t */, const struct pcap_pkthdr* hdr,
+@@ -367,10 +397,18 @@
+ 	return 1;
+ 	}
+ 
++// added to count the packets that were received at the src NF after the
++// move
++int drop_counter = 0;
++
++
+ void NetSessions::DoNextPacket(double t, const struct pcap_pkthdr* hdr,
+ 				const IP_Hdr* ip_hdr, const u_char* const pkt,
+ 				int hdr_size, const EncapsulationStack* encapsulation)
+ 	{
++	struct timeval recv_time;
++	gettimeofday(&recv_time,NULL);
++
+ 	uint32 caplen = hdr->caplen - hdr_size;
+ 	const struct ip* ip4 = ip_hdr->IP4_Hdr();
+ 
+@@ -625,6 +663,15 @@
+ 		return;
+ 	}
+ 
++	char pkttype[10]; 
++	if (80 == ntohs(id.src_port) || 80 == ntohs(id.dst_port))
++	{ sprintf(pkttype, "HTTP"); }
++	else if (443 == ntohs(id.src_port) || 443 == ntohs(id.dst_port))
++	{ sprintf(pkttype, "TLS"); }
++	else
++	{ sprintf(pkttype, "UNKNOWN"); }
++	sdmbn_notify_packet_received(pkttype, &recv_time);
++
+ 	HashKey* h = BuildConnIDHashKey(id);
+ 	if ( ! h )
+ 		reporter->InternalError("hash computation failed");
+@@ -636,13 +683,27 @@
+ 	conn = (Connection*) d->Lookup(h);
+ 	if ( ! conn )
+ 		{
++		printf("[SIGDEBUG] Creating a new connection\n");
++		sdmbn_notify_flow_created();
+ 		conn = NewConn(h, t, &id, data, proto, ip_hdr->FlowLabel(), encapsulation);
+ 		if ( conn )
++			{
++			conn->initLock();
+ 			d->Insert(h, conn);
++			}
+ 		}
+ 	else
+ 		{
+ 		// We already know that connection.
++		if(conn->HasMoved()) {
++			printf("[SIGDEBUG] The state of connection has moved\n");
++			drop_counter++;
++			printf("[SIGMOVE] Drop counter = %d\n", drop_counter);
++			}
++		else {
++			printf("[SIGDEBUG] The state is not moved\n"); 
++			}
++
+ 		int consistent = CheckConnectionTag(conn);
+ 		if ( consistent < 0 )
+ 			{
+@@ -657,6 +718,7 @@
+ 				conn->Event(connection_reused, 0);
+ 
+ 			Remove(conn);
++			printf("[SIGDEBUG] Removing and creating a new connection in the consistency check clause\n");
+ 			conn = NewConn(h, t, &id, data, proto, ip_hdr->FlowLabel(), encapsulation);
+ 			if ( conn )
+ 				d->Insert(h, conn);
+@@ -681,6 +743,21 @@
+ 	int is_orig = (id.src_addr == conn->OrigAddr()) &&
+ 			(id.src_port == conn->OrigPort());
+ 
++	pthread_mutex_lock(&conn->lock);
++
++	// If marked as MOVED - raise an event
++	if (conn->HasMoved())
++		{
++		/* NO REDIRECT EVENTS
++		sdmbn_raise_reprocess(conn->getGetOpId(), conn->Key()->Hash(), 
++				(struct pcap_pkthdr *)hdr, (u_char *)pkt);
++				*/
++		/* return to stop further processing, in case of reprocess we will
++		* not return */
++		pthread_mutex_unlock(&conn->lock);
++		return;
++		}
++
+ 	conn->CheckFlowLabel(is_orig, ip_hdr->FlowLabel());
+ 
+ 	Val* pkt_hdr_val = 0;
+@@ -699,6 +776,8 @@
+ 				record_packet, record_content,
+ 			        hdr, pkt, hdr_size);
+ 
++	pthread_mutex_unlock(&conn->lock);
++
+ 	if ( f )
+ 		{
+ 		// Above we already recorded the fragment in its entirety.
+@@ -958,22 +1037,26 @@
+ 		{
+ 		c->CancelTimers();
+ 
+-		TCP_Analyzer* ta = (TCP_Analyzer*) c->GetRootAnalyzer();
+-		if ( ta && c->ConnTransport() == TRANSPORT_TCP )
++		if (!c->HasMoved())
+ 			{
+-			assert(ta->GetTag() == AnalyzerTag::TCP);
+-			TCP_Endpoint* to = ta->Orig();
+-			TCP_Endpoint* tr = ta->Resp();
++			TCP_Analyzer* ta = (TCP_Analyzer*) c->GetRootAnalyzer();
++			if ( ta && c->ConnTransport() == TRANSPORT_TCP )
++				{
++				assert(ta->GetTag() == AnalyzerTag::TCP);
++				TCP_Endpoint* to = ta->Orig();
++				TCP_Endpoint* tr = ta->Resp();
+ 
+-			tcp_stats.StateLeft(to->state, tr->state);
++				tcp_stats.StateLeft(to->state, tr->state);
++				}
+ 			}
+ 
+ 		if ( c->IsPersistent() )
+ 			persistence_serializer->Unregister(c);
++	
++		if (!c->HasMoved())
++			{ c->Done(); }
+ 
+-		c->Done();
+-
+-		if ( connection_state_remove )
++		if (!c->HasMoved() && connection_state_remove ) 
+ 			c->Event(connection_state_remove, 0);
+ 
+ 		// Zero out c's copy of the key, so that if c has been Ref()'d
+@@ -983,17 +1066,17 @@
+ 
+ 		switch ( c->ConnTransport() ) {
+ 		case TRANSPORT_TCP:
+-			if ( ! tcp_conns.RemoveEntry(k) )
++			if ( ! tcp_conns.RemoveEntry(k) && !c->HasMoved() )
+ 				reporter->InternalError("connection missing");
+ 			break;
+ 
+ 		case TRANSPORT_UDP:
+-			if ( ! udp_conns.RemoveEntry(k) )
++			if ( ! udp_conns.RemoveEntry(k) && !c->HasMoved() )
+ 				reporter->InternalError("connection missing");
+ 			break;
+ 
+ 		case TRANSPORT_ICMP:
+-			if ( ! icmp_conns.RemoveEntry(k) )
++			if ( ! icmp_conns.RemoveEntry(k) && !c->HasMoved() )
+ 				reporter->InternalError("connection missing");
+ 			break;
+ 
+@@ -1001,7 +1084,7 @@
+ 			reporter->InternalError("unknown transport when removing connection");
+ 			break;
+ 		}
+-
++		sdmbn_notify_flow_destroyed();
+ 		Unref(c);
+ 		delete k;
+ 		}
+diff -urN bro-2.1/src/Sessions.h bro-2.1-sdmbn/src/Sessions.h
+--- bro-2.1/src/Sessions.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Sessions.h	2014-02-17 17:20:07.000000003 -0600
+@@ -185,6 +185,10 @@
+ 	unsigned int MemoryAllocation();
+ 	TCPStateStats tcp_stats;	// keeps statistics on TCP states
+ 
++	PDict(Connection) tcp_conns;
++	PDict(Connection) udp_conns;
++	PDict(Connection) icmp_conns;
++
+ protected:
+ 	friend class RemoteSerializer;
+ 	friend class ConnCompressor;
+@@ -245,9 +249,6 @@
+ 			      const EncapsulationStack* encap);
+ 
+ 	CompositeHash* ch;
+-	PDict(Connection) tcp_conns;
+-	PDict(Connection) udp_conns;
+-	PDict(Connection) icmp_conns;
+ 	PDict(FragReassembler) fragments;
+ 
+ 	typedef pair<IPAddr, IPAddr> IPPair;
+diff -urN bro-2.1/src/SMTP.cc bro-2.1-sdmbn/src/SMTP.cc
+--- bro-2.1/src/SMTP.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/SMTP.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -9,6 +9,10 @@
+ #include "Event.h"
+ #include "ContentLine.h"
+ #include "Reporter.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include <boost/serialization/list.hpp>
+ 
+ #undef SMTP_CMD_DEF
+ #define SMTP_CMD_DEF(cmd)	#cmd,
+@@ -882,3 +886,31 @@
+ 		mail = 0;
+ 		}
+ 	}
++
++BOOST_CLASS_EXPORT_GUID(SMTP_Analyzer,"SMTP_Analyzer")
++template<class Archive>
++void SMTP_Analyzer::serialize(Archive & ar, const unsigned int version)
++    {
++        // Serialize TCP_ApplicationAnalyzer
++        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
++
++        ar & orig_is_sender;
++        ar & expect_sender;
++        ar & expect_recver;
++        ar & state;
++        ar & last_replied_cmd;
++        ar & first_cmd;
++        ar & pending_reply;
++        ar & pipelining;
++        ar & pending_cmd_q;
++        ar & skip_data;
++        ar & orig_record_contents;
++        ar & line_after_gap;
++        ar & mail;
++    }
++template void SMTP_Analyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void SMTP_Analyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/SMTP.h bro-2.1-sdmbn/src/SMTP.h
+--- bro-2.1/src/SMTP.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/SMTP.h	2014-02-17 17:20:07.000000003 -0600
+@@ -8,6 +8,7 @@
+ 
+ #include "TCP.h"
+ #include "MIME.h"
++#include <boost/serialization/access.hpp>
+ 
+ 
+ #undef SMTP_CMD_DEF
+@@ -94,6 +95,12 @@
+ 					// after a gap
+ 
+ 	MIME_Mail* mail;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    SMTP_Analyzer() {}; // Dummy default constructor for serialization
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/SSH.cc bro-2.1-sdmbn/src/SSH.cc
+--- bro-2.1/src/SSH.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/SSH.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -8,6 +8,9 @@
+ #include "SSH.h"
+ #include "Event.h"
+ #include "ContentLine.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
+ 
+ SSH_Analyzer::SSH_Analyzer(Connection* c)
+ : TCP_ApplicationAnalyzer(AnalyzerTag::SSH, c)
+@@ -99,3 +102,20 @@
+ 
+ 	ConnectionEvent(event, vl);
+ 	}
++
++BOOST_CLASS_EXPORT_GUID(SSH_Analyzer,"SSH_Analyzer")
++template<class Archive>
++void SSH_Analyzer::serialize(Archive & ar, const unsigned int version)
++    {
++        // Serialize TCP_ApplicationAnalyzer
++        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
++
++        ar & orig;
++        ar & resp;
++    }
++template void SSH_Analyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void SSH_Analyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/SSH.h bro-2.1-sdmbn/src/SSH.h
+--- bro-2.1/src/SSH.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/SSH.h	2014-02-17 17:20:07.000000003 -0600
+@@ -5,6 +5,7 @@
+ 
+ #include "TCP.h"
+ #include "ContentLine.h"
++#include <boost/serialization/access.hpp>
+ 
+ class SSH_Analyzer : public TCP_ApplicationAnalyzer {
+ public:
+@@ -21,6 +22,12 @@
+ private:
+ 	ContentLine_Analyzer* orig;
+ 	ContentLine_Analyzer* resp;
++    
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    SSH_Analyzer() {}; // Dummy default constructor for serialization
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/SSL.cc bro-2.1-sdmbn/src/SSL.cc
+--- bro-2.1/src/SSL.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/SSL.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -2,6 +2,9 @@
+ #include "TCP_Reassembler.h"
+ #include "Reporter.h"
+ #include "util.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
+ 
+ SSL_Analyzer::SSL_Analyzer(Connection* c)
+ : TCP_ApplicationAnalyzer(AnalyzerTag::SSL, c)
+@@ -58,3 +61,20 @@
+ 	had_gap = true;
+ 	interp->NewGap(orig, len);
+ 	}
++
++BOOST_CLASS_EXPORT_GUID(SSL_Analyzer,"SSL_Analyzer")
++template<class Archive>
++void SSL_Analyzer::serialize(Archive & ar, const unsigned int version)
++    {
++        // Serialize TCP_ApplicationAnalyzer
++        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
++        //ar & interp; //FIXME
++        if (Archive::is_loading::value) { interp = new binpac::SSL::SSL_Conn(this); } //TMPHACK
++        ar & had_gap;
++    }
++template void SSL_Analyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void SSL_Analyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/SSL.h bro-2.1-sdmbn/src/SSL.h
+--- bro-2.1/src/SSL.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/SSL.h	2014-02-17 17:20:07.000000003 -0600
+@@ -3,6 +3,7 @@
+ 
+ #include "TCP.h"
+ #include "ssl_pac.h"
++#include <boost/serialization/access.hpp>
+ 
+ class SSL_Analyzer : public TCP_ApplicationAnalyzer {
+ public:
+@@ -31,6 +32,11 @@
+ 	binpac::SSL::SSL_Conn* interp;
+ 	bool had_gap;
+ 
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    SSL_Analyzer() {}; // Dummy default constructor for serialization
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/TCP.cc bro-2.1-sdmbn/src/TCP.cc
+--- bro-2.1/src/TCP.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/TCP.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -9,6 +9,11 @@
+ #include "TCP_Reassembler.h"
+ #include "OSFinger.h"
+ #include "Event.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include <boost/serialization/list.hpp>
++#include "SDMBNlocal.h"
+ 
+ namespace { // local namespace
+ 	const bool DEBUG_tcp_data_sent = false;
+@@ -1833,6 +1838,64 @@
+ 	return true;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(TCP_Analyzer,"TCP_Analyzer")
++template<class Archive>
++void TCP_Analyzer::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:TCP_Analyzer:%d",__FILE__,__LINE__);
++
++        // Serialize TransportLayerAnalyzer
++        ar & boost::serialization::base_object<TransportLayerAnalyzer>(*this);
++
++        SERIALIZE_PRINT("\t\tTCP_Analyzer:%d",__LINE__);
++        ar & orig;
++        SERIALIZE_PRINT("\t\tTCP_Analyzer:%d",__LINE__);
++        ar & resp;
++
++        // Special check for analyzer serializability
++        if (!Archive::is_loading::value)
++        {
++            for (std::list<Analyzer*>::iterator it = packet_children.begin();
++                    it != packet_children.end(); it++)
++            { assert(sdmbn_can_serialize((*it)->GetTag())); }
++        }
++        SERIALIZE_PRINT("\t\tTCP_Analyzer:%d",__LINE__);
++        ar & packet_children;
++        
++        // Special handling of bit fields
++        unsigned int bitfields = 0;
++        if (!Archive::is_loading::value)
++        {
++            bitfields |= (first_packet_seen << 0); // 2 bits
++            bitfields |= (reassembling << 2);
++            bitfields |= (is_partial << 3);
++            bitfields |= (is_active << 4);
++            bitfields |= (finished << 5);
++            bitfields |= (close_deferred << 6);
++            bitfields |= (deferred_gen_event << 7);
++            bitfields |= (seen_first_ACK << 8);
++        }
++        ar & bitfields;
++        if (Archive::is_loading::value)
++        {
++            first_packet_seen = (bitfields >> 0) & 0x3; // 2 bits
++            reassembling = (bitfields >> 2) & 0x1;
++            is_partial = (bitfields >> 3) & 0x1;
++            is_active = (bitfields >> 4) & 0x1;
++            finished = (bitfields >> 5) & 0x1;
++            close_deferred = (bitfields >> 6) & 0x1;
++            deferred_gen_event = (bitfields >> 7) & 0x1;
++            seen_first_ACK = (bitfields >> 8) & 0x1;
++        }
++        SERIALIZE_PRINT("\t\tTCP_Analyzer:Done");
++    }
++template void TCP_Analyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar,
++        const unsigned int file_version);
++template void TCP_Analyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar,
++        const unsigned int file_version);
++
+ void TCP_ApplicationAnalyzer::Init()
+ 	{
+ 	Analyzer::Init();
+@@ -1918,6 +1981,41 @@
+ 		static_cast<TCP_SupportAnalyzer*>(sa)->PacketWithRST();
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(TCP_ApplicationAnalyzer,"TCP_ApplicationAnalyzer")
++template<class Archive>
++void TCP_ApplicationAnalyzer::serialize(Archive & ar, 
++        const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:TCP_ApplicationAnalyzer:%d",__FILE__,__LINE__);
++
++        // Serialize Analyzer
++        ar & boost::serialization::base_object<Analyzer>( *this );
++        
++        SERIALIZE_PRINT("\t\tTCP_ApplicationAnalyzer:%d",__LINE__);
++        ar & tcp; 
++        SERIALIZE_PRINT("\t\tTCP_ApplicationAnalyzer:Done");
++    }
++template void TCP_ApplicationAnalyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar,
++        const unsigned int file_version);
++template void TCP_ApplicationAnalyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar,
++        const unsigned int file_version);
++
++BOOST_CLASS_EXPORT_GUID(TCP_SupportAnalyzer,"TCP_SupportAnalyzer")
++template<class Archive>
++void TCP_SupportAnalyzer::serialize(Archive & ar, const unsigned int version)
++    {
++        // Serialize SupportAnalyzer
++        ar & boost::serialization::base_object<SupportAnalyzer>(*this);
++    }
++template void TCP_SupportAnalyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void TCP_SupportAnalyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ TCPStats_Endpoint::TCPStats_Endpoint(TCP_Endpoint* e)
+ 	{
+ 	endp = e;
+@@ -2049,6 +2147,28 @@
+ 	return stats;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(TCPStats_Endpoint,"TCPStats_Endpoint")
++template<class Archive>
++void TCPStats_Endpoint::serialize(Archive & ar, const unsigned int version)
++    {
++        ar & endp;
++        ar & num_pkts;
++        ar & num_rxmit;
++        ar & num_rxmit_bytes;
++        ar & num_in_order;
++        ar & num_OO;
++        ar & num_repl;
++        ar & max_top_seq;
++        ar & last_id;
++        ar & endian_type;
++    }
++template void TCPStats_Endpoint::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar,
++        const unsigned int file_version);
++template void TCPStats_Endpoint::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar,
++        const unsigned int file_version);
++
+ TCPStats_Analyzer::TCPStats_Analyzer(Connection* c)
+ : TCP_ApplicationAnalyzer(AnalyzerTag::TCPStats, c)
+ 	{
+@@ -2088,3 +2208,20 @@
+ 	else
+ 		resp_stats->DataSent(network_time, seq, len, caplen, data, ip, 0);
+ 	}
++
++BOOST_CLASS_EXPORT_GUID(TCPStats_Analyzer,"TCPStats_Analyzer")
++template<class Archive>
++void TCPStats_Analyzer::serialize(Archive & ar, const unsigned int version)
++    {
++        // Serialize TCP_ApplicationAnalyzer
++        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
++
++        ar & orig_stats;
++        ar & resp_stats;
++    }
++template void TCPStats_Analyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar,
++        const unsigned int file_version);
++template void TCPStats_Analyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar,
++        const unsigned int file_version);
+diff -urN bro-2.1/src/TCP_Endpoint.cc bro-2.1-sdmbn/src/TCP_Endpoint.cc
+--- bro-2.1/src/TCP_Endpoint.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/TCP_Endpoint.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -8,6 +8,10 @@
+ #include "Event.h"
+ #include "File.h"
+ #include "Val.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include "SDMBNlocal.h"
+ 
+ TCP_Endpoint::TCP_Endpoint(TCP_Analyzer* arg_analyzer, int arg_is_orig)
+ 	{
+@@ -21,11 +25,13 @@
+ 	window_scale = 0;
+ 	window_seq = window_ack_seq = 0;
+ 	contents_start_seq = 0;
++    FIN_seq = 0;
+ 	SYN_cnt = FIN_cnt = RST_cnt = 0;
+ 	did_close = 0;
+ 	contents_file = 0;
+ 	tcp_analyzer = arg_analyzer;
+ 	is_orig = arg_is_orig;
++    hist_last_SYN = hist_last_FIN = hist_last_RST = 0;
+ 
+ 	src_addr = is_orig ? tcp_analyzer->Conn()->RespAddr() :
+ 				tcp_analyzer->Conn()->OrigAddr();
+@@ -245,3 +251,47 @@
+ 	tcp_analyzer->Conn()->AddHistory(code);
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(TCP_Endpoint,"TCP_Endpoint")
++template<class Archive>
++void TCP_Endpoint::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:TCP_Endpoint:%d",__FILE__,__LINE__);
++
++        ar & state;
++        ar & prev_state;
++        ar & peer;
++        ar & contents_processor;
++        ar & tcp_analyzer;
++        ar & contents_file;
++        ar & checksum_base;
++        ar & start_time;
++        ar & last_time;
++        ar & src_addr;
++        ar & dst_addr;
++        ar & window;
++        ar & window_scale;
++        ar & window_ack_seq;
++        ar & window_seq;
++        ar & contents_start_seq;
++        ar & FIN_seq;
++        ar & SYN_cnt;
++        ar & FIN_cnt;
++        ar & RST_cnt;
++        ar & did_close;
++        ar & is_orig;
++        ar & hist_last_SYN;
++        ar & hist_last_FIN;
++        ar & hist_last_RST;
++        ar & start_seq;
++        ar & last_seq;
++        ar & ack_seq;
++        ar & last_seq_high;
++        ar & ack_seq_high;
++        SERIALIZE_PRINT("\t\tTCP_Endpoint:Done");
++    }   
++template void TCP_Endpoint::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void TCP_Endpoint::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/TCP_Endpoint.h bro-2.1-sdmbn/src/TCP_Endpoint.h
+--- bro-2.1/src/TCP_Endpoint.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/TCP_Endpoint.h	2014-02-17 17:20:07.000000003 -0600
+@@ -4,6 +4,7 @@
+ #define tcpendpoint_h
+ 
+ #include "IPAddr.h"
++#include <boost/serialization/access.hpp>
+ 
+ typedef enum {
+ 	TCP_ENDPOINT_INACTIVE,	// no SYN (or other packets) seen for this side
+@@ -150,6 +151,12 @@
+ protected:
+ 	uint32 start_seq, last_seq, ack_seq;	// in host order
+ 	uint32 last_seq_high, ack_seq_high;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    TCP_Endpoint() {}; // Dummy default constructor for serialization
+ };
+ 
+ #define ENDIAN_UNKNOWN 0
+diff -urN bro-2.1/src/TCP.h bro-2.1-sdmbn/src/TCP.h
+--- bro-2.1/src/TCP.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/TCP.h	2014-02-17 17:20:07.000000003 -0600
+@@ -7,6 +7,7 @@
+ #include "TCP.h"
+ #include "PacketDumper.h"
+ #include "IPAddr.h"
++#include <boost/serialization/access.hpp>
+ 
+ // We define two classes here:
+ // - TCP_Analyzer is the analyzer for the TCP protocol itself.
+@@ -256,6 +257,12 @@
+ 
+ 	// Whether we have seen the first ACK from the originator.
+ 	unsigned int seen_first_ACK: 1;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++    
++    TCP_Analyzer() {}; // Dummy default constructor for serialization
+ };
+ 
+ class TCP_ApplicationAnalyzer : public Analyzer {
+@@ -312,6 +319,10 @@
+ 
+ private:
+ 	TCP_Analyzer* tcp;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class TCP_SupportAnalyzer : public SupportAnalyzer {
+@@ -328,6 +339,12 @@
+ 	virtual void ConnectionFinished(int half_finished)	{ }
+ 	virtual void ConnectionReset()	{ }
+ 	virtual void PacketWithRST()	{ }
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++    
++    TCP_SupportAnalyzer() {}; // Dummy default constructor for serialization
+ };
+ 
+ 
+@@ -351,6 +368,12 @@
+ 	int max_top_seq;
+ 	int last_id;
+ 	int endian_type;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++    
++    TCPStats_Endpoint() {}; // Dummy default constructor for serialization
+ };
+ 
+ class TCPStats_Analyzer : public TCP_ApplicationAnalyzer {
+@@ -372,6 +395,12 @@
+ 
+ 	TCPStats_Endpoint* orig_stats;
+ 	TCPStats_Endpoint* resp_stats;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    TCPStats_Analyzer() {}; // Dummy default constructor for serialization
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/TCP_Reassembler.cc bro-2.1-sdmbn/src/TCP_Reassembler.cc
+--- bro-2.1/src/TCP_Reassembler.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/TCP_Reassembler.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -4,6 +4,10 @@
+ #include "TCP_Reassembler.h"
+ #include "TCP.h"
+ #include "TCP_Endpoint.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include "SDMBNlocal.h"
+ 
+ // Only needed for gap_report events.
+ #include "Event.h"
+@@ -665,3 +669,65 @@
+ 
+ 	return 0;
+ 	}
++
++BOOST_CLASS_EXPORT_GUID(TCP_Reassembler,"TCP_Reassembler")
++template<class Archive>
++void TCP_Reassembler::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:TCP_Reassembler:%d",__FILE__,__LINE__);
++
++        // Serialize Reassembler
++        ar & boost::serialization::base_object<Reassembler>(*this);
++
++        SERIALIZE_PRINT("\t\tTCP_Reassembler:%d",__LINE__);
++        ar & endp;
++
++        // Special handling of bit fields
++        unsigned int bitfields = 0;
++        if (!Archive::is_loading::value)
++        {
++            bitfields |= (deliver_tcp_contents << 0);
++            bitfields |= (had_gap << 1);
++            bitfields |= (did_EOF << 2);
++            bitfields |= (skip_deliveries << 3);
++        }
++        ar & bitfields;
++        if (Archive::is_loading::value)
++        {
++            deliver_tcp_contents = (bitfields >> 0) & 0x1;
++            had_gap = (bitfields >> 1) & 0x1;
++            did_EOF = (bitfields >> 2) & 0x1;
++            skip_deliveries = (bitfields >> 3) & 0x1;
++        }
++     
++#ifdef ENABLE_SEQ_TO_SKIP
++	    ar & seq_to_skip;
++#endif
++        SERIALIZE_PRINT("\t\tTCP_Reassembler:%d",__LINE__);
++        ar & in_delivery;
++        //ar & record_contents_file; //FIXME
++        if (Archive::is_loading::value) { record_contents_file = NULL; } //TMPHACK
++        
++        // Special check for analyzer serializability
++        if (!Archive::is_loading::value)
++        {
++            if (dst_analyzer != NULL)
++            { assert(sdmbn_can_serialize(dst_analyzer->GetTag())); }
++
++            if (tcp_analyzer != NULL)
++            { assert(sdmbn_can_serialize(tcp_analyzer->GetTag())); }
++        }
++        ar & dst_analyzer;
++        ar & tcp_analyzer;
++
++        SERIALIZE_PRINT("\t\tTCP_Reassembler:%d",__LINE__);
++        ar & type;
++        ar & is_orig;
++        SERIALIZE_PRINT("\t\tTCP_Reassembler:Done");
++    }
++template void TCP_Reassembler::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void TCP_Reassembler::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/TCP_Reassembler.h bro-2.1-sdmbn/src/TCP_Reassembler.h
+--- bro-2.1/src/TCP_Reassembler.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/TCP_Reassembler.h	2014-02-17 17:20:07.000000003 -0600
+@@ -3,6 +3,7 @@
+ 
+ #include "Reassem.h"
+ #include "TCP_Endpoint.h"
++#include <boost/serialization/access.hpp>
+ 
+ // The skip_to_seq feature does not work correctly with connections >2GB due
+ // to use of 32 bit signed ints (see comments in TCP_Reassembler.cc) Since
+@@ -130,6 +131,10 @@
+ 
+ 	Type type;
+ 	bool is_orig;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/Teredo.cc bro-2.1-sdmbn/src/Teredo.cc
+--- bro-2.1/src/Teredo.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Teredo.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -2,6 +2,9 @@
+ #include "Teredo.h"
+ #include "IP.h"
+ #include "Reporter.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
+ 
+ void Teredo_Analyzer::Done()
+ 	{
+@@ -9,6 +12,20 @@
+ 	Event(udp_session_done);
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(Teredo_Analyzer,"Teredo_Analyzer")
++template<class Archive>
++void Teredo_Analyzer::serialize(Archive & ar, const unsigned int version)
++    {
++        // Serialize Analyzer 
++        ar & boost::serialization::base_object<Analyzer>(*this);
++    }
++template void Teredo_Analyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void Teredo_Analyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ bool TeredoEncapsulation::DoParse(const u_char* data, int& len,
+                                   bool found_origin, bool found_auth)
+ 	{
+diff -urN bro-2.1/src/Teredo.h bro-2.1-sdmbn/src/Teredo.h
+--- bro-2.1/src/Teredo.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Teredo.h	2014-02-17 17:20:07.000000003 -0600
+@@ -3,6 +3,7 @@
+ 
+ #include "Analyzer.h"
+ #include "NetVar.h"
++#include <boost/serialization/access.hpp>
+ 
+ class Teredo_Analyzer : public Analyzer {
+ public:
+@@ -38,6 +39,12 @@
+ protected:
+ 	friend class AnalyzerTimer;
+ 	void ExpireTimer(double t);
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    Teredo_Analyzer() {}; // Dummy default constructor for serialization
+ };
+ 
+ class TeredoEncapsulation {
+diff -urN bro-2.1/src/Timer.cc bro-2.1-sdmbn/src/Timer.cc
+--- bro-2.1/src/Timer.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Timer.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -6,6 +6,10 @@
+ #include "Timer.h"
+ #include "Desc.h"
+ #include "Serializer.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include "SDMBNlocal.h"
+ 
+ // Names of timers in same order than in TimerType.
+ const char* TimerNames[] = {
+@@ -86,6 +90,33 @@
+ 	return UNSERIALIZE(&time);
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(Timer,"Timer")
++template<class Archive>
++void Timer::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:Timer:%d",__FILE__,__LINE__);
++        // Serialize PQ_Element
++//        ar & boost::serialization::base_object<PQ_Element>(*this);
++
++        // Special handling of bit field
++        unsigned int bitfields = 0;
++        if (!Archive::is_loading::value)
++        {
++            bitfields |= (type << 0);
++        }
++        ar & bitfields;
++        if (Archive::is_loading::value)
++        {
++            type = (bitfields >> 0) & 0xFF;
++        } 
++    }
++template void Timer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void Timer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ unsigned int TimerMgr::current_timers[NUM_TIMER_TYPES];
+ 
+ TimerMgr::~TimerMgr()
+@@ -106,6 +137,24 @@
+ 	return DoAdvance(t, max_expire);
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(TimerMgr,"TimerMgr")
++template<class Archive>
++void TimerMgr::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:TimerMgr:%d",__FILE__,__LINE__);
++
++        ar & t;
++        ar & last_timestamp;
++        ar & last_advance;
++        ar & tag;
++        ar & num_expired;
++    }
++template void TimerMgr::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void TimerMgr::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+ 
+ PQ_TimerMgr::PQ_TimerMgr(const Tag& tag) : TimerMgr(tag)
+ 	{
+@@ -178,6 +227,24 @@
+ 	delete timer;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(PQ_TimerMgr,"PQ_TimerMgr")
++template<class Archive>
++void PQ_TimerMgr::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:PQ_TimerMgr:%d",__FILE__,__LINE__);
++        // Serialize TimerMgr
++        ar & boost::serialization::base_object<TimerMgr>(*this);
++
++        //ar & q; //FIXME
++        if (Archive::is_loading::value) { q = NULL; } //TMPHACK
++    }
++template void PQ_TimerMgr::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void PQ_TimerMgr::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ CQ_TimerMgr::CQ_TimerMgr(const Tag& tag) : TimerMgr(tag)
+ 	{
+ 	cq = cq_init(60.0, 1.0);
+@@ -260,3 +327,21 @@
+ 		delete timer;
+ 		}
+ 	}
++
++BOOST_CLASS_EXPORT_GUID(CQ_TimerMgr,"CQ_TimerMgr")
++template<class Archive>
++void CQ_TimerMgr::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:CQ_TimerMgr:%d",__FILE__,__LINE__);
++        // Serialize TimerMgr
++        ar & boost::serialization::base_object<TimerMgr>(*this);
++
++        //ar & cq; //FIXME
++        if (Archive::is_loading::value) { cq = NULL; } //TMPHACK
++    }
++template void CQ_TimerMgr::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void CQ_TimerMgr::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/Timer.h bro-2.1-sdmbn/src/Timer.h
+--- bro-2.1/src/Timer.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Timer.h	2014-02-17 17:20:07.000000003 -0600
+@@ -8,6 +8,7 @@
+ #include <string>
+ #include "SerialObj.h"
+ #include "PriorityQueue.h"
++#include <boost/serialization/access.hpp>
+ 
+ extern "C" {
+ #include "cq.h"
+@@ -75,6 +76,10 @@
+ 	DECLARE_ABSTRACT_SERIAL(Timer);
+ 
+ 	unsigned int type:8;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class TimerMgr {
+@@ -135,6 +140,12 @@
+ 	int num_expired;
+ 
+ 	static unsigned int current_timers[NUM_TIMER_TYPES];
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    TimerMgr() {}; // Dummy default constructor for serialization
+ };
+ 
+ class PQ_TimerMgr : public TimerMgr {
+@@ -157,6 +168,12 @@
+ 	Timer* Top()			{ return (Timer*) q->Top(); }
+ 
+ 	PriorityQueue* q;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    PQ_TimerMgr() {}; // Dummy default constructor for serialization
+ };
+ 
+ class CQ_TimerMgr : public TimerMgr {
+@@ -176,6 +193,12 @@
+ 	void Remove(Timer* timer);
+ 
+ 	struct cq_handle *cq;
++    
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    CQ_TimerMgr() {}; // Dummy default constructor for serialization
+ };
+ 
+ extern TimerMgr* timer_mgr;
+diff -urN bro-2.1/src/TunnelEncapsulation.cc bro-2.1-sdmbn/src/TunnelEncapsulation.cc
+--- bro-2.1/src/TunnelEncapsulation.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/TunnelEncapsulation.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -3,6 +3,10 @@
+ #include "TunnelEncapsulation.h"
+ #include "util.h"
+ #include "Conn.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include <boost/serialization/vector.hpp>
+ 
+ EncapsulatingConn::EncapsulatingConn(Connection* c, BifEnum::Tunnel::Type t)
+ 		: src_addr(c->OrigAddr()), dst_addr(c->RespAddr()),
+@@ -34,6 +38,25 @@
+ 	return rv;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(EncapsulatingConn,"EncapsulatingConn")
++template<class Archive>
++void EncapsulatingConn::serialize(Archive & ar, const unsigned int version)
++    {
++        ar & src_addr;
++        ar & dst_addr;
++        ar & src_port;
++        ar & dst_port;
++        ar & proto;
++        ar & type;
++        ar & uid;
++    }
++template void EncapsulatingConn::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void EncapsulatingConn::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ bool operator==(const EncapsulationStack& e1, const EncapsulationStack& e2)
+ 	{
+ 	if ( ! e1.conns )
+@@ -53,3 +76,17 @@
+ 
+ 	return true;
+ 	}
++
++BOOST_CLASS_EXPORT_GUID(EncapsulationStack,"EncapsulationStack")
++template<class Archive>
++void EncapsulationStack::serialize(Archive & ar, const unsigned int version)
++    {
++        printf("%s:EncapsulationStack:%d\n",__FILE__,__LINE__);
++//        ar & conns; //REINCLUDE
++    }
++template void EncapsulationStack::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void EncapsulationStack::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/TunnelEncapsulation.h bro-2.1-sdmbn/src/TunnelEncapsulation.h
+--- bro-2.1/src/TunnelEncapsulation.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/TunnelEncapsulation.h	2014-02-17 17:20:07.000000003 -0600
+@@ -8,6 +8,8 @@
+ #include "IPAddr.h"
+ #include "Val.h"
+ #include <vector>
++#include <boost/serialization/access.hpp>
++#include <boost/serialization/vector.hpp>
+ 
+ class Connection;
+ 
+@@ -109,6 +111,10 @@
+ 	TransportProto proto;
+ 	BifEnum::Tunnel::Type type;
+ 	uint64 uid;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ /**
+@@ -203,6 +209,10 @@
+ 
+ protected:
+ 	vector<EncapsulatingConn>* conns;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/Type.cc bro-2.1-sdmbn/src/Type.cc
+--- bro-2.1/src/Type.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Type.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -8,6 +8,12 @@
+ #include "Scope.h"
+ #include "Serializer.h"
+ #include "Reporter.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include <boost/serialization/binary_object.hpp>
++#include <boost/serialization/list.hpp>
++#include "SDMBNlocal.h"
+ 
+ #include <string>
+ #include <list>
+@@ -290,6 +296,59 @@
+ 	return true;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(BroType,"BroType")
++template<class Archive>
++void BroType::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:BroType:%d",__FILE__,__LINE__);
++        // Serialize BroObj
++        ar & boost::serialization::base_object<BroObj>(*this);
++
++        SERIALIZE_PRINT("\t\tBroType:%d",__LINE__);
++        ar & tag;
++        ar & internal_tag;
++        ar & is_network_order;
++        ar & base_type;
++
++        // Special handling of type_id 
++        SERIALIZE_PRINT("\t\tBroType:%d",__LINE__);
++        int type_id_len;
++        if (!Archive::is_loading::value)
++        {   
++            if (NULL == type_id)
++            { type_id_len = 0; }
++            else
++            { type_id_len = strlen(type_id)+1; } 
++        }
++        ar & type_id_len;
++        if (!Archive::is_loading::value)
++        { 
++            if (type_id_len > 0)
++            {
++                ar & boost::serialization::make_binary_object((void *)type_id, 
++                        type_id_len); 
++            }
++        }
++        if (Archive::is_loading::value)
++        {
++            if (type_id_len > 0)
++            {
++                type_id = new char[type_id_len];
++                ar & boost::serialization::make_binary_object(
++                        const_cast<char* &>(type_id), type_id_len);
++            }
++            else
++            { type_id = NULL; }
++        }
++        SERIALIZE_PRINT("\t\tBroType:Done");
++    }
++template void BroType::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void BroType::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ TypeList::~TypeList()
+ 	{
+ 	loop_over_list(types, i)
+@@ -393,6 +452,24 @@
+ 	return true;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(TypeList,"TypeList")
++template<class Archive>
++void TypeList::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:TypeList:%d",__FILE__,__LINE__);
++        // Serialize BroType
++        ar & boost::serialization::base_object<BroType>(*this);
++
++        ar & pure_type;
++        ar & types;
++    }
++template void TypeList::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void TypeList::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ IndexType::~IndexType()
+ 	{
+ 	Unref(indices);
+@@ -513,6 +590,24 @@
+ 	return indices != 0;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(IndexType,"IndexType")
++template<class Archive>
++void IndexType::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:IndexType:%d",__FILE__,__LINE__);
++        // Serialize BroType
++        ar & boost::serialization::base_object<BroType>(*this);
++
++        ar & indices;
++        ar & yield_type;
++    }
++template void IndexType::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void IndexType::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ TableType::TableType(TypeList* ind, BroType* yield)
+ : IndexType(TYPE_TABLE, ind, yield)
+ 	{
+@@ -628,6 +723,21 @@
+ 	return true;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(TableType,"TableType")
++template<class Archive>
++void TableType::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:TableType:%d",__FILE__,__LINE__);
++        // Serialize IndexType
++        ar & boost::serialization::base_object<IndexType>(*this);
++    }
++template void TableType::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void TableType::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ SetType::~SetType()
+ 	{
+ 	Unref(elements);
+@@ -651,6 +761,24 @@
+ 	return true;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(SetType,"SetType")
++template<class Archive>
++void SetType::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:SetType:%d",__FILE__,__LINE__);
++        // Serialize TableType
++        ar & boost::serialization::base_object<TableType>(*this);
++
++        //ar & elements; //FIXME
++        if (Archive::is_loading::value) { elements = NULL; } //TMPHACK
++    }
++template void SetType::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void SetType::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ FuncType::FuncType(RecordType* arg_args, BroType* arg_yield, int arg_is_event)
+ : BroType(TYPE_FUNC)
+ 	{
+@@ -777,6 +905,42 @@
+ 	return UNSERIALIZE(&is_event);
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(FuncType,"FuncType")
++template<class Archive>
++void FuncType::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:FuncType:%d",__FILE__,__LINE__);
++        // Serialize BroType
++        ar & boost::serialization::base_object<BroType>(*this);
++
++        ar & args;
++        ar & arg_types;
++        ar & yield;
++        ar & is_event;
++        ar & return_value;
++    }
++template void FuncType::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void FuncType::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
++BOOST_CLASS_EXPORT_GUID(TypeType,"TypeType")
++template<class Archive>
++void TypeType::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:TypeType:%d",__FILE__,__LINE__);
++        // Serialize BroType
++        ar & boost::serialization::base_object<BroType>(*this);
++    }
++template void TypeType::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void TypeType::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ TypeDecl::TypeDecl(BroType* t, const char* i, attr_list* arg_attrs, bool in_record)
+ 	{
+ 	type = t;
+@@ -841,6 +1005,24 @@
+ 		}
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(TypeDecl,"TypeDecl")
++template<class Archive>
++void TypeDecl::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:TypeDecl:%d",__FILE__,__LINE__);
++
++        ar & type;
++        ar & attrs;
++        //ar & id; //FIXME
++        if (Archive::is_loading::value) { id = NULL; } //TMPHACK
++    }
++template void TypeDecl::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void TypeDecl::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ CommentedTypeDecl::CommentedTypeDecl(BroType* t, const char* i,
+ 			attr_list* attrs, bool in_record, std::list<std::string>* cmnt_list)
+ 	: TypeDecl(t, i, attrs, in_record)
+@@ -872,6 +1054,23 @@
+ 		}
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(CommentedTypeDecl,"CommentedTypeDecl")
++template<class Archive>
++void CommentedTypeDecl::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:CommentedTypeDecl:%d",__FILE__,__LINE__);
++        // Serialize TypeDecl
++        ar & boost::serialization::base_object<TypeDecl>(*this);
++
++        ar & comments;
++    }
++template void CommentedTypeDecl::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void CommentedTypeDecl::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ RecordType::RecordType(type_decl_list* arg_types) : BroType(TYPE_RECORD)
+ 	{
+ 	types = arg_types;
+@@ -1128,6 +1327,24 @@
+ 	return true;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(RecordType,"RecordType")
++template<class Archive>
++void RecordType::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:RecordType:%d",__FILE__,__LINE__);
++        // Serialize BroType
++        ar & boost::serialization::base_object<BroType>(*this);
++
++        ar & num_fields;
++        ar & types; 
++    }
++template void RecordType::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void RecordType::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ SubNetType::SubNetType() : BroType(TYPE_SUBNET)
+ 	{
+ 	}
+@@ -1154,6 +1371,21 @@
+ 	return true;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(SubNetType,"SubNetType")
++template<class Archive>
++void SubNetType::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:SubNetType:%d",__FILE__,__LINE__);
++        // Serialize BroType
++        ar & boost::serialization::base_object<BroType>(*this);
++    }
++template void SubNetType::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void SubNetType::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ FileType::FileType(BroType* yield_type)
+ : BroType(TYPE_FILE)
+ 	{
+@@ -1202,6 +1434,23 @@
+ 	return yield != 0;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(FileType,"FileType")
++template<class Archive>
++void FileType::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:FileType:%d",__FILE__,__LINE__);
++        // Serialize BroType
++        ar & boost::serialization::base_object<BroType>(*this);
++
++        ar & yield;
++    }
++template void FileType::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void FileType::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ EnumType::EnumType()
+ : BroType(TYPE_ENUM)
+ 	{
+@@ -1418,6 +1667,41 @@
+ 	return true;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(EnumType,"EnumType")
++template<class Archive>
++void EnumType::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:EnumType:%d",__FILE__,__LINE__);
++        // Serialize BroType
++        ar & boost::serialization::base_object<BroType>(*this);
++
++        //ar & names; //FIXME
++        ar & counter;
++    }
++template void EnumType::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void EnumType::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
++BOOST_CLASS_EXPORT_GUID(CommentedEnumType,"CommentedEnumType")
++template<class Archive>
++void CommentedEnumType::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:CommentedEnumType:%d",__FILE__,__LINE__);
++        // Serialize EnumType
++        ar & boost::serialization::base_object<EnumType>(*this);
++
++        //ar & comments; //FIXME
++    }
++template void CommentedEnumType::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void CommentedEnumType::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ VectorType::VectorType(BroType* element_type)
+ : BroType(TYPE_VECTOR)
+ 	{
+@@ -1477,6 +1761,23 @@
+ 	yield_type->Describe(d);
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(VectorType,"VectorType")
++template<class Archive>
++void VectorType::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:VectorType:%d",__FILE__,__LINE__);
++        // Serialize BroType
++        ar & boost::serialization::base_object<BroType>(*this);
++
++        ar & yield_type;
++    }
++template void VectorType::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void VectorType::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ BroType* base_type(TypeTag tag)
+ 	{
+ 	static BroType* base_types[NUM_TYPES];
+diff -urN bro-2.1/src/Type.h bro-2.1-sdmbn/src/Type.h
+--- bro-2.1/src/Type.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Type.h	2014-02-17 17:20:07.000000003 -0600
+@@ -11,6 +11,7 @@
+ #include "Attr.h"
+ #include "BroList.h"
+ #include "Dict.h"
++#include <boost/serialization/access.hpp>
+ 
+ // BRO types.
+ 
+@@ -241,6 +242,10 @@
+ 	// This type_id field is only used by the documentation framework to
+ 	// track the names of declared types.
+ 	const char* type_id;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class TypeList : public BroType {
+@@ -285,6 +290,10 @@
+ 
+ 	BroType* pure_type;
+ 	type_list types;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class IndexType : public BroType {
+@@ -315,6 +324,10 @@
+ 
+ 	TypeList* indices;
+ 	BroType* yield_type;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class TableType : public IndexType {
+@@ -331,6 +344,10 @@
+ 	TypeList* ExpandRecordIndex(RecordType* rt) const;
+ 
+ 	DECLARE_SERIAL(TableType)
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class SetType : public TableType {
+@@ -346,6 +363,10 @@
+ 	ListExpr* elements;
+ 
+ 	DECLARE_SERIAL(SetType)
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class FuncType : public BroType {
+@@ -382,6 +403,10 @@
+ 	BroType* yield;
+ 	int is_event;
+ 	ID* return_value;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class TypeType : public BroType {
+@@ -395,6 +420,10 @@
+ 	TypeType()	{}
+ 
+ 	BroType* type;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class TypeDecl {
+@@ -413,6 +442,12 @@
+ 	BroType* type;
+ 	Attributes* attrs;
+ 	const char* id;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++    
++    TypeDecl() {}; // Dummy default constructor for serialization
+ };
+ 
+ class CommentedTypeDecl : public TypeDecl {
+@@ -424,6 +459,12 @@
+ 	void DescribeReST(ODesc* d) const;
+ 
+ 	std::list<std::string>* comments;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    CommentedTypeDecl() {}; // Dummy default constructor for serialization
+ };
+ 
+ class RecordType : public BroType {
+@@ -468,6 +509,10 @@
+ 
+ 	int num_fields;
+ 	type_decl_list* types;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class SubNetType : public BroType {
+@@ -476,6 +521,10 @@
+ 	void Describe(ODesc* d) const;
+ protected:
+ 	DECLARE_SERIAL(SubNetType)
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class FileType : public BroType {
+@@ -493,6 +542,10 @@
+ 	DECLARE_SERIAL(FileType)
+ 
+ 	BroType* yield;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class EnumType : public BroType {
+@@ -529,6 +582,10 @@
+ 	// as a flag to prevent mixing of auto-increment and explicit
+ 	// enumerator specifications.
+ 	bro_int_t counter;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class CommentedEnumType: public EnumType {
+@@ -550,6 +607,10 @@
+ 	// Comments are only filled when in "documentation mode".
+ 	typedef std::map< const char*, std::list<std::string>*, ltstr > CommentMap;
+ 	CommentMap comments;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class VectorType : public BroType {
+@@ -572,6 +633,10 @@
+ 	DECLARE_SERIAL(VectorType)
+ 
+ 	BroType* yield_type;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ // Returns the BRO basic (non-parameterized) type with the given type.
+diff -urN bro-2.1/src/UDP.cc bro-2.1-sdmbn/src/UDP.cc
+--- bro-2.1/src/UDP.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/UDP.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -8,6 +8,10 @@
+ #include "NetVar.h"
+ #include "UDP.h"
+ #include "Reporter.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include "SDMBNlocal.h"
+ 
+ UDP_Analyzer::UDP_Analyzer(Connection* conn)
+ : TransportLayerAnalyzer(AnalyzerTag::UDP, conn)
+@@ -227,3 +231,22 @@
+ 
+ 	return sum == 0xffff;
+ 	}
++
++BOOST_CLASS_EXPORT_GUID(UDP_Analyzer,"UDP_Analyzer")
++template<class Archive>
++void UDP_Analyzer::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:UDP_Analyzer:%d",__FILE__,__LINE__);
++
++        // Serialize TransportLayerAnalyzer
++        ar & boost::serialization::base_object<TransportLayerAnalyzer>(*this); 
++        ar & request_len;
++        ar & reply_len;
++        SERIALIZE_PRINT("\t\tUDP_Analyzer:Done");
++    }
++template void UDP_Analyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void UDP_Analyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/UDP.h bro-2.1-sdmbn/src/UDP.h
+--- bro-2.1/src/UDP.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/UDP.h	2014-02-17 17:20:07.000000003 -0600
+@@ -5,6 +5,7 @@
+ 
+ #include "Analyzer.h"
+ #include <netinet/udp.h>
++#include <boost/serialization/access.hpp>
+ 
+ typedef enum {
+ 	UDP_INACTIVE,	// no packet seen
+@@ -45,6 +46,12 @@
+ #define HIST_RESP_DATA_PKT 0x2
+ #define HIST_ORIG_CORRUPT_PKT 0x4
+ #define HIST_RESP_CORRUPT_PKT 0x8
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    UDP_Analyzer() {}; // Dummy default constructor for serialization
+ };
+ 
+ #endif
+diff -urN bro-2.1/src/Val.cc bro-2.1-sdmbn/src/Val.cc
+--- bro-2.1/src/Val.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Val.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -26,10 +26,17 @@
+ #include "Conn.h"
+ #include "Reporter.h"
+ #include "IPAddr.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include <boost/serialization/list.hpp>
++#include <boost/serialization/vector.hpp>
++#include "SDMBNlocal.h"
+ 
+ Val::Val(Func* f)
+ 	{
+ 	val.func_val = f;
++    val_type = BROVALUNION_FUNC;
+ 	type = f->FType()->Ref();
+ 	attribs = 0;
+ #ifdef DEBUG
+@@ -44,6 +51,7 @@
+ 		string_file_type = new FileType(base_type(TYPE_STRING));
+ 
+ 	val.file_val = f;
++    val_type = BROVALUNION_FILE;
+ 
+ 	assert(f->FType()->Tag() == TYPE_STRING);
+ 	type = string_file_type->Ref();
+@@ -163,6 +171,7 @@
+ 					// Different, so let's bind the val
+ 					// to the local type.
+ 					v->val.int_val = lv;
++                    v->val_type = BROVALUNION_INT;
+ 					Unref(rt);
+ 					v->type = lt;
+ 					::Ref(lt);
+@@ -270,18 +279,21 @@
+ 			return false;
+ 
+ 		val.string_val = new BroString((u_char*) str, len, 1);
++        val_type = BROVALUNION_STRING;
+ 		delete [] str;
+ 		return true;
+ 
+ 	case TYPE_INTERNAL_ADDR:
+ 		{
+ 		val.addr_val = new IPAddr();
++        val_type = BROVALUNION_ADDR;
+ 		return UNSERIALIZE(val.addr_val);
+ 		}
+ 
+ 	case TYPE_INTERNAL_SUBNET:
+ 		{
+ 		val.subnet_val = new IPPrefix();
++        val_type = BROVALUNION_SUBNET;
+ 		return UNSERIALIZE(val.subnet_val);
+ 		}
+ 
+@@ -292,11 +304,13 @@
+ 		if ( type->Tag() == TYPE_FUNC )
+ 			{
+ 			val.func_val = Func::Unserialize(info);
++            val_type = BROVALUNION_FUNC;
+ 			return val.func_val != 0;
+ 			}
+ 		else if ( type->Tag() == TYPE_FILE )
+ 			{
+ 			val.file_val = BroFile::Unserialize(info);
++            val_type = BROVALUNION_FILE;
+ 			return val.file_val != 0;
+ 			}
+ 		return true;
+@@ -532,6 +546,112 @@
+ 	}
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(Val,"Val")
++template<class Archive>
++void Val::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:Val:%d",__FILE__,__LINE__);
++        // Serialize BroObj
++        ar & boost::serialization::base_object<BroObj>(*this);
++        
++        ar & val_type;
++
++        // Special handling of value union
++        if (!Archive::is_loading::value)
++        {
++            switch(val_type)
++            {
++            case BROVALUNION_INT:
++                ar & val.int_val;
++                break;
++            case BROVALUNION_UINT:
++                ar & val.uint_val;
++                break;
++            case BROVALUNION_ADDR:
++                ar & val.addr_val;
++                break;
++            case BROVALUNION_SUBNET:
++                ar & val.subnet_val;
++                break;
++            case BROVALUNION_DOUBLE:
++                ar & val.double_val;
++                break;
++            case BROVALUNION_STRING:
++                ar & val.string_val;
++                break;
++            case BROVALUNION_FUNC:
++                break;
++            case BROVALUNION_FILE:
++                ar & val.file_val;
++                break;
++            case BROVALUNION_RE:
++            case BROVALUNION_TABLE:
++            case BROVALUNION_LIST:
++                break;
++            case BROVALUNION_VECTOR:
++                ar & val.vector_val;
++                break;
++            default:
++                SERIALIZE_PRINT("ERROR: Unknown type for Val");
++                break;
++            }
++        }
++        if (Archive::is_loading::value)
++        {
++            switch(val_type)
++            {
++            case BROVALUNION_INT:
++                ar & val.int_val;
++                break;
++            case BROVALUNION_UINT:
++                ar & val.uint_val;
++                break;
++            case BROVALUNION_ADDR:
++                ar & val.addr_val;
++                break;
++            case BROVALUNION_SUBNET:
++                ar & val.subnet_val;
++                break;
++            case BROVALUNION_DOUBLE:
++                ar & val.double_val;
++                break;
++            case BROVALUNION_STRING:
++                ar & val.string_val;
++                break;
++            case BROVALUNION_FUNC:
++                val.func_val = NULL; //TMPHACK
++                break;
++            case BROVALUNION_FILE:
++                ar & val.file_val;
++                break;
++            case BROVALUNION_RE:
++                val.re_val = NULL; //TMPHACK
++                break;
++            case BROVALUNION_TABLE:
++                val.table_val = NULL; //TMPHACK
++                break;
++            case BROVALUNION_LIST:
++                val.val_list_val = NULL; //TMPHACK
++                break;
++            case BROVALUNION_VECTOR:
++                ar & val.vector_val;
++                break;
++            default:
++                SERIALIZE_PRINT("ERROR: Unknown type for Val");
++                break;
++            }
++        }
++
++        ar & type; 
++        ar & attribs;
++    }
++template void Val::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void Val::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ MutableVal::~MutableVal()
+ 	{
+ 	for ( list<ID*>::iterator i = aliases.begin(); i != aliases.end(); ++i )
+@@ -709,6 +829,26 @@
+ 	return true;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(MutableVal,"MutableVal")
++template<class Archive>
++void MutableVal::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:MutableVal:%d",__FILE__,__LINE__);
++        // Serialize Val
++        ar & boost::serialization::base_object<Val>(*this);
++
++        ar & id;
++        ar & aliases;
++        ar & props;
++        ar & last_modified;
++    }
++template void MutableVal::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void MutableVal::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ IntervalVal::IntervalVal(double quantity, double units) :
+ 	Val(quantity * units, TYPE_INTERVAL)
+ 	{
+@@ -765,6 +905,21 @@
+ 	return true;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(IntervalVal,"IntervalVal")
++template<class Archive>
++void IntervalVal::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:IntervalVal:%d",__FILE__,__LINE__);
++        // Serialize Val
++        ar & boost::serialization::base_object<Val>(*this);
++    }
++template void IntervalVal::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void IntervalVal::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ PortVal::PortVal(uint32 p, TransportProto port_type) : Val(TYPE_PORT)
+ 	{
+ 	// Note, for ICMP one-way connections:
+@@ -794,6 +949,7 @@
+ 	}
+ 
+ 	val.uint_val = static_cast<bro_uint_t>(p);
++    val_type = BROVALUNION_UINT;
+ 	}
+ 
+ PortVal::PortVal(uint32 p) : Val(TYPE_PORT)
+@@ -805,6 +961,7 @@
+ 		}
+ 
+ 	val.uint_val = static_cast<bro_uint_t>(p);
++    val_type = BROVALUNION_UINT;
+ 	}
+ 
+ uint32 PortVal::Port() const
+@@ -856,25 +1013,44 @@
+ 	return true;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(PortVal,"PortVal")
++template<class Archive>
++void PortVal::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:PortVal:%d",__FILE__,__LINE__);
++        // Serialize Val
++        ar & boost::serialization::base_object<Val>(*this);
++    }
++template void PortVal::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void PortVal::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ AddrVal::AddrVal(const char* text) : Val(TYPE_ADDR)
+ 	{
+ 	val.addr_val = new IPAddr(text);
++    val_type = BROVALUNION_ADDR;
+ 	}
+ 
+ AddrVal::AddrVal(uint32 addr) : Val(TYPE_ADDR)
+ 	{
+ 	// ### perhaps do gethostbyaddr here?
+ 	val.addr_val = new IPAddr(IPv4, &addr, IPAddr::Network);
++    val_type = BROVALUNION_ADDR;
+ 	}
+ 
+ AddrVal::AddrVal(const uint32 addr[4]) : Val(TYPE_ADDR)
+ 	{
+ 	val.addr_val = new IPAddr(IPv6, addr, IPAddr::Network);
++    val_type = BROVALUNION_ADDR;
+ 	}
+ 
+ AddrVal::AddrVal(const IPAddr& addr) : Val(TYPE_ADDR)
+ 	{
+ 	val.addr_val = new IPAddr(addr);
++    val_type = BROVALUNION_ADDR;
+ 	}
+ 
+ AddrVal::~AddrVal()
+@@ -909,6 +1085,21 @@
+ 	return true;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(AddrVal,"AddrVal")
++template<class Archive>
++void AddrVal::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:AddrVal:%d",__FILE__,__LINE__);
++        // Serialize Val
++        ar & boost::serialization::base_object<Val>(*this);
++    }
++template void AddrVal::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void AddrVal::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ SubNetVal::SubNetVal(const char* text) : Val(TYPE_SUBNET)
+ 	{
+ 	string s(text);
+@@ -918,39 +1109,46 @@
+ 		{
+ 		reporter->Error("Bad string in SubNetVal ctor: %s", text);
+ 		val.subnet_val = new IPPrefix();
++        val_type = BROVALUNION_SUBNET;
+ 		}
+ 	else
+ 		{
+ 		val.subnet_val = new IPPrefix(s.substr(0, slash_loc),
+ 		                              atoi(s.substr(slash_loc + 1).c_str()));
++        val_type = BROVALUNION_SUBNET;
+ 		}
+ 	}
+ 
+ SubNetVal::SubNetVal(const char* text, int width) : Val(TYPE_SUBNET)
+ 	{
+ 	val.subnet_val = new IPPrefix(text, width);
++    val_type = BROVALUNION_SUBNET;
+ 	}
+ 
+ SubNetVal::SubNetVal(uint32 addr, int width) : Val(TYPE_SUBNET)
+ 	{
+ 	IPAddr a(IPv4, &addr, IPAddr::Network);
+ 	val.subnet_val = new IPPrefix(a, width);
++    val_type = BROVALUNION_SUBNET;
+ 	}
+ 
+ SubNetVal::SubNetVal(const uint32* addr, int width) : Val(TYPE_SUBNET)
+ 	{
+ 	IPAddr a(IPv6, addr, IPAddr::Network);
+ 	val.subnet_val = new IPPrefix(a, width);
++    val_type = BROVALUNION_SUBNET;
+ 	}
+ 
+ SubNetVal::SubNetVal(const IPAddr& addr, int width) : Val(TYPE_SUBNET)
+ 	{
+ 	val.subnet_val = new IPPrefix(addr, width);
++    val_type = BROVALUNION_SUBNET;
+ 	}
+ 
+ SubNetVal::SubNetVal(const IPPrefix& prefix) : Val(TYPE_SUBNET)
+ 	{
+ 	val.subnet_val = new IPPrefix(prefix);
++    val_type = BROVALUNION_SUBNET;
+ 	}
+ 
+ SubNetVal::~SubNetVal()
+@@ -1033,20 +1231,38 @@
+ 	return true;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(SubNetVal,"SubNetVal")
++template<class Archive>
++void SubNetVal::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:SubNetVal:%d",__FILE__,__LINE__);
++        // Serialize Val
++        ar & boost::serialization::base_object<Val>(*this);
++    }
++template void SubNetVal::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void SubNetVal::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ StringVal::StringVal(BroString* s) : Val(TYPE_STRING)
+ 	{
+ 	val.string_val = s;
++    val_type = BROVALUNION_STRING;
+ 	}
+ 
+ StringVal::StringVal(int length, const char* s) : Val(TYPE_STRING)
+ 	{
+ 	// The following adds a NUL at the end.
+ 	val.string_val = new BroString((const u_char*)  s, length, 1);
++    val_type = BROVALUNION_STRING;
+ 	}
+ 
+ StringVal::StringVal(const char* s) : Val(TYPE_STRING)
+ 	{
+ 	val.string_val = new BroString(s);
++    val_type = BROVALUNION_STRING;
+ 	}
+ 
+ StringVal* StringVal::ToUpper()
+@@ -1084,9 +1300,25 @@
+ 	return true;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(StringVal,"StringVal")
++template<class Archive>
++void StringVal::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:StringVal:%d",__FILE__,__LINE__);
++        // Serialize Val
++        ar & boost::serialization::base_object<Val>(*this);
++    }
++template void StringVal::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void StringVal::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ PatternVal::PatternVal(RE_Matcher* re) : Val(base_type(TYPE_PATTERN))
+ 	{
+ 	val.re_val = re;
++    val_type = BROVALUNION_RE;
+ 	}
+ 
+ PatternVal::~PatternVal()
+@@ -1118,6 +1350,7 @@
+ 	{
+ 	delete AsPattern();
+ 	val.re_val = re;
++    val_type = BROVALUNION_RE;
+ 	}
+ 
+ void PatternVal::ValDescribe(ODesc* d) const
+@@ -1145,9 +1378,25 @@
+ 	DO_UNSERIALIZE(Val);
+ 
+ 	val.re_val = RE_Matcher::Unserialize(info);
++    val_type = BROVALUNION_RE;
+ 	return val.re_val != 0;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(PatternVal,"PatternVal")
++template<class Archive>
++void PatternVal::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:PatternVal:%d",__FILE__,__LINE__);
++        // Serialize Val
++        ar & boost::serialization::base_object<Val>(*this);
++    }
++template void PatternVal::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void PatternVal::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ ListVal::ListVal(TypeTag t)
+ : Val(new TypeList(t == TYPE_ANY ? 0 : base_type(t)))
+ 	{
+@@ -1303,7 +1552,39 @@
+ 		+ type->MemoryAllocation();
+ 	}
+ 
+-
++BOOST_CLASS_EXPORT_GUID(ListVal,"ListVal")
++template<class Archive>
++void ListVal::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:ListVal:%d",__FILE__,__LINE__);
++        // Serialize Val
++        ar & boost::serialization::base_object<Val>(*this);
++
++        ar & vals; 
++        ar & tag;
++    }
++template void ListVal::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void ListVal::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
++BOOST_CLASS_EXPORT_GUID(TableEntryVal,"TableEntryVal")
++template<class Archive>
++void TableEntryVal::serialize(Archive & ar, const unsigned int version)
++    {
++        ar & val;
++        ar & last_access_time;
++        ar & expire_access_time;
++        ar & last_read_update;
++    }
++template void TableEntryVal::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void TableEntryVal::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+ TableValTimer::TableValTimer(TableVal* val, double t) : Timer(t, TIMER_TABLE_VAL)
+ 	{
+ 	table = val;
+@@ -1353,6 +1634,7 @@
+ 
+ 	table_hash = new CompositeHash(table_type->Indices());
+ 	val.table_val = new PDict(TableEntryVal);
++    val_type = BROVALUNION_TABLE;
+ 	val.table_val->SetDeleteFunc(table_entry_val_delete_func);
+ 	}
+ 
+@@ -1375,6 +1657,7 @@
+ 	// Here we take the brute force approach.
+ 	delete AsTable();
+ 	val.table_val = new PDict(TableEntryVal);
++    val_type = BROVALUNION_TABLE;
+ 	val.table_val->SetDeleteFunc(table_entry_val_delete_func);
+ 	}
+ 
+@@ -2547,11 +2830,41 @@
+ 		+ table_hash->MemoryAllocation();
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(TableVal,"TableVal")
++template<class Archive>
++void TableVal::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:TableVal:%d",__FILE__,__LINE__);
++        // Serialize MutableVal
++        ar & boost::serialization::base_object<MutableVal>(*this);
++
++        ar & table_type;
++        ar & table_hash;
++        ar & attrs;
++        ar & expire_time;
++        //ar & expire_expr; //FIXME
++        if (Archive::is_loading::value) { expire_expr = NULL; } //TMPHACK
++        //ar & timer; //FIXME
++        if (Archive::is_loading::value) { timer = NULL; } //TMPHACK
++        //ar & expire_cookie; //FIXME
++        if (Archive::is_loading::value) { expire_cookie = NULL; } //TMPHACK
++        //ar & subnets; //FIXME
++        if (Archive::is_loading::value) { subnets = NULL; } //TMPHACK
++        ar & def_val;
++    }
++template void TableVal::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void TableVal::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ RecordVal::RecordVal(RecordType* t) : MutableVal(t)
+ 	{
+ 	record_type = t;
+ 	int n = record_type->NumFields();
+ 	val_list* vl = val.val_list_val = new val_list(n);
++    val_type = BROVALUNION_LIST;
+ 
+ 	// Initialize to default values from RecordType (which are nil
+ 	// by default).
+@@ -2815,10 +3128,12 @@
+ 	if ( ! UNSERIALIZE(&len) )
+ 		{
+ 		val.val_list_val = new val_list;
++        val_type = BROVALUNION_LIST;
+ 		return false;
+ 		}
+ 
+ 	val.val_list_val = new val_list(len);
++    val_type = BROVALUNION_LIST;
+ 
+ 	for ( int i = 0; i < len; ++i )
+ 		{
+@@ -2881,6 +3196,25 @@
+ 	return size + padded_sizeof(*this) + val.val_list_val->MemoryAllocation();
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(RecordVal,"RecordVal")
++template<class Archive>
++void RecordVal::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:RecordVal:%d",__FILE__,__LINE__);
++        // Serialize MutableVal
++        ar & boost::serialization::base_object<MutableVal>(*this);
++
++        ar & record_type;
++//        ar & origin; //REINCLUDE
++        if (Archive::is_loading::value) { origin = NULL; } //TMPHACK
++    }
++template void RecordVal::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void RecordVal::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ void EnumVal::ValDescribe(ODesc* d) const
+ 	{
+ 	const char* ename = type->AsEnumType()->Lookup(val.int_val);
+@@ -2905,10 +3239,26 @@
+ 	return true;
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(EnumVal,"EnumVal")
++template<class Archive>
++void EnumVal::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:EnumVal:%d",__FILE__,__LINE__);
++        // Serialize Val
++        ar & boost::serialization::base_object<Val>(*this);
++    }
++template void EnumVal::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void EnumVal::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
++
+ VectorVal::VectorVal(VectorType* t) : MutableVal(t)
+ 	{
+ 	vector_type = t->Ref()->AsVectorType();
+ 	val.vector_val = new vector<Val*>();
++    val_type = BROVALUNION_VECTOR;
+ 	}
+ 
+ VectorVal::~VectorVal()
+@@ -3079,6 +3429,7 @@
+ 	DO_UNSERIALIZE(MutableVal);
+ 
+ 	val.vector_val = new vector<Val*>;
++    val_type = BROVALUNION_VECTOR;
+ 	vector_type = type->Ref()->AsVectorType();
+ 
+ 	int len;
+@@ -3114,6 +3465,22 @@
+ 	d->Add("]");
+ 	}
+ 
++BOOST_CLASS_EXPORT_GUID(VectorVal,"VectorVal")
++template<class Archive>
++void VectorVal::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:VectorVal:%d",__FILE__,__LINE__);
++        // Serialize Val
++        ar & boost::serialization::base_object<Val>(*this);
++
++        ar & vector_type;
++    }
++template void VectorVal::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void VectorVal::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+ 
+ Val* check_and_promote(Val* v, const BroType* t, int is_init)
+ 	{
+diff -urN bro-2.1/src/Val.h bro-2.1-sdmbn/src/Val.h
+--- bro-2.1/src/Val.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/Val.h	2014-02-17 17:20:07.000000003 -0600
+@@ -19,6 +19,7 @@
+ #include "Scope.h"
+ #include "StateAccess.h"
+ #include "IPAddr.h"
++#include <boost/serialization/access.hpp>
+ 
+ class Val;
+ class Func;
+@@ -47,6 +48,21 @@
+ class TableEntryVal;
+ declare(PDict,TableEntryVal);
+ 
++typedef enum {
++    BROVALUNION_INT,
++    BROVALUNION_UINT,
++    BROVALUNION_ADDR,
++    BROVALUNION_SUBNET,
++    BROVALUNION_DOUBLE,
++    BROVALUNION_STRING,
++    BROVALUNION_FUNC,
++    BROVALUNION_FILE,
++    BROVALUNION_RE,
++    BROVALUNION_TABLE,
++    BROVALUNION_LIST,
++    BROVALUNION_VECTOR
++} BroValUnionType;
++
+ typedef union {
+ 	// Used for bool, int, enum.
+ 	bro_int_t int_val;
+@@ -79,6 +95,7 @@
+ 	Val(bool b, TypeTag t)
+ 		{
+ 		val.int_val = b;
++        val_type = BROVALUNION_INT;
+ 		type = base_type(t);
+ 		attribs = 0;
+ #ifdef DEBUG
+@@ -89,6 +106,7 @@
+ 	Val(int32 i, TypeTag t)
+ 		{
+ 		val.int_val = bro_int_t(i);
++        val_type = BROVALUNION_INT;
+ 		type = base_type(t);
+ 		attribs = 0;
+ #ifdef DEBUG
+@@ -99,6 +117,7 @@
+ 	Val(uint32 u, TypeTag t)
+ 		{
+ 		val.uint_val = bro_uint_t(u);
++        val_type = BROVALUNION_UINT;
+ 		type = base_type(t);
+ 		attribs = 0;
+ #ifdef DEBUG
+@@ -109,6 +128,7 @@
+ 	Val(int64 i, TypeTag t)
+ 		{
+ 		val.int_val = i;
++        val_type = BROVALUNION_INT;
+ 		type = base_type(t);
+ 		attribs = 0;
+ #ifdef DEBUG
+@@ -119,6 +139,7 @@
+ 	Val(uint64 u, TypeTag t)
+ 		{
+ 		val.uint_val = u;
++        val_type = BROVALUNION_UINT;
+ 		type = base_type(t);
+ 		attribs = 0;
+ #ifdef DEBUG
+@@ -129,6 +150,7 @@
+ 	Val(double d, TypeTag t)
+ 		{
+ 		val.double_val = d;
++        val_type = BROVALUNION_DOUBLE;
+ 		type = base_type(t);
+ 		attribs = 0;
+ #ifdef DEBUG
+@@ -154,6 +176,7 @@
+ 	Val()
+ 		{
+ 		val.int_val = 0;
++        val_type = BROVALUNION_INT;
+ 		type = base_type(TYPE_ERROR);
+ 		attribs = 0;
+ #ifdef DEBUG
+@@ -363,6 +386,7 @@
+ 	Val(BroString* s, TypeTag t)
+ 		{
+ 		val.string_val = s;
++        val_type = BROVALUNION_STRING;
+ 		type = base_type(t);
+ 		attribs = 0;
+ #ifdef DEBUG
+@@ -399,6 +423,7 @@
+ 			const BroType* exact_type);
+ 
+ 	BroValUnion val;
++    BroValUnionType val_type;
+ 	BroType* type;
+ 	RecordVal* attribs;
+ 
+@@ -407,6 +432,9 @@
+ 	const char* bound_id;
+ #endif
+ 
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class MutableVal : public Val {
+@@ -483,6 +511,10 @@
+ 	list<ID*> aliases;
+ 	Properties props;
+ 	uint64 last_modified;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ #define Microseconds 1e-6
+@@ -502,6 +534,10 @@
+ 	void ValDescribe(ODesc* d) const;
+ 
+ 	DECLARE_SERIAL(IntervalVal);
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ 
+@@ -550,6 +586,10 @@
+ 	void ValDescribe(ODesc* d) const;
+ 
+ 	DECLARE_SERIAL(PortVal);
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class AddrVal : public Val {
+@@ -573,6 +613,10 @@
+ 	AddrVal(BroType* t) : Val(t)	{ }
+ 
+ 	DECLARE_SERIAL(AddrVal);
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class SubNetVal : public Val {
+@@ -602,6 +646,10 @@
+ 	void ValDescribe(ODesc* d) const;
+ 
+ 	DECLARE_SERIAL(SubNetVal);
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class StringVal : public Val {
+@@ -633,6 +681,10 @@
+ 	void ValDescribe(ODesc* d) const;
+ 
+ 	DECLARE_SERIAL(StringVal);
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class PatternVal : public Val {
+@@ -653,6 +705,10 @@
+ 	void ValDescribe(ODesc* d) const;
+ 
+ 	DECLARE_SERIAL(PatternVal);
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class ListVal : public Val {
+@@ -705,6 +761,10 @@
+ 
+ 	val_list vals;
+ 	TypeTag tag;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ extern double bro_start_network_time;
+@@ -748,6 +808,12 @@
+ 	// for these anyway.
+ 	int expire_access_time;
+ 	int last_read_update;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++    
++    TableEntryVal() {}; // Dummy default constructor for serialization
+ };
+ 
+ class TableValTimer : public Timer {
+@@ -880,6 +946,10 @@
+ 	IterCookie* expire_cookie;
+ 	PrefixTable* subnets;
+ 	Val* def_val;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class RecordVal : public MutableVal {
+@@ -929,6 +999,10 @@
+ 
+ 	RecordType* record_type;
+ 	BroObj* origin;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ class EnumVal : public Val {
+@@ -949,6 +1023,10 @@
+ 	void ValDescribe(ODesc* d) const;
+ 
+ 	DECLARE_SERIAL(EnumVal);
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ 
+@@ -1011,6 +1089,10 @@
+ 	DECLARE_SERIAL(VectorVal);
+ 
+ 	VectorType* vector_type;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
+ };
+ 
+ 
+diff -urN bro-2.1/src/ZIP.cc bro-2.1-sdmbn/src/ZIP.cc
+--- bro-2.1/src/ZIP.cc	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/ZIP.cc	2014-02-17 17:20:07.000000003 -0600
+@@ -1,6 +1,10 @@
+ // See the file "COPYING" in the main distribution directory for copyright.
+ 
+ #include "ZIP.h"
++#include <boost/archive/text_oarchive.hpp>
++#include <boost/archive/text_iarchive.hpp>
++#include <boost/serialization/export.hpp>
++#include "SDMBNlocal.h"
+ 
+ ZIP_Analyzer::ZIP_Analyzer(Connection* conn, bool orig, Method arg_method)
+ : TCP_SupportAnalyzer(AnalyzerTag::Zip, conn, orig)
+@@ -87,3 +91,51 @@
+ 		}
+ 	while ( zip->avail_out == 0 );
+ 	}
++
++BOOST_CLASS_EXPORT_GUID(ZIP_Analyzer,"ZIP_Analyzer")
++template<class Archive>
++void ZIP_Analyzer::serialize(Archive & ar, const unsigned int version)
++    {
++        SERIALIZE_PRINT("%s:ZIP_Analzyer:%d\n",__FILE__,__LINE__);
++        // Serialize TCP_SupportAnalyzer 
++        ar & boost::serialization::base_object<TCP_SupportAnalyzer>(*this);
++
++        //ar & zip; //FIXME
++//        int zipnull;
++//        if (!Archive::is_loading::value)
++//        {
++//            if (NULL == zip)
++//            { zipnull = 1; }
++//            else
++//            { zipnull = 0; }
++//        }
++//        ar & zipnull;
++//        if (!zipnull)
++//        {
++//            //ar & zip->next_in; //FIXME
++//            ar & zip->avail_in;
++//            ar & zip->total_in;
++//            //ar & zip->next_out; //FIXME
++//            ar & zip->avail_out;
++//            ar & zip->total_out;
++//            //ar & zip->msg; //FIXME
++//            //ar & zip->state; //FIXME
++//            //zalloc, zfree, and opaque are always null? //FIXME
++//            ar & zip->data_type;
++//            ar & zip->adler;
++//            ar & zip->reserved;
++//        }
++//        else
++//        { zip = NULL; }
++//
++        if (Archive::is_loading::value) { zip = NULL; } //TMPHACK
++        ar & zip_status;
++        if (Archive::is_loading::value) { zip_status = Z_BUF_ERROR; } //TMPHACK
++        ar & method;
++    }
++template void ZIP_Analyzer::serialize<boost::archive::text_oarchive>(
++        boost::archive::text_oarchive & ar, 
++        const unsigned int file_version);
++template void ZIP_Analyzer::serialize<boost::archive::text_iarchive>(
++        boost::archive::text_iarchive & ar, 
++        const unsigned int file_version);
+diff -urN bro-2.1/src/ZIP.h bro-2.1-sdmbn/src/ZIP.h
+--- bro-2.1/src/ZIP.h	2012-08-29 10:44:07.000000003 -0500
++++ bro-2.1-sdmbn/src/ZIP.h	2014-02-17 17:20:07.000000003 -0600
+@@ -7,6 +7,7 @@
+ 
+ #include "zlib.h"
+ #include "TCP.h"
++#include <boost/serialization/access.hpp>
+ 
+ class ZIP_Analyzer : public TCP_SupportAnalyzer {
+ public:
+@@ -24,6 +25,12 @@
+ 	z_stream* zip;
+ 	int zip_status;
+ 	Method method;
++
++    friend class boost::serialization::access;
++    template<class Archive>
++    void serialize(Archive & ar, const unsigned int version);
++
++    ZIP_Analyzer() {}; // Dummy default constructor for serialization
+ };
+ 
+ #endif
+diff -urN bro-2.1/wisconsin_build.sh bro-2.1-sdmbn/wisconsin_build.sh
+--- bro-2.1/wisconsin_build.sh	1969-12-31 18:00:00.000000000 -0600
++++ bro-2.1-sdmbn/wisconsin_build.sh	2014-04-15 13:53:57.000000003 -0500
+@@ -0,0 +1,13 @@
++#!/bin/bash
++
++BASEDIR="/scratch/${USER}/tools"
++export CFLAGS="-I${BASEDIR}/json-c/include/ -I${BASEDIR}/sdmbn/include/ -g"
++export CXXFLAGS="-I${BASEDIR}/json-c/include/ -I${BASEDIR}/sdmbn/include/ -g"
++export LDFLAGS="-L${BASEDIR}/json-c/lib/ -L${BASEDIR}/sdmbn/lib/ -L/usr/local/lib/ -lsdmbn -ljson-c -lboost_serialization"
++
++export LD_LIBRARY_PATH="${BASEDIR}/json-c/lib:${BASEDIR}/sdmbn/lib" 
++
++./configure --prefix=${BASEDIR}/bro-sdmbn 
++sed -e 's/-lsdmbn -ljson-c -lboost_serialization//' -i build/src/CMakeFiles/bro.dir/link.txt
++sed -e 's/-lcrypto/-lcrypto -lsdmbn -ljson-c -lboost_serialization/' -i build/src/CMakeFiles/bro.dir/link.txt
++make install
diff --git a/conn.log b/conn.log
new file mode 100644
index 0000000..ade86a6
--- /dev/null
+++ b/conn.log
@@ -0,0 +1,543 @@
+#separator \x09
+#set_separator	,
+#empty_field	(empty)
+#unset_field	-
+#path	conn
+#open	2020-12-19-19-10-32
+#fields	ts	uid	id.orig_h	id.orig_p	id.resp_h	id.resp_p	proto	service	duration	orig_bytes	resp_bytes	conn_state	local_orig	missed_bytes	history	orig_pkts	orig_ip_bytes	resp_pkts	resp_ip_bytes	tunnel_parents
+#types	time	string	addr	port	addr	port	enum	string	interval	count	count	string	bool	count	string	count	count	count	count	table[string]
+1608401432.884181	mnH4Z46y4Pa	192.168.5.164	42080	34.213.232.200	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401435.549320	DTfmqv6q7Ef	192.168.5.164	49310	172.217.21.238	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401432.958169	9XlIMPF5QNa	7078:7d02:0:0:e00::	24757	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401439.733242	qNo9lWlx51h	192.168.5.164	46473	173.194.188.134	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401439.764046	sV5gldO2PH9	192.168.5.164	46474	173.194.188.134	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401439.802053	tojONienEx1	192.168.5.164	57526	172.217.18.161	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401439.833640	YufAB2MN1Q9	192.168.5.164	60003	74.125.173.202	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401439.857692	5xWsLyJ26A1	192.168.5.164	60833	172.217.23.162	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401439.874037	lPA5Nz0jJO3	192.168.5.164	39979	74.125.13.142	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401440.152433	ettXeuiLvz6	192.168.5.164	53944	172.217.16.142	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401435.585716	XC03QZRkDje	7078:7d02:0:0:e00::	16426	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401441.117245	jvCrN1fp674	192.168.5.164	53970	74.125.11.104	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.284022	6eKC0FK45N6	192.168.5.164	56873	173.194.188.231	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.290075	SD9ikhr8Oil	192.168.5.164	56874	173.194.188.231	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.317211	HUythVC8x7d	192.168.5.164	46710	172.217.16.130	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.325612	OKQlYHD6TBl	192.168.5.164	56733	173.194.188.103	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.340015	fXYYKU6Fokd	192.168.5.164	40228	172.217.22.3	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.352407	RVviofhPXZj	192.168.5.164	56735	173.194.188.103	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.455609	al07fkzx2Gb	192.168.5.164	49138	173.194.182.231	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.463211	lU6EdION3dk	192.168.5.164	49139	173.194.182.231	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.549617	0Jnx87FCTYb	192.168.5.164	53698	173.194.151.89	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.557216	mBiwcIFtTc5	192.168.5.164	53699	173.194.151.89	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.614806	raH28tOaGV7	192.168.5.164	54224	172.217.16.178	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.615205	0sFZcDj5864	192.168.5.164	48425	172.217.23.178	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.729606	5uU5c6ECUd8	192.168.5.164	51025	173.194.182.232	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.748403	rZd9TYLzYo8	192.168.5.164	51026	173.194.182.232	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.774017	4PLslP8C96	192.168.5.164	42508	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.780407	R7QXqaVkcr8	192.168.5.164	42509	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.796408	utLPCypQAe	192.168.5.164	42510	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.799604	wBWRBWWidAf	192.168.5.164	57549	172.217.18.161	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.814401	1UsymF4ubki	192.168.5.164	42512	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.822401	w2OgQMdW8Df	192.168.5.164	42513	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.846406	vY1TixdVUri	192.168.5.164	42514	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.851202	2Ybnsqa05Hd	192.168.5.164	60431	173.194.187.42	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401442.351189	nJ1TiywCMVl	192.168.5.164	43571	172.217.18.2	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401442.352397	aqyAf3H8n4c	192.168.5.164	43572	172.217.18.2	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401442.469588	gG5M1RsAG75	192.168.5.164	43576	172.217.18.2	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401442.469186	JW9RjCtxIv6	192.168.5.164	43575	172.217.18.2	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401442.468388	pB99KPVA4Il	192.168.5.164	42518	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401442.468787	RPYvZIfcfQ7	192.168.5.164	42519	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401443.405167	6d7f0XL5Nu3	192.168.5.164	46509	173.194.188.134	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401443.451169	WfQ4KJGMJW1	192.168.5.164	46510	173.194.188.134	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401443.483170	ljvItEgSX9a	192.168.5.164	46511	173.194.188.134	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401443.483569	mXpNQmUmuu	192.168.5.164	46512	173.194.188.134	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401443.699968	9ahMmiHW27a	192.168.5.164	49351	172.217.21.238	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401431.871079	kikzvx6kOu5	192.168.5.164	38408	173.194.188.9	443	tcp	-	7.763761	32	30445327	RSTRH	-	0	CdAar	1	40	25	20701	(empty)
+1608401433.261419	DNPzLc9Ldqh	192.168.5.164	58014	35.177.144.113	443	tcp	-	6.402220	0	31	SHR	-	0	CadfA	1	40	6	271	(empty)
+1608401433.323770	JPbFNDeRHKi	192.168.5.164	41740	18.233.201.37	443	tcp	-	6.343879	0	31	SHR	-	0	CadfA	1	40	6	271	(empty)
+1608401433.513414	VdFJTVB7jW6	192.168.5.164	36817	35.178.221.242	443	tcp	-	6.159026	0	31	SHR	-	0	CadfA	1	40	6	271	(empty)
+1608401433.511016	RCtVDHHwAUj	192.168.5.164	42684	35.178.3.188	443	tcp	-	6.169424	0	31	SHR	-	0	CadfA	1	40	6	271	(empty)
+1608401439.734039	GTeppzNnin8	7078:7d02:0:0:e00::	53267	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401432.491791	Qu6vbsmRcph	192.168.5.164	38539	23.42.150.222	443	tcp	-	7.273044	0	3066	RSTOS0	-	0	CadR	1	40	40	4666	(empty)
+1608401432.494577	JtUwPrPtdc1	192.168.5.164	38548	23.42.150.222	443	tcp	-	7.271061	0	438	RSTOS0	-	0	CadR	1	40	9	798	(empty)
+1608401433.039767	6n2qFphoDd1	192.168.5.164	43538	172.217.18.2	443	tcp	-	6.727485	0	1186	RSTOS0	-	0	CadR	1	40	9	1546	(empty)
+1608401433.395817	6lpMtlSgAnb	192.168.5.164	60772	172.217.23.162	443	tcp	-	6.374223	0	1250	RSTOS0	-	0	CadR	1	40	14	1810	(empty)
+1608401439.768038	7Wod8KtgQ7	7078:7d02:0:0:e00::	12311	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401439.810837	a0XnG65Gdq8	7078:7d02:0:0:e00::	49353	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401439.834837	BA1p59Nmzf	7078:7d02:0:0:e00::	49353	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401439.864436	Xpxx1lLpxe5	7078:7d02:0:0:e00::	41092	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401439.874437	sRShGSiq2U7	7078:7d02:0:0:e00::	41092	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401440.192838	fAEeuNb5Dr5	7078:7d02:0:0:e00::	41092	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401445.171144	fMSEHFGyLJg	192.168.5.164	56707	173.194.188.232	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401445.712326	LcMeabqDb1i	192.168.5.164	33881	216.58.207.78	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401445.824765	qhu2FA1LDcf	192.168.5.164	42529	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401445.825592	k7GJ916T4Ig	192.168.5.164	42531	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401445.825154	Ku041FbG9Sd	192.168.5.164	42530	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401445.826324	n9xJ4elZ2Wd	192.168.5.164	42533	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401445.825951	wQtRc0NxB2i	192.168.5.164	42532	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401445.979927	XlpLhFTZpY1	192.168.5.164	36950	172.217.16.162	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401446.013522	zmWGDx7izy	192.168.5.164	36951	172.217.16.162	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.140839	a5wqZbrcTc8	7078:7d02:0:0:e00::	49353	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401441.284441	MtqemNg2kYj	7078:7d02:0:0:e00::	8261	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401441.290465	nruWz6arGHb	7078:7d02:0:0:e00::	8261	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401441.320809	wgpX0F6q2ck	7078:7d02:0:0:e00::	8261	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401441.330008	hL4B2OSzUZb	7078:7d02:0:0:e00::	8261	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401441.342013	1c7rrpmuukl	7078:7d02:0:0:e00::	8261	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401441.359216	Giz5skfEQ5d	7078:7d02:0:0:e00::	8261	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401446.433130	hf3aUgQGZP1	192.168.5.164	56772	173.194.188.103	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.456005	h5uYauqVRCl	7078:7d02:0:0:e00::	57543	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401441.465207	MAA8rEGiqjd	7078:7d02:0:0:e00::	57543	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401446.465513	6jMlkc5p46a	192.168.5.164	32975	172.217.18.109	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401432.852972	LCq7SfBTsE2	192.168.5.164	46760	91.189.89.88	80	tcp	-	8.645434	0	0	SHR	-	0	CafA	1	40	8	320	(empty)
+1608401432.968576	5sgzeK3Y1o9	192.168.5.164	36308	23.15.38.145	80	tcp	-	8.544231	0	0	SHR	-	0	CafA	1	40	8	320	(empty)
+1608401446.515120	AOhAAf8A4u6	192.168.5.164	54826	172.217.16.131	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401446.516328	gtAUVMBGyO7	192.168.5.164	54827	172.217.16.131	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401446.527116	HX9jsf8Vm95	192.168.5.164	33893	216.58.207.78	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401446.530322	GSGubf89Rb6	192.168.5.164	54829	172.217.16.131	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401446.530751	qNx5gDlPHB7	192.168.5.164	54830	172.217.16.131	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401441.550809	aiKDO78M2N3	7078:7d02:0:0:e00::	57543	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401441.558462	vJFZfKI4cB6	7078:7d02:0:0:e00::	57543	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401432.488177	7WpfT6NuHUf	192.168.5.164	41020	172.217.23.142	443	tcp	-	9.123848	0	521998	RSTOS0	-	0	CadR	1	40	138	72572	(empty)
+1608401441.617206	T6Ylyh2W3O6	7078:7d02:0:0:e00::	37104	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401441.615604	UZSmPYsaCq5	7078:7d02:0:0:e00::	12420	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401446.593121	0tJ46IY2Czk	192.168.5.164	33896	216.58.207.78	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401446.593519	xcdOt7vCSpd	192.168.5.164	33897	216.58.207.78	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401432.492184	JkO8Qv8Fe2g	192.168.5.164	41019	172.217.23.142	443	tcp	-	9.154619	0	28384	RSTOS0	-	0	CadR	1	40	45	18154	(empty)
+1608401439.284462	kfVhmDSdWqi	192.168.5.164	42080	34.213.232.200	443	tcp	-	2.364740	0	31	SHR	-	0	CadfA	1	40	7	311	(empty)
+1608401432.489777	YR0ZNanwJJi	192.168.5.164	41021	172.217.23.142	443	tcp	-	9.172225	0	42897	RSTOS0	-	0	CadR	1	40	36	13505	(empty)
+1608401432.485774	AK02OB6WCGi	192.168.5.164	41018	172.217.23.142	443	tcp	-	9.191037	0	2014	RSTOS0	-	0	CadR	1	40	23	2934	(empty)
+1608401441.732429	bGwBelRFsJ9	7078:7d02:0:0:e00::	184	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401441.755606	ezSV0OGj0w1	7078:7d02:0:0:e00::	8373	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401441.778000	ZAYTQLw13R9	7078:7d02:0:0:e00::	8373	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401441.785600	eCC0e9zV4z1	7078:7d02:0:0:e00::	8249	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401432.486175	CmaxzKpOOgh	192.168.5.164	53894	172.217.16.142	443	tcp	-	9.308226	0	24139	RSTOS0	-	0	CadR	1	40	27	11331	(empty)
+1608401441.797216	cqhXZihcpae	7078:7d02:0:0:e00::	8249	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401441.800000	VH8mX6ZOEZg	7078:7d02:0:0:e00::	8249	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401441.814797	O0rRGscgCie	7078:7d02:0:0:e00::	8249	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401441.824800	LNZmrwBN62h	7078:7d02:0:0:e00::	8249	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401441.850398	Gf2Hbbjiehc	7078:7d02:0:0:e00::	8249	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401441.853205	vig2ZL7wiBk	7078:7d02:0:0:e00::	8249	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401442.378383	9mfK3GDUdik	7078:7d02:0:0:e00::	8391	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401442.376785	2fcHulxdRod	7078:7d02:0:0:e00::	8249	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401442.493184	PhZOqawaGC7	7078:7d02:0:0:e00::	57378	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401442.491632	QNmVLv6uSH3	7078:7d02:0:0:e00::	12349	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401442.498385	ZldUAJA2Sc6	7078:7d02:0:0:e00::	8391	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401442.499186	U7gRKx6MjP4	7078:7d02:0:0:e00::	53453	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401448.172281	yyshEHWCNc2	192.168.5.164	35745	172.217.23.163	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401448.307145	6tLU0NjC4Ze	192.168.5.164	32984	172.217.18.109	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401448.373478	zAj5KfQf9Jh	192.168.5.164	40571	216.58.210.4	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401448.374676	omDgr9fhlhg	192.168.5.164	40572	216.58.210.4	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401443.410369	G2Kuv9kGVw	7078:7d02:0:0:e00::	20684	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401443.458769	f1XM1LudrP8	7078:7d02:0:0:e00::	20684	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401443.496823	83RVSlf31P1	7078:7d02:0:0:e00::	53453	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401443.497625	tFGn3eMOeH8	7078:7d02:0:0:e00::	24736	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401432.616178	IWxHrdCulm9	192.168.5.164	45988	216.58.205.227	80	tcp	-	11.093382	0	0	SHR	-	0	CafA	1	40	10	400	(empty)
+1608401443.734821	XvQLVG5Ff4i	7078:7d02:0:0:e00::	24736	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401448.779470	XgknCtgKVwj	192.168.5.164	49518	172.217.18.174	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401449.726252	AXI5R1mVZZa	192.168.5.164	55978	172.217.18.3	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401449.922666	23pLwaqlzJ4	192.168.5.164	42551	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401449.963049	DWTmCEKTrx7	192.168.5.164	51550	216.58.210.3	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401433.521385	57WLGIMZTBf	192.168.5.164	34317	172.217.18.4	443	tcp	-	11.516552	0	0	SHR	-	0	CafA	1	40	11	440	(empty)
+1608401433.524162	0J1fvQqe1Yg	192.168.5.164	41044	172.217.23.142	443	tcp	-	11.517781	0	0	SHR	-	0	CafA	1	40	11	440	(empty)
+1608401431.891421	to48ysyTP94	192.168.5.164	43121	74.125.206.157	443	tcp	-	13.155316	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401450.059452	4LvxDP6hww4	192.168.5.164	59090	216.58.205.234	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401445.201535	k9k4Sbuwdkf	7078:7d02:0:0:e00::	24727	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401450.228650	ziYQKvCs4U5	192.168.5.164	37498	172.217.22.78	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401450.417442	D70IHBz2gL4	192.168.5.164	55983	172.217.18.3	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401450.417839	AEEf76BCX56	192.168.5.164	55984	172.217.18.3	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401450.419045	wF6XJmBKLv7	192.168.5.164	55985	172.217.18.3	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401432.451382	nkbzi6WyKJc	192.168.5.164	43488	172.217.18.2	443	tcp	-	13.187744	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401445.736726	xIBH7D7XkBg	7078:7d02:0:0:e00::	16387	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401445.848778	dZSriJM5Rlf	7078:7d02:0:0:e00::	16387	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401445.851928	A17nEm0Aa0i	7078:7d02:0:0:e00::	246	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401445.853578	zd4ztwx2Fdf	7078:7d02:0:0:e00::	61642	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401445.852726	BBmeQrhm8Td	7078:7d02:0:0:e00::	12342	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401445.851139	iRfQln0smAg	7078:7d02:0:0:e00::	20595	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401446.021118	KklmXRafh8a	7078:7d02:0:0:e00::	53433	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401446.060343	kMfzFVG8NN8	7078:7d02:0:0:e00::	28825	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401432.884577	SlVcOuZM3v2	192.168.5.164	55374	216.58.206.2	443	tcp	-	13.238995	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401432.869771	sBrblSVrAu9	192.168.5.164	41699	216.58.206.6	443	tcp	-	13.254559	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401451.121835	uxMYwDmRzd7	192.168.5.164	33911	216.58.207.78	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401432.903777	qAAqlfY6xa1	192.168.5.164	55373	216.58.206.2	443	tcp	-	13.338993	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401433.047370	XrKn0Hnu5Qa	192.168.5.164	55351	216.58.206.2	443	tcp	-	13.196151	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401433.349412	kw0FiXMOf1g	192.168.5.164	55388	216.58.206.2	443	tcp	-	13.001703	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401433.211366	i7CKZ6h5xye	192.168.5.164	59834	93.184.220.29	80	tcp	-	13.140548	0	0	SHR	-	0	CafA	1	40	11	440	(empty)
+1608401433.475785	rFbs6VG822l	192.168.5.164	41025	216.58.206.14	443	tcp	-	12.876929	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401433.333422	s3WOj3f7pBe	192.168.5.164	38530	23.42.150.222	443	tcp	-	13.022103	0	31	RSTO	-	0	CadRf	2	80	13	551	(empty)
+1608401433.221366	OiUChMqa1Tf	192.168.5.164	43517	172.217.18.166	443	tcp	-	13.135352	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401433.199368	rRWUMY2sjIi	192.168.5.164	36861	172.217.16.162	443	tcp	-	13.158148	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401433.387754	akYApC1m4Ic	192.168.5.164	58513	172.217.21.194	443	tcp	-	12.970599	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401446.446314	ZIsvcqVBvv	7078:7d02:0:0:e00::	41098	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401433.509384	Ku2vvu0p6Bb	192.168.5.164	43530	172.217.18.166	443	tcp	-	12.965755	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401433.518176	Fv0ALbpSFO5	192.168.5.164	43529	172.217.18.166	443	tcp	-	12.957745	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401433.511812	jT7bDe00vw5	192.168.5.164	35541	216.58.208.42	443	tcp	-	12.965700	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401433.514211	4BxoZEUDFN2	192.168.5.164	37420	172.217.22.78	443	tcp	-	12.966902	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401433.517776	enBLYgWjc84	192.168.5.164	43522	172.217.18.166	443	tcp	-	12.964137	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401433.508598	iHr9A9y6X0d	192.168.5.164	41027	216.58.206.14	443	tcp	-	12.974516	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401446.487114	OudaLyRIdG8	7078:7d02:0:0:e00::	41098	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401446.531989	LR95jBexOv3	7078:7d02:0:0:e00::	41098	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401446.532714	lPjFzE9CiQ4	7078:7d02:0:0:e00::	16483	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401446.541970	be8C2xULIId	7078:7d02:0:0:e00::	45067	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401446.545111	1aAKGqtFUic	7078:7d02:0:0:e00::	4325	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401446.545911	AYbo53GH8Ul	7078:7d02:0:0:e00::	37119	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401446.620317	gFjipuYE3Hl	7078:7d02:0:0:e00::	16638	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401446.619523	bApxpifWl5c	7078:7d02:0:0:e00::	61509	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401433.520977	CMAziXO1er4	192.168.5.164	37421	172.217.22.78	443	tcp	-	13.145731	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401451.942214	VPvPwexcmEc	192.168.5.164	40146	172.217.16.161	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401432.549776	9u7dJS3zHw2	192.168.5.164	36860	172.217.16.162	443	tcp	-	14.698522	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401448.172679	6wLlmHEiBjg	7078:7d02:0:0:e00::	12348	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401448.340743	5cmbKoLnX8j	7078:7d02:0:0:e00::	45243	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401448.397876	QRu3wuSaxRe	7078:7d02:0:0:e00::	12348	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401448.398674	FLL7M463z0j	7078:7d02:0:0:e00::	20524	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401448.815079	1IsJLPbSJWk	7078:7d02:0:0:e00::	8276	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401454.422964	l84uiQ2cTg2	192.168.5.164	41816	216.58.206.6	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401449.739451	EWAaqiI1Opc	7078:7d02:0:0:e00::	32968	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401449.962248	y8CqYWzg5p3	7078:7d02:0:0:e00::	32968	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401449.998650	3R9cfqsdB76	7078:7d02:0:0:e00::	24643	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401450.091493	UuHiGvfzF63	7078:7d02:0:0:e00::	24643	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401450.242647	Fp3dkRjmJq3	7078:7d02:0:0:e00::	16435	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401450.433837	fGU2ciFKux4	7078:7d02:0:0:e00::	37110	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401450.433039	h4IC97eEG73	7078:7d02:0:0:e00::	41000	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401450.436247	EvXdenFc3T5	7078:7d02:0:0:e00::	36897	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401451.153427	I2ElIEPe6Vk	7078:7d02:0:0:e00::	57382	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401456.701334	L0IL9VNHvvf	192.168.5.164	55484	216.58.206.2	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401456.725002	mtDDYoOPfei	192.168.5.164	42346	172.217.21.226	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401456.838525	qkMCuHn4rwi	192.168.5.164	49430	172.217.21.202	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401456.840549	0go4jlsWC6h	192.168.5.164	49431	172.217.21.202	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401456.871320	trL3DDA7j	192.168.5.164	57800	100.24.142.9	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401456.878919	IfCjMorBex8	192.168.5.164	38789	52.56.172.244	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401456.871730	fzCDCXrP9q1	192.168.5.164	57801	100.24.142.9	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401456.906919	FsX1FgRRGh5	192.168.5.164	41277	172.217.16.198	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401456.934975	ms983wWjx18	192.168.5.164	38635	23.42.150.222	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401456.938186	oUc76qxd3H6	192.168.5.164	38636	23.42.150.222	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401451.965470	vjHGz6C7Sjb	7078:7d02:0:0:e00::	4299	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401456.966518	ggAAlYbFi98	192.168.5.164	32953	172.217.21.206	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401457.037316	CIy19JK3G4k	192.168.5.164	36470	18.130.64.138	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401457.048115	Z2UENupQYLb	192.168.5.164	45713	172.217.21.195	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401457.048518	hRvFG9MWMbd	192.168.5.164	51788	3.9.227.4	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401457.088915	rAUxc2VOmUb	192.168.5.164	38641	23.42.150.222	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401457.107317	Zy1iKPUwwnl	192.168.5.164	38642	23.42.150.222	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401457.126914	41gv99tBtdd	192.168.5.164	38643	23.42.150.222	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401457.146512	lDUbWM3dLvl	192.168.5.164	38644	23.42.150.222	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401433.025377	eC82Y7XurD2	192.168.5.164	59836	93.184.220.29	80	tcp	-	19.582455	0	788	SHR	-	0	CadfA	1	40	15	1388	(empty)
+1608401452.799795	exSPYlXCj7j	7078:7d02:0:0:e00::	61663	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401454.463365	7gkwYGMvmW	7078:7d02:0:0:e00::	28840	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401456.708178	rTMlyErBH5e	7078:7d02:0:0:e00::	28923	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401456.742924	GC1yEd2bJTg	7078:7d02:0:0:e00::	28923	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401456.786921	bjep84smgJf	192.168.5.164	55985	172.217.18.3	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401433.136565	9vgG3srLsih	192.168.5.164	38546	23.42.150.222	443	tcp	-	23.655956	0	469	RSTOS0	-	0	CadR	1	40	21	1309	(empty)
+1608401432.492983	F9WaR1oyqCe	192.168.5.164	38547	23.42.150.222	443	tcp	-	24.339544	0	469	RSTOS0	-	0	CadR	1	40	21	1309	(empty)
+1608401432.425779	hONkipZSdpb	192.168.5.164	49266	172.217.21.238	443	tcp	-	24.409141	0	34582	SHR	-	0	CadfA	1	40	23	3976	(empty)
+1608401456.844924	g0lRPPUObk8	7078:7d02:0:0:e00::	16441	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401456.850520	gPpOqxjVFE9	7078:7d02:0:0:e00::	41173	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401432.653783	WI7t9Z8bcMa	192.168.5.164	51236	172.217.22.54	443	tcp	-	24.218743	0	5920	SHR	-	0	CadfA	1	40	21	3664	(empty)
+1608401456.881718	0IBGbDJh5X9	7078:7d02:0:0:e00::	41173	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401456.890117	7dV1dSh9cj	7078:7d02:0:0:e00::	4329	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401456.891719	nusaJ58eGD1	7078:7d02:0:0:e00::	24783	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401456.916124	3kRvgj0aQR3	7078:7d02:0:0:e00::	24783	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401456.944918	LMA7GlCgzk5	7078:7d02:0:0:e00::	24783	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401456.947318	xyKajlMb504	7078:7d02:0:0:e00::	37038	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401456.982115	81N12vTYrJ6	7078:7d02:0:0:e00::	4208	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401457.049720	2ncdIVfKV6k	7078:7d02:0:0:e00::	28674	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401457.046515	65AwWxwIcpl	7078:7d02:0:0:e00::	4208	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401457.052117	oNUXF4bSJwl	7078:7d02:0:0:e00::	36902	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401457.094512	5yekAWfvTed	7078:7d02:0:0:e00::	36902	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401457.111368	JNjtbYqq23k	7078:7d02:0:0:e00::	8212	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401457.136541	42qsMWGTCNb	7078:7d02:0:0:e00::	8212	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401457.152512	Num6E4QwU5k	7078:7d02:0:0:e00::	8212	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401432.482577	qbwu1ntqzTj	192.168.5.164	51234	172.217.22.54	443	tcp	-	24.852790	0	18201	SHR	-	0	CadfA	1	40	30	8985	(empty)
+1608401447.215953	ZMlmBbRzvpa	192.168.5.164	40228	172.217.22.3	443	tcp	-	10.201818	0	0	SHR	-	0	CafA	1	40	11	440	(empty)
+1608401432.481379	MCYWj4ivl0l	192.168.5.164	57540	172.217.16.182	443	tcp	-	24.965928	0	18313	SHR	-	0	CadfA	1	40	29	10159	(empty)
+1608401432.489376	RW3uwCQOaAe	192.168.5.164	36839	172.217.16.162	443	tcp	-	25.113185	0	6223	SHR	-	0	CadfA	1	40	37	7703	(empty)
+1608401433.523386	MCJPP7Bkvii	192.168.5.164	45379	216.58.205.226	443	tcp	-	24.101613	0	4731	SHR	-	0	CadfA	1	40	34	6091	(empty)
+1608401433.522577	7lq6qEji3ce	192.168.5.164	55354	216.58.206.2	443	tcp	-	24.103252	0	4751	SHR	-	0	CadfA	1	40	34	6111	(empty)
+1608401432.480977	WgzAEsBnxAj	192.168.5.164	57544	172.217.16.182	443	tcp	-	25.145597	0	33747	SHR	-	0	CadfA	1	40	32	13388	(empty)
+1608401447.131104	pVVxG5st159	192.168.5.164	48425	172.217.23.178	443	tcp	-	10.531005	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401447.129500	uHzwnZkHcf2	192.168.5.164	54224	172.217.16.178	443	tcp	-	10.533403	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401432.364579	XUVcHB0jfs4	192.168.5.164	58738	172.217.22.97	443	tcp	-	25.393523	0	19720	SHR	-	0	CadfA	1	40	48	21640	(empty)
+1608401432.363383	7ijY8hkOlP2	192.168.5.164	58739	172.217.22.97	443	tcp	-	25.395519	0	8481	SHR	-	0	CadfA	1	40	32	9761	(empty)
+1608401432.363778	eXy9tXKtb87	192.168.5.164	58740	172.217.22.97	443	tcp	-	25.428783	0	15374	SHR	-	0	CadfA	1	40	37	12781	(empty)
+1608401433.510214	veFcPlNC4fl	192.168.5.164	45987	216.58.205.227	80	tcp	-	24.283143	0	1402	SHR	-	0	CadfA	1	40	23	2322	(empty)
+1608401432.482979	mK53MGt56el	192.168.5.164	51235	172.217.22.54	443	tcp	-	25.311154	0	51824	SHR	-	0	CadfA	1	40	43	23190	(empty)
+1608401433.520178	UmG9M19Vp13	192.168.5.164	51424	216.58.210.3	443	tcp	-	24.274779	0	3241	SHR	-	0	CadfA	1	40	31	4481	(empty)
+1608401433.498218	tNB9M15sbCj	192.168.5.164	45969	216.58.205.227	80	tcp	-	24.297489	0	1403	SHR	-	0	CadfA	1	40	23	2323	(empty)
+1608401433.519378	zffhvquxc97	192.168.5.164	34312	172.217.18.4	443	tcp	-	24.277123	0	3600	SHR	-	0	CadfA	1	40	31	4840	(empty)
+1608401432.832970	ZMtKU68cCe1	192.168.5.164	45980	216.58.205.227	80	tcp	-	24.964336	0	2103	SHR	-	0	CadfA	1	40	25	3103	(empty)
+1608401446.879505	bNQN5w7dU79	192.168.5.164	57549	172.217.18.161	443	tcp	-	10.978595	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401433.049769	JnSShdiPyv9	192.168.5.164	41710	216.58.206.6	443	tcp	-	24.809131	0	578	SHR	-	0	CadfA	1	40	23	1498	(empty)
+1608401446.525910	Pw2rNLldwJ3	192.168.5.164	60833	172.217.23.162	443	tcp	-	11.932180	0	0	SHR	-	0	CafA	1	40	14	560	(empty)
+1608401448.885522	kMiB3xXsbib	192.168.5.164	43571	172.217.18.2	443	tcp	-	9.574175	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401463.535602	yoLhxacRwT3	192.168.5.164	42579	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401432.481776	HUCWpiHD7Cb	192.168.5.164	58711	172.217.22.97	443	tcp	-	26.075138	0	97125	SHR	-	0	CadfA	1	40	50	26664	(empty)
+1608401432.374585	rZveGRxBo23	192.168.5.164	58721	172.217.22.97	443	tcp	-	26.183132	0	90922	SHR	-	0	CadfA	1	40	46	21738	(empty)
+1608401432.364183	ojcxOoAnHN5	192.168.5.164	58718	172.217.22.97	443	tcp	-	26.194346	0	36416	SHR	-	0	CadfA	1	40	44	17760	(empty)
+1608401432.482178	Foqal8sKV1d	192.168.5.164	51233	172.217.22.54	443	tcp	-	26.077120	0	136383	SHR	-	0	CadfA	1	40	59	36920	(empty)
+1608401446.891925	yE3V2ZuCIU	192.168.5.164	42513	172.217.22.46	443	tcp	-	11.668166	0	0	SHR	-	0	CafA	1	40	14	560	(empty)
+1608401449.224275	Yf6Muci9ICc	192.168.5.164	43572	172.217.18.2	443	tcp	-	9.336615	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401449.255064	pYYeJyPNajj	192.168.5.164	42518	172.217.22.46	443	tcp	-	9.306626	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401446.704708	EuHmtiYwfhk	192.168.5.164	46710	172.217.16.130	443	tcp	-	11.857783	0	0	SHR	-	0	CafA	1	40	14	560	(empty)
+1608401449.255884	PGDF5KBsHDk	192.168.5.164	42519	172.217.22.46	443	tcp	-	9.307412	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401463.543279	5oNrayq4nF6	192.168.5.164	42580	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401446.889505	5XXHrZpTKxa	192.168.5.164	42514	172.217.22.46	443	tcp	-	11.675382	0	0	SHR	-	0	CafA	1	40	14	560	(empty)
+1608401452.329409	FvB7ulprY0b	192.168.5.164	33881	216.58.207.78	443	tcp	-	6.599072	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401452.285403	iNwI2RF8cij	192.168.5.164	42529	172.217.22.46	443	tcp	-	6.643878	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401452.259800	ghFO4t9fGCk	192.168.5.164	42530	172.217.22.46	443	tcp	-	6.670280	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401452.314219	b3SdsKb9Pqc	192.168.5.164	42532	172.217.22.46	443	tcp	-	6.616662	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401452.438608	6CRWIDJWsHh	192.168.5.164	36951	172.217.16.162	443	tcp	-	6.567473	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401452.372601	FOpOJvw9L0f	192.168.5.164	42533	172.217.22.46	443	tcp	-	6.634289	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401452.417397	bizLKhreflg	192.168.5.164	36950	172.217.16.162	443	tcp	-	6.590319	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401448.142281	40QydK5VWM	192.168.5.164	42510	172.217.22.46	443	tcp	-	10.959854	0	0	SHR	-	0	CafA	1	40	14	560	(empty)
+1608401453.103789	7bMRLqgcmig	192.168.5.164	32975	172.217.18.109	443	tcp	-	6.198296	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401453.095796	rUgareuuvSe	192.168.5.164	33893	216.58.207.78	443	tcp	-	6.207078	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401453.138990	YL0sNdcDxZi	192.168.5.164	33896	216.58.207.78	443	tcp	-	6.253105	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401453.193387	Q8z6yCOpg69	192.168.5.164	54826	172.217.16.131	443	tcp	-	6.199494	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401453.168588	OYm0axOx4wa	192.168.5.164	54827	172.217.16.131	443	tcp	-	6.225085	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401453.130991	UyYhcmIw3Fh	192.168.5.164	33897	216.58.207.78	443	tcp	-	6.263483	0	0	SHR	-	0	CafA	1	40	12	480	(empty)
+1608401451.633812	KCqjklCyfvj	192.168.5.164	42531	172.217.22.46	443	tcp	-	7.840260	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401465.644363	94rksXgtvi8	192.168.5.164	46341	52.39.194.243	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401465.644757	GROuBfHINr1	192.168.5.164	46342	52.39.194.243	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401465.651560	SgJKFNBbHE1	192.168.5.164	46342	52.39.194.243	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401465.645155	A9SgB4gCZ1	192.168.5.164	36182	3.8.13.74	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401465.645556	nrlXCdiU3W9	192.168.5.164	36183	3.8.13.74	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401465.654358	2T0WQObxl7e	192.168.5.164	36182	3.8.13.74	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401465.655557	ig1QMdYecxf	192.168.5.164	36183	3.8.13.74	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401465.663574	IrGh7g6BKpe	192.168.5.164	42585	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401465.664760	MmyL6o1GeKf	192.168.5.164	42586	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401465.671156	GSJNhRMC927	192.168.5.164	46961	35.177.15.101	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401465.673157	TXpF7Ia4Zc4	192.168.5.164	60365	3.9.61.237	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401465.665959	1C5ze4wwB5h	192.168.5.164	42585	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401465.667160	PmfgAnJcsvi	192.168.5.164	42586	172.217.22.46	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.870322	RVJ9srVLbl4	192.168.5.164	42840	35.162.37.53	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.870720	TXXUfRyFnV2	192.168.5.164	39921	34.209.209.121	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.871520	DCGOufB00Oc	192.168.5.164	39923	34.209.209.121	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.871121	HdGDOjLVvtb	192.168.5.164	42842	35.162.37.53	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.882320	0EfZ7767tOj	192.168.5.164	59968	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.882723	8Dxro8vdX8l	192.168.5.164	59969	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.883128	eDQRowP9nCi	192.168.5.164	59970	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.884726	8hp2ZZlEePi	192.168.5.164	59968	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.883528	esT7Gmxtwch	192.168.5.164	59971	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.884326	jNFVoguQOte	192.168.5.164	59973	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.883928	VpgHBykViOf	192.168.5.164	59972	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.885538	1OeZNqYSn7g	192.168.5.164	59970	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.894721	90qAyQ6lfi1	192.168.5.164	59973	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.895121	NroDQbtr3I2	192.168.5.164	59972	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.894325	4v2nwUaH2Ja	192.168.5.164	59971	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.892338	lByyjWsYF41	192.168.5.164	59974	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.892730	hAEP1xNEcp2	192.168.5.164	59975	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.893132	Qmd7Etfzej9	192.168.5.164	59976	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.895521	ykdL9zLJBB9	192.168.5.164	59977	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.895919	YUMdNFxo8Wa	192.168.5.164	59978	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.896323	m1jc4vygQq2	192.168.5.164	59979	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.906328	ZBnv137cDA9	192.168.5.164	59976	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.905919	rJJapAAi7Va	192.168.5.164	59975	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.910723	b21oRfcmSah	192.168.5.164	59977	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.911522	eH3zSnKpsve	192.168.5.164	59979	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.911123	3nn7LrcuGAi	192.168.5.164	59978	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.905522	8Qg4DlFYdj1	192.168.5.164	59974	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.885127	mpTnHdXxKuh	192.168.5.164	59969	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.947921	wg8IuQxH9vb	192.168.5.164	59969	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.989921	LkUQfeN7fFj	192.168.5.164	42856	35.162.37.53	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.991134	OdaCYiFKpXc	192.168.5.164	42857	35.162.37.53	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.991554	kvhHINdEBxb	192.168.5.164	42858	35.162.37.53	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.992721	1tiTTaSPY7l	192.168.5.164	42859	35.162.37.53	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401468.013119	ZS1YSbbbsNj	192.168.5.164	42860	35.162.37.53	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401468.013518	F4wP2hgZEA5	192.168.5.164	42861	35.162.37.53	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401468.015118	mwYBqxxI8U2	192.168.5.164	42863	35.162.37.53	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401468.013917	pFpmEUtFv07	192.168.5.164	42862	35.162.37.53	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401463.549999	XwIVRB7JTZ7	7078:7d02:0:0:e00::	16473	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401463.557195	AmzqOdnF314	7078:7d02:0:0:e00::	36902	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401469.357498	0EbR6TSkpl2	192.168.5.164	49582	172.217.18.174	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401469.359496	RZU7VxUuiZ8	192.168.5.164	49583	172.217.18.174	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401469.425901	0D3vrQ6lQ72	192.168.5.164	57653	172.217.18.161	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401469.469092	UQkBmDIpN6f	192.168.5.164	53477	52.51.196.181	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401469.513494	aDtTFIprzdg	192.168.5.164	37947	185.60.217.35	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401469.509493	Pk98wQhf4Mh	192.168.5.164	37946	185.60.217.35	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401469.534691	XKKn2tE8HTi	192.168.5.164	37946	185.60.217.35	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401469.535490	vZ4F6Zt2dzh	192.168.5.164	51617	216.58.210.3	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401469.536691	rYWpSeLEcpj	192.168.5.164	51618	216.58.210.3	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401469.593886	nJTdd9SwZmj	192.168.5.164	45295	172.217.18.110	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401469.615088	0XBb78yAP6b	192.168.5.164	48207	173.194.164.167	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401469.705912	4yqWeo0Z7F4	192.168.5.164	52959	74.125.173.43	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401465.646756	dPWA2XhMfw8	7078:7d02:0:0:e00::	244	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401465.655957	DwrsWKbq5Sg	7078:7d02:0:0:e00::	4106	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401465.656756	lUPK0nFwzci	7078:7d02:0:0:e00::	8352	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401465.652761	CTIUf3mvak	7078:7d02:0:0:e00::	61654	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401465.671556	80GB0NRulC5	7078:7d02:0:0:e00::	151	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401465.673556	vwsk3JPnsS2	7078:7d02:0:0:e00::	151	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401465.691559	KrirbqZdB47	7078:7d02:0:0:e00::	8395	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401465.694763	SaqaHwdz4K5	7078:7d02:0:0:e00::	61605	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401456.378530	id6oO9KKwoa	192.168.5.164	35745	172.217.23.163	443	tcp	-	9.435023	0	56	SHR	-	0	Cadf	0	0	7	336	(empty)
+1608401456.483731	emQy4636049	192.168.5.164	49518	172.217.18.174	443	tcp	-	9.350626	0	56	SHR	-	0	Cadf	0	0	7	336	(empty)
+1608401456.601724	P4xZMi3ZLd2	192.168.5.164	55978	172.217.18.3	443	tcp	-	9.276232	0	56	SHR	-	0	Cadf	0	0	7	336	(empty)
+1608401456.681324	NiCYfSBSXN	192.168.5.164	59090	216.58.205.234	443	tcp	-	9.214628	0	56	SHR	-	0	Caf	0	0	6	296	(empty)
+1608401456.804920	ncGqJo7GJoe	192.168.5.164	55983	172.217.18.3	443	tcp	-	9.105033	0	56	SHR	-	0	CadfA	1	40	7	336	(empty)
+1608401463.533999	cjJqkUqWnVb	192.168.5.164	49431	172.217.21.202	443	tcp	-	3.671531	0	56	SHR	-	0	Cadf	0	0	5	256	(empty)
+1608401463.649196	LaKGglhhtI6	192.168.5.164	45713	172.217.21.195	443	tcp	-	3.625158	0	56	SHR	-	0	Cadf	0	0	6	296	(empty)
+1608401472.568642	pQ1NXU9Pq16	192.168.5.164	49593	172.217.18.174	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401467.872720	0gdWwRTIJ6l	7078:7d02:0:0:e00::	141	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401467.871926	w7zBwjB2TGj	7078:7d02:0:0:e00::	61605	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401467.875171	fYbQMBdfAwb	7078:7d02:0:0:e00::	8213	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401467.875953	DBVURD4XqWc	7078:7d02:0:0:e00::	53422	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401467.888721	5NP6vb7bxHe	7078:7d02:0:0:e00::	4109	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401467.898319	nscpdFkCoHa	7078:7d02:0:0:e00::	28739	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401467.896719	aeTpLrDbm61	7078:7d02:0:0:e00::	49336	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401467.899126	LDB0bh7Wxh9	7078:7d02:0:0:e00::	16598	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401467.901529	IxkBfPrG4J2	7078:7d02:0:0:e00::	28869	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401467.918322	Qp72Zc06ZPf	7078:7d02:0:0:e00::	61607	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401467.922326	a6vH5VNnGPc	7078:7d02:0:0:e00::	28869	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401467.920726	aANNdHAsyIe	7078:7d02:0:0:e00::	61626	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401467.919922	FVFqgkc9gOi	7078:7d02:0:0:e00::	37064	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401467.919121	FG9MeZuuJth	7078:7d02:0:0:e00::	4109	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401467.921525	qbikxN1zm8g	7078:7d02:0:0:e00::	41127	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401467.952321	R06JAdNf35l	7078:7d02:0:0:e00::	28869	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401468.025153	MumyaoEvmW2	7078:7d02:0:0:e00::	8439	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401468.021917	dGSLIlzkA37	7078:7d02:0:0:e00::	28855	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401468.021119	z0kbtp5e6J5	7078:7d02:0:0:e00::	12297	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401468.020324	IweV5osNCe4	7078:7d02:0:0:e00::	28869	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401468.047517	LVlg8a2Qnc9	7078:7d02:0:0:e00::	12470	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401468.049922	HGng9HIXbCa	7078:7d02:0:0:e00::	28803	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401468.045917	sDmPQvqddm4	7078:7d02:0:0:e00::	53417	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401468.051522	sJpgs7WES01	7078:7d02:0:0:e00::	4206	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401473.768614	6rOGmZoSoc3	192.168.5.164	43680	172.217.18.2	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401473.796216	TbXQ8Adawj7	192.168.5.164	34966	216.58.207.34	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401473.798617	PWyNaWcvZY5	192.168.5.164	46841	172.217.16.130	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401473.799414	BPjgEL0nXi3	192.168.5.164	46842	172.217.16.130	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401473.832613	xnKsvzgFeB4	192.168.5.164	46843	172.217.16.130	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401473.853012	CendkgsV006	192.168.5.164	34970	216.58.207.34	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401473.853808	IMz1QNk8HQk	192.168.5.164	42416	172.217.21.226	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401473.853410	4KlkDCx1vk7	192.168.5.164	46845	172.217.16.130	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401473.867011	tpraOEPl6yc	192.168.5.164	46847	172.217.16.130	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401473.876211	vNAXGkOFzdb	192.168.5.164	46848	172.217.16.130	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401473.890213	wX4xSTM0vIk	192.168.5.164	48610	172.217.18.162	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401474.085866	gSC0SJkwydj	192.168.5.164	57674	172.217.18.161	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401474.087419	rjFSqLHmycg	192.168.5.164	57676	172.217.18.161	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401474.086264	hZl6gL1gKMe	192.168.5.164	57675	172.217.18.161	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401474.087811	i93w6tMJbAh	192.168.5.164	57677	172.217.18.161	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401474.088213	iMTQbDRoIUi	192.168.5.164	57678	172.217.18.161	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401474.105008	KXoR4S2t1e9	192.168.5.164	34529	172.217.18.4	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401474.104611	ktigGGE9SDa	192.168.5.164	34528	172.217.18.4	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401474.240677	9EkCjgch2mk	192.168.5.164	58703	172.217.21.194	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401474.240273	MW0UTem7Jvd	192.168.5.164	58201	35.177.144.113	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401474.245872	lT0AgGPw2K7	192.168.5.164	58203	35.177.144.113	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401474.238272	mO7WuKprcbc	192.168.5.164	41927	18.233.201.37	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401474.246272	vBqlAtFqyp6	192.168.5.164	47463	52.41.52.45	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401469.363102	NIg7kWU9Pja	7078:7d02:0:0:e00::	36934	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401469.367894	CD3Ia5me2I	7078:7d02:0:0:e00::	7	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.311069	Fp84YoHNMh6	192.168.5.164	47464	52.41.52.45	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401469.435098	89ZM2KWuhrg	7078:7d02:0:0:e00::	28871	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.427021	6B6Ta7IMW22	192.168.5.164	33031	172.217.21.206	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401474.427408	piNytSScVT8	192.168.5.164	33032	172.217.21.206	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401469.470303	nZQIvTOVUbj	7078:7d02:0:0:e00::	45269	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.488203	MfphtpVo3K1	192.168.5.164	33033	172.217.21.206	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401469.514689	Gul1WTWJINe	7078:7d02:0:0:e00::	20711	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401469.543886	AnAa31ofKzc	7078:7d02:0:0:e00::	36934	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401469.543094	6F0wqv9agfb	7078:7d02:0:0:e00::	28871	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401469.539496	1I8dRVhl3Pk	7078:7d02:0:0:e00::	20711	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.531812	rvBdGzham1a	192.168.5.164	41210	216.58.206.14	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401474.536208	9QBm3SCud7i	192.168.5.164	41211	216.58.206.14	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401474.537413	tni0lyCPGMg	192.168.5.164	41212	216.58.206.14	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401474.552200	y3LdaGvT52e	192.168.5.164	41213	216.58.206.14	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401469.599086	3A81Aq2DtHk	7078:7d02:0:0:e00::	36934	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401469.622686	yvAElc1iGwc	7078:7d02:0:0:e00::	36934	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401469.708783	oTaxwY3jBk3	7078:7d02:0:0:e00::	37042	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401472.569836	GWb50y9ZcC4	7078:7d02:0:0:e00::	8406	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401473.800612	XhEedmasrD4	7078:7d02:0:0:e00::	36902	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401473.819873	i99nvVHz436	7078:7d02:0:0:e00::	61695	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401473.826224	BIjENAIXnb3	7078:7d02:0:0:e00::	49154	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401473.825541	i2OvXwjgVs7	7078:7d02:0:0:e00::	49336	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401473.859812	IV0jWMI0Tqj	7078:7d02:0:0:e00::	207	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401473.891435	4G4GvlHlYnj	7078:7d02:0:0:e00::	61547	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401473.893812	lulloVPkFvc	7078:7d02:0:0:e00::	24779	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401473.899444	FDuTFYRoDpg	7078:7d02:0:0:e00::	61695	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401473.898253	9UeXkrQI65f	7078:7d02:0:0:e00::	8441	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401473.895414	R7m5KhaeR5b	7078:7d02:0:0:e00::	49189	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401473.922212	APi1XXIoKNh	7078:7d02:0:0:e00::	12397	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.118206	rOCb2QGOR62	7078:7d02:0:0:e00::	57558	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.117405	6gnC4RCIj09	7078:7d02:0:0:e00::	106	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.116607	gkERYzIONka	7078:7d02:0:0:e00::	12427	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.114206	nWFyzcmBeZ	7078:7d02:0:0:e00::	53425	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.113407	pCWgeyvGIj2	7078:7d02:0:0:e00::	61516	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.135822	SaJv1EJs7Ed	7078:7d02:0:0:e00::	53348	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.136605	1HAEXV5Nztk	7078:7d02:0:0:e00::	32964	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.250681	wsaGZqxvf35	7078:7d02:0:0:e00::	57398	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.244266	t9EUv7ToQLl	7078:7d02:0:0:e00::	24820	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.260209	cpyE4i4OoD3	7078:7d02:0:0:e00::	24820	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.279005	B2bDDaeuDH7	7078:7d02:0:0:e00::	57536	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.319410	87CMmvFc0V4	7078:7d02:0:0:e00::	24798	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.394604	WdSTq4r7wA3	7078:7d02:0:0:e00::	16450	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.455006	D6UY5r3jpea	7078:7d02:0:0:e00::	45058	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.455804	cCHs6eHjzp	7078:7d02:0:0:e00::	61481	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.501800	b8WfnBKtvB8	7078:7d02:0:0:e00::	16569	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.550601	gnOD7wg0Urf	7078:7d02:0:0:e00::	4213	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.560599	hWquRFNjvug	7078:7d02:0:0:e00::	4140	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.558199	1LTbzhurjUh	7078:7d02:0:0:e00::	49334	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.576605	qREMPtIDR8f	7078:7d02:0:0:e00::	4213	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.762998	K4lTRMLXkOd	192.168.5.164	45295	172.217.18.110	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401474.772207	my39nvwlnOg	192.168.5.164	51617	216.58.210.3	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401477.348148	gmiLA9CrR8i	192.168.5.164	53477	52.51.196.181	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401477.384604	DFJLsV6zp0e	192.168.5.164	37947	185.60.217.35	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401480.225734	PIsFnOn7mNd	7078:7d02:0:0:e00::	4282	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401485.580473	ncTrp5jw1U4	192.168.5.164	54591	54.148.41.88	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401486.204863	cW8SPDCwKPl	192.168.5.164	42909	35.162.37.53	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401486.116012	rt9F8679Dcc	192.168.5.164	42908	35.162.37.53	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401486.520794	7iLKPbyNdac	192.168.5.164	38225	34.213.110.255	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401486.817186	SHYvjlyO0nk	192.168.5.164	60035	93.184.220.29	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401486.376793	deJh5RHSHud	192.168.5.164	42908	35.162.37.53	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401487.122376	jNT5RsBrmK7	192.168.5.164	42908	35.162.37.53	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401482.884467	lGWVVealz15	7078:7d02:0:0:e00::	61507	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401489.715937	9bJYb4mJjH7	192.168.5.164	41370	172.217.16.198	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401484.763621	sx916itRNi6	192.168.5.164	52959	74.125.173.43	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401484.863283	OhzvGn5ZBI7	192.168.5.164	48207	173.194.164.167	80	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401489.813537	QNxf3vHYXdc	192.168.5.164	46378	52.41.66.223	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401489.877131	aWEt3NyD4wd	192.168.5.164	38731	23.42.150.222	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401489.876737	1YYKPIFWUtk	192.168.5.164	36263	3.8.13.74	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401489.891134	OdNsTqRYxbc	192.168.5.164	38732	23.42.150.222	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401489.849129	hJJE4zVCrOl	192.168.5.164	46379	52.41.66.223	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401484.986815	HpS0ZPhQuz3	7078:7d02:0:0:e00::	53315	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401490.220327	EYkgbN5wyrf	192.168.5.164	33886	18.130.186.43	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401490.224833	nweZrDW6aug	192.168.5.164	33887	18.130.186.43	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401490.257940	eWk5FW1Yc9f	192.168.5.164	44134	18.130.137.141	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401490.265581	0t8LMAlxC22	192.168.5.164	44135	18.130.137.141	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401474.131813	CvbT4aZljec	192.168.5.164	59972	93.184.220.29	80	tcp	-	11.187796	0	0	SHR	-	0	CafA	1	40	6	240	(empty)
+1608401474.124663	XRjvGf971H	192.168.5.164	59973	93.184.220.29	80	tcp	-	11.195746	0	0	SHR	-	0	CafA	1	40	6	240	(empty)
+1608401474.223063	tQPtCE6s6Ol	192.168.5.164	59970	93.184.220.29	80	tcp	-	11.430946	0	0	SHR	-	0	CafA	1	40	6	240	(empty)
+1608401485.688880	3iKH90FQtCd	7078:7d02:0:0:e00::	12357	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401474.407005	szqI7nf56D	192.168.5.164	39921	34.209.209.121	443	tcp	-	11.322262	0	31	RSTOS0	-	0	CadR	1	40	7	311	(empty)
+1608401490.962314	6leZ4grunK1	192.168.5.164	51267	172.217.14.99	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401486.205259	mwjZPcxqgvk	7078:7d02:0:0:e00::	4106	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401486.647189	43Z55S9vRMl	7078:7d02:0:0:e00::	12357	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401486.861181	fKJSpoGmSp6	7078:7d02:0:0:e00::	12357	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401487.242775	GNO8o0QL4D3	7078:7d02:0:0:e00::	12357	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401489.715134	Jcmtmzz1th6	192.168.5.164	37946	185.60.217.35	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401463.646797	w1Mb6nDlAl5	192.168.5.164	38635	23.42.150.222	443	tcp	-	26.096741	0	31	RSTOS0	-	0	CadR	1	40	8	351	(empty)
+1608401489.743939	2DOS9IH6MDd	7078:7d02:0:0:e00::	33022	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401489.899933	5dKrlbwhHlk	7078:7d02:0:0:e00::	28802	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401489.897534	50xWRiXnvLl	7078:7d02:0:0:e00::	53329	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401489.909536	hw9QGwgS1Ng	7078:7d02:0:0:e00::	61564	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401489.917531	5Fzx9Awyy7i	7078:7d02:0:0:e00::	16403	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401489.933531	OgQq3P5oK1e	7078:7d02:0:0:e00::	24820	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401490.248327	mbaFMYkjGOd	7078:7d02:0:0:e00::	16435	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401490.245933	3xB4v7odYTh	7078:7d02:0:0:e00::	45224	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401490.287591	CVWgoY7RLC	7078:7d02:0:0:e00::	16435	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401490.292341	xIKXXhE0Jea	7078:7d02:0:0:e00::	16384	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401480.766955	HGMXfz8jsB	192.168.5.164	58201	35.177.144.113	443	tcp	-	9.952162	0	31	SHR	-	0	CadfA	1	40	7	311	(empty)
+1608401480.952161	9K4y6G0Vxo	192.168.5.164	41927	18.233.201.37	443	tcp	-	9.799757	0	31	SHR	-	0	CadfA	1	40	7	311	(empty)
+1608401463.541624	gC0E6BDXkj5	192.168.5.164	49430	172.217.21.202	443	tcp	-	27.434302	0	237032	SHR	-	0	Cadf	0	0	16	3512	(empty)
+1608401490.971518	QHOTXkXnTp	7078:7d02:0:0:e00::	151	502f:5503::1984:6b36:fb7f:0	0	tcp	-	-	-	-	OTH	-	0	c	0	0	0	0	(empty)
+1608401491.296771	xqmbli1cNB	192.168.5.164	42909	35.162.37.53	443	tcp	-	2.614754	0	31	SHR	-	0	CadfA	1	40	5	231	(empty)
+1608401480.136102	mkkr3CelkVh	192.168.5.164	46842	172.217.16.130	443	tcp	-	16.395331	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401480.053703	rW55vAEggqf	192.168.5.164	43680	172.217.18.2	443	tcp	-	16.478520	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401480.282558	ZghGl5xcQ7f	192.168.5.164	34966	216.58.207.34	443	tcp	-	16.250497	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401480.093003	YKZkLICEtvg	192.168.5.164	49593	172.217.18.174	443	tcp	-	16.440814	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401480.563753	1UD2KuOpg12	192.168.5.164	34529	172.217.18.4	443	tcp	-	16.050861	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401496.712612	MXk0fxKlG2a	192.168.5.164	51267	172.217.14.99	443	tcp	-	-	-	-	OTH	-	0	C	0	0	0	0	(empty)
+1608401480.838956	q3NY0jn7zV8	192.168.5.164	34528	172.217.18.4	443	tcp	-	15.884058	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401480.895353	1Pn78i2B4J1	192.168.5.164	46841	172.217.16.130	443	tcp	-	15.828466	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401481.067353	yBBDEjGxcr6	192.168.5.164	33031	172.217.21.206	443	tcp	-	15.657267	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401481.035297	CQDOrNZpwC8	192.168.5.164	33032	172.217.21.206	443	tcp	-	15.690918	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401480.818949	cJ41NxsM5ga	192.168.5.164	46843	172.217.16.130	443	tcp	-	15.908064	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401480.982540	0CVaGuBxk2a	192.168.5.164	58703	172.217.21.194	443	tcp	-	15.745272	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401481.203696	5Pj7BwueLB3	192.168.5.164	41211	216.58.206.14	443	tcp	-	15.647318	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401481.173341	akXVkNLcJL7	192.168.5.164	41210	216.58.206.14	443	tcp	-	15.678478	0	0	SHR	-	0	CafA	1	40	13	520	(empty)
+1608401463.949189	ngwhNdY72D9	192.168.5.164	38643	23.42.150.222	443	tcp	-	36.092165	0	469	RSTO	-	0	CadRf	2	80	12	949	(empty)
+1608401501.464354	64Ksl482x8i	10.0.0.3	45428	10.0.0.2	7792	tcp	-	0.032591	0	0	S0	-	0	ScA	72	3752	0	0	(empty)
+1608401546.846699	Uie7S9iX2Og	10.0.0.3	45428	10.0.0.2	7792	tcp	-	-	-	-	SH	-	0	Fc	1	52	0	0	(empty)
diff --git a/dns.log b/dns.log
new file mode 100644
index 0000000..26ced98
--- /dev/null
+++ b/dns.log
@@ -0,0 +1,9 @@
+#separator \x09
+#set_separator	,
+#empty_field	(empty)
+#unset_field	-
+#path	dns
+#open	2020-12-18-19-45-38
+#fields	ts	uid	id.orig_h	id.orig_p	id.resp_h	id.resp_p	proto	trans_id	query	qclass	qclass_name	qtype	qtype_name	rcode	rcode_name	AA	TC	RD	RA	Z	answers	TTLs
+#types	time	string	addr	port	addr	port	enum	count	string	count	string	count	string	count	string	bool	bool	bool	bool	count	vector[string]	vector[interval]
+1608317118.706946	vuvKHBD0Hd1	10.0.0.1	5353	224.0.0.251	5353	udp	0	_googlecast._tcp.local	1	C_INTERNET	12	PTR	-	-	F	F	F	F	0	-	-
diff --git a/notice.log b/notice.log
new file mode 100644
index 0000000..f392f94
--- /dev/null
+++ b/notice.log
@@ -0,0 +1,11 @@
+#separator \x09
+#set_separator	,
+#empty_field	(empty)
+#unset_field	-
+#path	notice
+#open	2020-12-19-15-24-39
+#fields	ts	uid	id.orig_h	id.orig_p	id.resp_h	id.resp_p	proto	note	msg	sub	src	dst	p	n	peer_descr	actions	policy_items	suppress_for	dropped	remote_location.country_code	remote_location.region	remote_location.city	remote_location.latitude	remote_location.longitude	metric_index.host	metric_index.str	metric_index.network
+#types	time	string	addr	port	addr	port	enum	enum	string	string	addr	addr	port	count	string	table[enum]	table[count]	interval	bool	string	string	string	double	double	addr	string	subnet
+1608387879.157268	-	-	-	-	-	-	PacketFilter::Dropped_Packets	14 packets dropped after filtering, 13883 received, 13883 on link	-	-	-	-	-	bro	Notice::ACTION_LOG	6	3600.000000	F	-	-	-	-	-	-	-	-
+1608387889.157279	-	-	-	-	-	-	PacketFilter::Dropped_Packets	71 packets dropped after filtering, 17219 received, 17222 on link	-	-	-	-	-	bro	Notice::ACTION_LOG	6	3600.000000	F	-	-	-	-	-	-	-	-
+#close	2020-12-19-15-26-18
diff --git a/notice_policy.log b/notice_policy.log
new file mode 100644
index 0000000..429abd8
--- /dev/null
+++ b/notice_policy.log
@@ -0,0 +1,15 @@
+#separator \x09
+#set_separator	,
+#empty_field	(empty)
+#unset_field	-
+#path	notice_policy
+#open	2020-12-19-19-10-21
+#fields	position	priority	action	pred	halt	suppress_for
+#types	count	count	enum	func	bool	interval
+0	10	Notice::ACTION_ADD_GEODATA	anonymous-function\x0a{ \x0areturn ((Notice::n$note in Notice::lookup_location_types));\x0a}	F	-
+1	9	Notice::ACTION_NO_SUPPRESS	anonymous-function\x0a{ \x0areturn ((Notice::n$note in Notice::not_suppressed_types));\x0a}	F	-
+2	9	Notice::ACTION_NONE	anonymous-function\x0a{ \x0areturn ((Notice::n$note in Notice::ignored_types));\x0a}	T	-
+3	8	Notice::ACTION_ALARM	anonymous-function\x0a{ \x0areturn ((Notice::n$note in Notice::alarmed_types));\x0a}	F	-
+4	8	Notice::ACTION_NONE	anonymous-function\x0a{ \x0aif (Notice::n$note in Notice::type_suppression_intervals) \x0a\x09{ \x0a\x09Notice::n$suppress_for = Notice::type_suppression_intervals[Notice::n$note];\x0a\x09return (T);\x0a\x09}\x0a\x0areturn (F);\x0a}	F	-
+5	8	Notice::ACTION_EMAIL	anonymous-function\x0a{ \x0areturn ((Notice::n$note in Notice::emailed_types));\x0a}	F	-
+6	0	Notice::ACTION_LOG	-	F	-
diff --git a/packet_filter.log b/packet_filter.log
new file mode 100644
index 0000000..95fc8d9
--- /dev/null
+++ b/packet_filter.log
@@ -0,0 +1,9 @@
+#separator \x09
+#set_separator	,
+#empty_field	(empty)
+#unset_field	-
+#path	packet_filter
+#open	2020-12-19-19-10-21
+#fields	ts	node	filter	init	success
+#types	time	string	string	bool	bool
+1608401421.784677	-	ip or not ip	T	T
diff --git a/reporter.log b/reporter.log
new file mode 100644
index 0000000..5c54c95
--- /dev/null
+++ b/reporter.log
@@ -0,0 +1,11 @@
+#separator \x09
+#set_separator	,
+#empty_field	(empty)
+#unset_field	-
+#path	reporter
+#open	2020-12-19-15-26-18
+#fields	ts	level	message	location
+#types	time	enum	string	string
+1608387978.706733	Reporter::INFO	received termination signal	(empty)
+1608387978.706733	Reporter::INFO	159018 packets received on interface eno1, 85 dropped\x0a	(empty)
+#close	2020-12-19-15-26-18
diff --git a/sdmbn_build.sh b/sdmbn_build.sh
new file mode 100644
index 0000000..57bbe23
--- /dev/null
+++ b/sdmbn_build.sh
@@ -0,0 +1,11 @@
+#!/bin/bash
+
+export LDFLAGS="-lsdmbn -ljson-c -lboost_serialization"
+
+./configure
+sed -e 's/-lsdmbn -ljson-c -lboost_serialization//' -i build/src/CMakeFiles/bro.dir/link.txt
+sed -e 's/-lcrypto/-lcrypto -lsdmbn -ljson-c -lboost_serialization/' -i build/src/CMakeFiles/bro.dir/link.txt
+sed -e 's/-lsdmbn -ljson-c -lboost_serialization//' -i build/src/CMakeFiles/bro.dir/relink.txt
+sed -e 's/-lcrypto/-lcrypto -lsdmbn -ljson-c -lboost_serialization/' -i build/src/CMakeFiles/bro.dir/relink.txt
+make
+make install
diff --git a/src/Analyzer.cc b/src/Analyzer.cc
index 9e30da0..b734d04 100644
--- a/src/Analyzer.cc
+++ b/src/Analyzer.cc
@@ -40,6 +40,11 @@
 #include "Syslog-binpac.h"
 #include "Teredo.h"
 #include "ConnSizeAnalyzer.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/list.hpp>
+#include "SDMBNlocal.h"
 
 // Keep same order here as in AnalyzerTag definition!
 const Analyzer::Config Analyzer::analyzer_configs[] = {
@@ -203,6 +208,27 @@ void AnalyzerTimer::Init(Analyzer* arg_analyzer, analyzer_timer_func arg_timer,
 	Ref(analyzer->Conn());
 	}
 
+BOOST_CLASS_EXPORT_GUID(AnalyzerTimer,"AnalyzerTimer")
+template<class Archive>
+void AnalyzerTimer::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:AnalyzerTimer:%d",__FILE__,__LINE__);
+        // Serialize Timer
+        ar & boost::serialization::base_object<Timer>(*this);
+
+        ar & analyzer;
+       
+        //ar & timer; //FIXME
+
+        ar & do_expire;
+    }
+template void AnalyzerTimer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void AnalyzerTimer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 AnalyzerID Analyzer::id_counter = 0;;
 
 Analyzer* Analyzer::InstantiateAnalyzer(AnalyzerTag::Tag tag, Connection* c)
@@ -248,11 +274,13 @@ Analyzer::Analyzer(AnalyzerTag::Tag arg_tag, Connection* arg_conn)
 	resp_supporters = 0;
 	signature = 0;
 	output_handler = 0;
+    timers_canceled = false;
+    moved = false;
 	}
 
 Analyzer::~Analyzer()
 	{
-	assert(finished);
+	//assert(moved || finished); // SDMBN-FIXME
 
 	LOOP_OVER_CHILDREN(i)
 		delete *i;
@@ -272,6 +300,9 @@ Analyzer::~Analyzer()
 		}
 
 	delete output_handler;
+
+    if (moved)
+    { CancelTimers(); }
 	}
 
 void Analyzer::Init()
@@ -291,6 +322,9 @@ void Analyzer::InitChildren()
 
 void Analyzer::Done()
 	{
+    if (moved)
+    { return; }
+
 	assert(!finished);
 
 	if ( ! skip )
@@ -863,6 +897,86 @@ void Analyzer::UpdateConnVal(RecordVal *conn_val)
 		(*i)->UpdateConnVal(conn_val);
 	}
 
+void Analyzer::Moved()
+    {
+    moved = true;
+	
+	for ( SupportAnalyzer* a = orig_supporters; a; a = a->sibling )
+    { a->Moved(); }
+
+	for ( SupportAnalyzer* a = resp_supporters; a; a = a->sibling )
+    { a->Moved(); }
+
+    for (std::list<Analyzer*>::iterator it = children.begin(); 
+              it != children.end(); it++)
+    { (*it)->Moved(); }
+        
+    for (std::list<Analyzer*>::iterator it = new_children.begin(); 
+            it != new_children.end(); it++)
+    { (*it)->Moved(); }
+    }
+
+BOOST_CLASS_EXPORT_GUID(Analyzer,"Analyzer")
+template<class Archive>
+void Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:Analyzer:%d",__FILE__,__LINE__);
+
+        ar & tag;
+        ar & id;
+        ar & conn; 
+
+        // Special check for analyzer serializability
+        if (!Archive::is_loading::value)
+        {
+            if (parent != NULL)
+            { assert(sdmbn_can_serialize(parent->GetTag())); }
+        }
+        SERIALIZE_PRINT("\t\tAnalyzer:%d",__LINE__);
+        ar & parent;
+        //ar & signature; //Include? Does not seem to be used
+        if (Archive::is_loading::value) { signature = NULL; }
+        //ar & output_handler //Include? Only used in HTTP.cc:190
+        if (Archive::is_loading::value) { output_handler = NULL; }
+        
+        // Special check for analyzer serializability
+        if (!Archive::is_loading::value)
+        {
+            for (std::list<Analyzer*>::iterator it = children.begin(); 
+                    it != children.end(); it++)
+            { assert(sdmbn_can_serialize((*it)->GetTag())); }
+
+            if (orig_supporters != NULL)
+            { assert(sdmbn_can_serialize(orig_supporters->GetTag())); }
+        
+            if (resp_supporters != NULL)
+            { assert(sdmbn_can_serialize(resp_supporters->GetTag())); }
+        
+            for (std::list<Analyzer*>::iterator it = new_children.begin(); 
+                    it != new_children.end(); it++)
+            { assert(sdmbn_can_serialize((*it)->GetTag())); }
+        }
+        ar & children;
+        ar & orig_supporters;
+        ar & resp_supporters;
+        ar & new_children;
+
+        SERIALIZE_PRINT("\t\tAnalyzer:%d",__LINE__);
+        ar & protocol_confirmed;
+        //ar & timers; //FIXME //Should include?
+        ar & timers_canceled;
+        ar & skip;
+        ar & finished;
+        ar & removing;
+        SERIALIZE_PRINT("\t\tAnalyzer:Done");
+    }
+template void Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar,
+        const unsigned int file_version);
+template void Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar,
+        const unsigned int file_version);
+
 void SupportAnalyzer::ForwardPacket(int len, const u_char* data, bool is_orig,
 					int seq, const IP_Hdr* ip, int caplen)
 	{
@@ -906,6 +1020,26 @@ void SupportAnalyzer::ForwardUndelivered(int seq, int len, bool is_orig)
 		Parent()->Undelivered(seq, len, is_orig);
 	}
 
+BOOST_CLASS_EXPORT_GUID(SupportAnalyzer,"SupportAnalyzer")
+template<class Archive>
+void SupportAnalyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:SupportAnalyzer:%d",__FILE__,__LINE__);
+
+        // Serialize Analyzer
+        ar & boost::serialization::base_object<Analyzer>( *this );
+
+        SERIALIZE_PRINT("\t\tSupportAnalyzer:%d",__LINE__);
+        ar & orig;
+        ar & sibling;
+        SERIALIZE_PRINT("\t\tSupportAnalyzer:Done");
+    }
+template void SupportAnalyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar,
+        const unsigned int file_version);
+template void SupportAnalyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar,
+        const unsigned int file_version);
 
 void TransportLayerAnalyzer::Done()
 	{
@@ -934,3 +1068,23 @@ void TransportLayerAnalyzer::PacketContents(const u_char* data, int len)
 		}
 	}
 
+BOOST_CLASS_EXPORT_GUID(TransportLayerAnalyzer,"TransportLayerAnalyzer")
+template<class Archive>
+void TransportLayerAnalyzer::serialize(Archive & ar, 
+        const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TransportLayerAnalyzer:%d",__FILE__,__LINE__);
+
+        // Serialize Analyzer
+        ar & boost::serialization::base_object<Analyzer>(*this);
+
+        SERIALIZE_PRINT("\t\tTransportLayerAnalyzer:%d",__LINE__);
+        ar & pia;
+        SERIALIZE_PRINT("\t\tTransportLayerAnalyzer:Done");
+    }
+template void TransportLayerAnalyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar,
+        const unsigned int file_version);
+template void TransportLayerAnalyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar,
+        const unsigned int file_version);
diff --git a/src/Analyzer.h b/src/Analyzer.h
index 6ccd764..f77790a 100644
--- a/src/Analyzer.h
+++ b/src/Analyzer.h
@@ -8,6 +8,7 @@
 #include "AnalyzerTags.h"
 #include "Conn.h"
 #include "Obj.h"
+#include <boost/serialization/access.hpp>
 
 class DPM;
 class PIA;
@@ -36,6 +37,10 @@ protected:
 	Analyzer* analyzer;
 	analyzer_timer_func timer;
 	int do_expire;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 
@@ -253,6 +258,9 @@ public:
 
 	// Factory function to instantiate new analyzers.
 	static Analyzer* InstantiateAnalyzer(AnalyzerTag::Tag tag, Connection* c);
+    
+    void Moved();
+    bool HasMoved() { return moved; }
 
 protected:
 	friend class DPM;
@@ -260,7 +268,7 @@ protected:
 	friend class AnalyzerTimer;
 	friend class TCP_ApplicationAnalyzer;
 
-	Analyzer()	{ }
+	Analyzer()	{ moved = false; }
 
 	// Associates a connection with this analyzer.  Must be called if
 	// we're using the default ctor.
@@ -326,6 +334,11 @@ private:
 	// Table of analyzers.
 	static const Config analyzer_configs[];
 
+    bool moved;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #define ADD_ANALYZER_TIMER(timer, t, do_expire, type) \
@@ -373,8 +386,11 @@ private:
 	// Points to next support analyzer in chain.  The list is managed by
 	// parent analyzer.
 	SupportAnalyzer* sibling;
-};
 
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+};
 
 class TransportLayerAnalyzer : public Analyzer {
 public:
@@ -398,6 +414,10 @@ protected:
 
 private:
 	PIA* pia;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff --git a/src/Attr.cc b/src/Attr.cc
index 2e4e090..8322a5f 100644
--- a/src/Attr.cc
+++ b/src/Attr.cc
@@ -6,6 +6,10 @@
 #include "Expr.h"
 #include "Serializer.h"
 #include "threading/SerialTypes.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include "SDMBNlocal.h"
 
 const char* attr_name(attr_tag t)
 	{
@@ -548,3 +552,21 @@ bool Attributes::DoUnserialize(UnserialInfo* info)
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(Attributes,"Attributes")
+template<class Archive>
+void Attributes::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:Attributes:%d",__FILE__,__LINE__);
+        // Serialize BroObj
+        ar & boost::serialization::base_object<BroObj>(*this);
+
+        ar & type;
+        ar & attrs;
+        ar & in_record;
+    }
+template void Attributes::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void Attributes::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/Attr.h b/src/Attr.h
index e6b09cf..55471c4 100644
--- a/src/Attr.h
+++ b/src/Attr.h
@@ -4,6 +4,7 @@
 #define attr_h
 
 #include "Obj.h"
+#include <boost/serialization/access.hpp>
 
 class Expr;
 
@@ -107,6 +108,10 @@ protected:
 	BroType* type;
 	attr_list* attrs;
 	bool in_record;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff --git a/src/Base64.cc b/src/Base64.cc
index b0da8ea..e77a1a7 100644
--- a/src/Base64.cc
+++ b/src/Base64.cc
@@ -1,5 +1,10 @@
 #include "config.h"
 #include "Base64.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include "SDMBNlocal.h"
 
 int Base64Decoder::default_base64_table[256];
 const string Base64Decoder::default_alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
@@ -163,6 +168,46 @@ int Base64Decoder::Done(int* pblen, char** pbuf)
 	return 0;
 	}
 
+BOOST_CLASS_EXPORT_GUID(Base64Decoder,"Base64Decoder")
+template<class Archive>
+void Base64Decoder::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:Base64Decoder:%d",__FILE__,__LINE__);
+
+        ar & error_msg;
+        ar & base64_group;
+        ar & base64_group_next;
+        ar & base64_padding;
+        ar & base64_after_padding;
+        ar & errored;
+
+        // Special check for analyzer serializability
+        if (!Archive::is_loading::value)
+        {
+            if (analyzer != NULL)
+            { assert(sdmbn_can_serialize(analyzer->GetTag())); }
+        }
+        ar & analyzer;
+
+        // Special handling of base64_table
+        if (!Archive::is_loading::value)
+        { 
+            ar & boost::serialization::make_binary_object(base64_table,
+                    256*sizeof(int)); 
+        }
+        if (Archive::is_loading::value)
+        {
+            base64_table = new int[256];
+            ar & boost::serialization::make_binary_object(base64_table,
+                    256*sizeof(int));
+        }
+    }
+template void Base64Decoder::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void Base64Decoder::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
 
 BroString* decode_base64(const BroString* s, const BroString* a)
 	{
diff --git a/src/Base64.h b/src/Base64.h
index 0e02c94..0283e5e 100644
--- a/src/Base64.h
+++ b/src/Base64.h
@@ -8,6 +8,7 @@
 #include "util.h"
 #include "BroString.h"
 #include "Analyzer.h"
+#include <boost/serialization/access.hpp>
 
 // Maybe we should have a base class for generic decoders?
 
@@ -62,6 +63,12 @@ protected:
 	static int* InitBase64Table(const string& alphabet);
 	static int default_base64_table[256];
 	static const string default_alphabet;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    Base64Decoder() {}; // Dummy default constructor for serialization
 };
 
 BroString* decode_base64(const BroString* s, const BroString* a = 0);
diff --git a/src/BroString.cc b/src/BroString.cc
index e05995b..92c3fac 100644
--- a/src/BroString.cc
+++ b/src/BroString.cc
@@ -10,6 +10,11 @@
 #include "BroString.h"
 #include "Var.h"
 #include "Reporter.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include "SDMBNlocal.h"
 
 #ifdef DEBUG
 #define DEBUG_STR(msg) DBG_LOG(DBG_STRING, msg)
@@ -61,6 +66,7 @@ BroString::BroString(const BroString& bs)
 	{
 	b = 0;
 	n = 0;
+	final_NUL = 0;
 	use_free_to_delete = 0;
 	*this = bs;
 	}
@@ -408,6 +414,51 @@ char* BroString::VecToString(const Vec* vec)
 	return strdup(result.c_str());
 	}
 
+BOOST_CLASS_EXPORT_GUID(BroString,"BroString")
+template<class Archive>
+void BroString::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:BroString:%d",__FILE__,__LINE__);
+
+        // Special handling of bit fields
+        unsigned int bitfields = 0;
+        if (!Archive::is_loading::value)
+        {
+            bitfields |= (final_NUL << 0);
+        }
+        ar & bitfields;
+        if (Archive::is_loading::value)
+        {
+            final_NUL = (bitfields >> 0) & 0x1;
+        }
+
+        ar & n;
+
+        // Special handling of buffer
+        if (!Archive::is_loading::value)
+        {
+            if (n > 0)
+            { ar & boost::serialization::make_binary_object(b, n+final_NUL); }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (n > 0)
+            {
+                b = new u_char[n + final_NUL];
+                ar & boost::serialization::make_binary_object(b, n+final_NUL);
+                use_free_to_delete = 0;
+            }
+            else
+            { b = 0; }
+        }
+    }
+template void BroString::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void BroString::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 bool BroStringLenCmp::operator()(BroString * const& bst1,
 				 BroString * const& bst2)
 	{
@@ -500,6 +551,12 @@ BroString* concatenate(BroString::Vec& v)
 	return concatenate(cv);
 	}
 
+void delete_strings(std::vector<BroString*>& v)
+	{
+	for ( unsigned int i = 0; i < v.size(); ++i )
+		delete v[i];
+	v.clear();
+	}
 void delete_strings(std::vector<const BroString*>& v)
 	{
 	for ( unsigned int i = 0; i < v.size(); ++i )
diff --git a/src/BroString.h b/src/BroString.h
index 58991d7..4dedc23 100644
--- a/src/BroString.h
+++ b/src/BroString.h
@@ -8,6 +8,7 @@
 #include <iostream>
 #include <stdlib.h>
 #include <sys/types.h>
+#include <boost/serialization/access.hpp>
 using namespace std;
 
 #include "util.h"
@@ -150,6 +151,10 @@ protected:
 	int n;
 	unsigned int final_NUL:1;	// whether we have added a final NUL
 	unsigned int use_free_to_delete:1;	// free() vs. operator delete
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 // A comparison class that sorts pointers to BroString's according to
@@ -186,6 +191,7 @@ struct data_chunk_t {
 extern BroString* concatenate(std::vector<data_chunk_t>& v);
 extern BroString* concatenate(BroString::Vec& v);
 extern BroString* concatenate(BroString::CVec& v);
+extern void delete_strings(std::vector<BroString*>& v);
 extern void delete_strings(std::vector<const BroString*>& v);
 
 #endif
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index ce44085..045f459 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -378,6 +378,7 @@ set(bro_SRCS
     RuleCondition.cc
     RuleMatcher.cc
     ScriptAnaly.cc
+    SDMBNlocal.cc
     SmithWaterman.cc
     SMB.cc
     SMTP.cc
diff --git a/src/CompHash.cc b/src/CompHash.cc
index 86677f9..e01a6b3 100644
--- a/src/CompHash.cc
+++ b/src/CompHash.cc
@@ -6,6 +6,11 @@
 #include "Val.h"
 #include "Reporter.h"
 #include "Func.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include "SDMBNlocal.h"
 
 CompositeHash::CompositeHash(TypeList* composite_type)
 	{
@@ -917,3 +922,38 @@ const char* CompositeHash::RecoverOneVal(const HashKey* k, const char* kp0,
 
 	return kp1;
 	}
+
+BOOST_CLASS_EXPORT_GUID(CompositeHash,"Compositehash")
+template<class Archive>
+void CompositeHash::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & type;
+        ar & size;
+
+        // Special handling of key 
+        if (!Archive::is_loading::value)
+        { 
+            if (size > 0)
+            { ar & boost::serialization::make_binary_object(key, size); }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (size > 0)
+            {
+                key = new char[size];
+                ar & boost::serialization::make_binary_object(key, size);
+            }
+            else
+            { key = NULL; }
+        }
+
+        ar & is_singleton;
+        ar & is_complex_type;
+        ar & singleton_tag;
+    }
+template void CompositeHash::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void CompositeHash::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/CompHash.h b/src/CompHash.h
index 1a02114..db1c7d4 100644
--- a/src/CompHash.h
+++ b/src/CompHash.h
@@ -5,6 +5,7 @@
 
 #include "Hash.h"
 #include "Type.h"
+#include <boost/serialization/access.hpp>
 
 class ListVal;
 
@@ -88,6 +89,12 @@ protected:
 	int is_complex_type;
 
 	InternalTypeTag singleton_tag;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    CompositeHash() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff --git a/src/Conn.cc b/src/Conn.cc
index bc2e7fb..faf3edd 100644
--- a/src/Conn.cc
+++ b/src/Conn.cc
@@ -14,6 +14,10 @@
 #include "PIA.h"
 #include "binpac.h"
 #include "TunnelEncapsulation.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include "SDMBNlocal.h"
 
 void ConnectionTimer::Init(Connection* arg_conn, timer_func arg_timer,
 				int arg_do_expire)
@@ -106,6 +110,62 @@ bool ConnectionTimer::DoUnserialize(UnserialInfo* info)
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(ConnectionTimer,"ConnectionTimer")
+template<class Archive>
+void ConnectionTimer::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:ConnectionTimer:%d",__FILE__,__LINE__);
+        // Serialize Timer
+        ar & boost::serialization::base_object<Timer>(*this);
+
+        ar & conn;
+
+        // Special handling of timer
+        char type = 0;
+        if (!Archive::is_loading::value)
+        {
+            if ( timer == timer_func(&Connection::DeleteTimer) )
+                type = 'D';
+            else if ( timer == timer_func(&Connection::InactivityTimer) )
+                type = 'I';
+            else if ( timer == timer_func(&Connection::StatusUpdateTimer) )
+                type = 'S';
+            else if ( timer == timer_func(&Connection::RemoveConnectionTimer) )
+                type = 'R';
+            else
+                assert("Unkown timer type" && false);
+        }
+        ar & type;
+        if (Archive::is_loading::value)
+        {
+            switch(type)
+            {
+            case 'D':
+                timer = timer_func(&Connection::DeleteTimer);
+                break;
+            case'I':
+                timer = timer_func(&Connection::InactivityTimer);
+                break;
+            case 'S':
+                timer = timer_func(&Connection::StatusUpdateTimer);
+                break;
+            case 'R':
+                timer = timer_func(&Connection::RemoveConnectionTimer);
+                break;
+            default:
+                assert("Unkown timer type" && false);
+            }
+        }
+
+        ar & do_expire;
+    }
+template void ConnectionTimer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void ConnectionTimer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 unsigned int Connection::total_connections = 0;
 unsigned int Connection::current_connections = 0;
 unsigned int Connection::external_connections = 0;
@@ -156,6 +216,9 @@ Connection::Connection(NetSessions* s, HashKey* k, double t, const ConnID* id,
 	++current_connections;
 	++total_connections;
 
+        //INFO_PRINT("FAST in Conn.cc: current connections %d", current_connections);
+        //INFO_PRINT("FAST in Conn.cc: total connections %d", total_connections);
+
 	TimerMgr::Tag* tag = current_iosrc->GetCurrentTag();
 	conn_timer_mgr = tag ? new TimerMgr::Tag(*tag) : 0;
 
@@ -175,13 +238,29 @@ Connection::Connection(NetSessions* s, HashKey* k, double t, const ConnID* id,
 		ADD_TIMER(&Connection::RemoveConnectionTimer, 1e20, 1,
 				TIMER_REMOVE_CONNECTION);
 		}
+
+    moved = false; // Flag to indicate object has moved
+
+    // initialize pthread here
+    assert(0 == pthread_mutex_init(&lock, NULL));
 	}
 
+Connection::Connection()
+    {
+        persistent = 0;
+        moved = false; // Flag to indicate object has moved
+        // initialize pthread here
+        assert(0 == pthread_mutex_init(&lock, NULL));
+    }
+
 Connection::~Connection()
 	{
-	if ( ! finished )
+	if ( ! finished && !moved )
 		reporter->InternalError("Done() not called before destruction of Connection");
 
+    // destroy mutex
+    pthread_mutex_destroy(&lock);
+
 	CancelTimers();
 
 	if ( conn_val )
@@ -966,3 +1045,120 @@ void Connection::CheckFlowLabel(bool is_orig, uint32 flow_label)
 	else
 		saw_first_resp_packet = 1;
 	}
+
+void Connection::Moved()
+    {
+    moved = true;
+    if (root_analyzer)
+    { root_analyzer->Moved(); }
+    }
+
+BOOST_CLASS_EXPORT_GUID(Connection,"Connection")
+template<class Archive>
+void Connection::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:Connection:%d",__FILE__,__LINE__);
+
+        // Serialize BroObj
+        ar & boost::serialization::base_object<BroObj>(*this);
+
+        // Special handling of sessions field
+        if (Archive::is_loading::value)
+        { sessions = ::sessions; }
+
+        ar & key; 
+
+        // Special handling of conn_timer_mgr
+        if (!Archive::is_loading::value)
+        {
+            if (conn_timer_mgr)
+            {
+                // Use local conn_timer_mgr
+            }
+            else
+            {
+                // Use global conn_timer_mgr
+            }
+        }
+        //ar & conn_timer_mgr; // Not sure if this should be included
+        if (Archive::is_loading::value) { conn_timer_mgr = NULL; } //TMPHACK
+        //ar & timers; // Not sure if this should be included
+        ar &  orig_addr;
+        ar &  resp_addr;
+        ar &  orig_port; 
+        ar &  resp_port; 
+        ar &  proto;
+        ar &  orig_flow_label; 
+        ar &  resp_flow_label; 
+        ar &  start_time; 
+        ar &  last_time; 
+        ar &  inactivity_timeout; 
+
+        // Special handling of conn_val field
+        if (Archive::is_loading::value) 
+        { 
+            // Set conn_val to NULL, so it is rebuilt if needed
+            conn_val = NULL; 
+        } 
+    
+        // Special handling of login_conn field
+        bool has_login_conn = false;
+        if (!Archive::is_loading::value)
+        { has_login_conn = (true && login_conn); }
+        ar & has_login_conn;
+        if (Archive::is_loading::value)
+        { login_conn = has_login_conn ? (LoginConn*) this : 0; }
+
+//        ar &  encapsulation; //Beware: this is a vector of related conns //REINCLUDE
+        if (Archive::is_loading::value) { encapsulation = NULL; } //TMPHACK
+        ar &  suppress_event; 
+
+        // Special handling of bit fields
+        unsigned int bitfields = 0;
+        if (!Archive::is_loading::value)
+        {
+            bitfields |= (installed_status_timer << 0);
+            bitfields |= (timers_canceled << 1);
+            bitfields |= (is_active << 2); 
+            bitfields |= (skip << 3);
+            bitfields |= (weird << 4);
+            bitfields |= (finished << 5);
+            bitfields |= (record_packets << 6);
+            bitfields |= (record_contents << 7);
+            bitfields |= (persistent << 8);
+            bitfields |= (record_current_packet << 9);
+            bitfields |= (record_current_content << 10);
+            bitfields |= (saw_first_orig_packet << 11);
+            bitfields |= (saw_first_resp_packet << 12);
+        }
+        ar & bitfields;
+        if (Archive::is_loading::value)
+        {
+            installed_status_timer = (bitfields >> 0) & 0x1;
+            timers_canceled = (bitfields >> 1) & 0x1;
+            is_active = (bitfields >> 2) & 0x1; 
+            skip = (bitfields >> 3) & 0x1;
+            weird = (bitfields >> 4) & 0x1;
+            finished = (bitfields >> 5) & 0x1;
+            record_packets = (bitfields >> 6) & 0x1;
+            record_contents = (bitfields >> 7) & 0x1;
+            persistent = (bitfields >> 8) & 0x1;
+            record_current_packet = (bitfields >> 9) & 0x1;
+            record_current_content = (bitfields >> 10) & 0x1;
+            saw_first_orig_packet = (bitfields >> 11) & 0x1;
+            saw_first_resp_packet = (bitfields >> 12) & 0x1;
+        }
+
+        ar & history;
+        ar & hist_seen;
+        ar & root_analyzer;
+        ar & primary_PIA;
+        ar & uid;
+        SERIALIZE_PRINT("\t\tConnection:Done");
+    }
+template void Connection::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void Connection::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/Conn.h b/src/Conn.h
index 782d41a..9bb1af8 100644
--- a/src/Conn.h
+++ b/src/Conn.h
@@ -14,6 +14,7 @@
 #include "AnalyzerTags.h"
 #include "IPAddr.h"
 #include "TunnelEncapsulation.h"
+#include <boost/serialization/access.hpp>
 
 class Connection;
 class ConnectionTimer;
@@ -23,6 +24,7 @@ class RuleHdrTest;
 class Specific_RE_Matcher;
 class TransportLayerAnalyzer;
 class RuleEndpointState;
+class PIA;
 
 typedef enum {
 	NUL_IN_LINE,
@@ -256,11 +258,26 @@ public:
 		{ return encapsulation; }
 
 	void CheckFlowLabel(bool is_orig, uint32 flow_label);
+	
+    Connection();
+
+    void Moved();
+    bool HasMoved() { return moved; }
+
+    // manipulation methods for dirty marker
+    bool isDirty() { return dirty; }
+    void setDirty(bool dirtyVal) { dirty = dirtyVal; }
+    int dirtyBackoff() { return dirty_backoff; }
+    void setDirtyBackoff(int dirtyBackoff) { dirty_backoff = dirtyBackoff; } 
+    int getGetOpId() { return getOpId; }
+    void setGetOpId(int opId) { getOpId = opId; }
+    void initLock() { assert(0 == pthread_mutex_init(&lock, NULL)); /* = PTHREAD_MUTEX_INITIALIZER; */ }
+	uint32_t getOpId; /* last SDMBN get call that returned this */
+    // keep a lock per connection
+    pthread_mutex_t lock;
 
 protected:
 
-	Connection()	{ persistent = 0; }
-
 	// Add the given timer to expire at time t.  If do_expire
 	// is true, then the timer is also evaluated when Bro terminates,
 	// otherwise not.
@@ -318,6 +335,16 @@ protected:
 	PIA* primary_PIA;
 
 	uint64 uid;	// Globally unique connection ID.
+
+    bool moved;
+
+    // mark a connection as dirty
+    bool dirty;
+    int dirty_backoff;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class ConnectionTimer : public Timer {
@@ -340,6 +367,10 @@ protected:
 	Connection* conn;
 	timer_func timer;
 	int do_expire;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #define ADD_TIMER(timer, t, do_expire, type) \
diff --git a/src/ConnSizeAnalyzer.cc b/src/ConnSizeAnalyzer.cc
index a1b892f..03c21c3 100644
--- a/src/ConnSizeAnalyzer.cc
+++ b/src/ConnSizeAnalyzer.cc
@@ -5,6 +5,9 @@
 
 #include "ConnSizeAnalyzer.h"
 #include "TCP.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 
 
@@ -86,3 +89,21 @@ void ConnSize_Analyzer::FlipRoles()
 	resp_pkts = tmp;
 	}
 
+BOOST_CLASS_EXPORT_GUID(ConnSize_Analyzer,"ConnSize_Analyzer")
+template<class Archive>
+void ConnSize_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize Analyzer
+        ar & boost::serialization::base_object<Analyzer>(*this);
+
+        ar & orig_bytes;
+        ar & resp_bytes;
+        ar & orig_pkts;
+        ar & resp_pkts;
+    }
+template void ConnSize_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void ConnSize_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/ConnSizeAnalyzer.h b/src/ConnSizeAnalyzer.h
index 1fdd57b..a0c9ee3 100644
--- a/src/ConnSizeAnalyzer.h
+++ b/src/ConnSizeAnalyzer.h
@@ -6,6 +6,7 @@
 
 #include "Analyzer.h"
 #include "NetVar.h"
+#include <boost/serialization/access.hpp>
 
 
 class ConnSize_Analyzer : public Analyzer {
@@ -34,6 +35,12 @@ protected:
 	uint64_t resp_bytes;
 	uint64_t orig_pkts;
 	uint64_t resp_pkts;
+    
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    ConnSize_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff --git a/src/ContentLine.cc b/src/ContentLine.cc
index 5601694..c8cc989 100644
--- a/src/ContentLine.cc
+++ b/src/ContentLine.cc
@@ -2,6 +2,11 @@
 
 #include "ContentLine.h"
 #include "TCP.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include "SDMBNlocal.h"
 
 ContentLine_Analyzer::ContentLine_Analyzer(Connection* conn, bool orig)
 : TCP_SupportAnalyzer(AnalyzerTag::ContentLine, conn, orig)
@@ -23,6 +28,9 @@ void ContentLine_Analyzer::InitState()
 	skip_deliveries = 0;
 	skip_partial = 0;
 	buf = 0;
+    offset = 0;
+    buf_len = 0;
+    last_char = 0;
 	seq_delivered_in_lines = 0;
 	skip_pending = 0;
 	seq = 0;
@@ -332,3 +340,61 @@ void ContentLine_Analyzer::SkipBytes(int64_t length)
 	seq_to_skip = SeqDelivered() + length;
 	}
 
+BOOST_CLASS_EXPORT_GUID(ContentLine_Analyzer,"ContentLine_Analyzer")
+template<class Archive>
+void ContentLine_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize TCP_SupportAnalyzer
+        ar & boost::serialization::base_object<TCP_SupportAnalyzer>(*this);
+
+        ar & buf_len;
+
+        // Special handling of buffer
+        if (!Archive::is_loading::value)
+        { 
+            if (buf_len > 0)
+            { ar & boost::serialization::make_binary_object(buf, buf_len); }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (buf_len > 0)
+            {
+                buf = new u_char[buf_len];
+                ar & boost::serialization::make_binary_object(buf, buf_len);
+            }
+            else
+            { buf = 0; }
+        }
+
+        ar & offset;
+        ar & last_char;
+        ar & seq;
+        ar & seq_to_skip;
+        ar & seq_delivered_in_lines;
+        ar & skip_pending;
+        ar & plain_delivery_length;
+        ar & is_plain;
+        ar & skip_deliveries;
+
+        // Special handling of bit fields
+        unsigned int bitfields = 0;
+        if (!Archive::is_loading::value)
+        {
+            bitfields |= (flag_NULs << 0);
+            bitfields |= (CR_LF_as_EOL << 1);
+            bitfields |= (skip_partial << 3);
+        }
+        ar & bitfields;
+        if (Archive::is_loading::value)
+        {
+            flag_NULs = (bitfields >> 0) & 0x1;
+            CR_LF_as_EOL = (bitfields >> 1) & 0x3;
+            skip_partial = (bitfields >> 3) & 0x1;
+        }
+    }
+template void ContentLine_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void ContentLine_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/ContentLine.h b/src/ContentLine.h
index 5e9f019..d64edda 100644
--- a/src/ContentLine.h
+++ b/src/ContentLine.h
@@ -4,6 +4,7 @@
 #define CONTENTLINE_H
 
 #include "TCP.h"
+#include <boost/serialization/access.hpp>
 
 #define CR_as_EOL 1
 #define LF_as_EOL 2
@@ -102,6 +103,28 @@ protected:
 
 	// Whether to skip partial conns.
 	unsigned int skip_partial:1;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    ContentLine_Analyzer() 
+    {
+        buf_len = 0;
+        offset = 0;
+        last_char = 0;
+        flag_NULs = 0;
+        CR_LF_as_EOL = (CR_as_EOL | LF_as_EOL);
+        skip_deliveries = 0;
+        skip_partial = 0;
+        buf = 0;
+        seq_delivered_in_lines = 0;
+        skip_pending = 0;
+        seq = 0;
+        seq_to_skip = 0;
+        plain_delivery_length = 0;
+        is_plain = 0;
+    }; // Dummy default constructor for serialization
 };
 
 #endif
diff --git a/src/DNS.cc b/src/DNS.cc
index a3b0b62..a1be3a6 100644
--- a/src/DNS.cc
+++ b/src/DNS.cc
@@ -11,6 +11,11 @@
 #include "DNS.h"
 #include "Sessions.h"
 #include "Event.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include "SDMBNlocal.h"
 
 DNS_Interpreter::DNS_Interpreter(Analyzer* arg_analyzer)
 	{
@@ -859,6 +864,18 @@ void DNS_Interpreter::SendReplyOrRejectEvent(DNS_MsgInfo* msg,
 	analyzer->ConnectionEvent(event, vl);
 	}
 
+BOOST_CLASS_EXPORT_GUID(DNS_Interpreter,"DNS_Interpreter")
+template<class Archive>
+void DNS_Interpreter::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & analyzer; 
+    }
+template void DNS_Interpreter::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void DNS_Interpreter::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
 
 DNS_MsgInfo::DNS_MsgInfo(DNS_RawMsgHdr* hdr, int arg_is_query)
 	{
@@ -1079,6 +1096,37 @@ void Contents_DNS::DeliverStream(int len, const u_char* data, bool orig)
 		DeliverStream(len - n, data + n, orig);
 	}
 
+BOOST_CLASS_EXPORT_GUID(Contents_DNS,"Contents_DNS")
+template<class Archive>
+void Contents_DNS::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize TCP_SupportAnalyzer
+        ar & boost::serialization::base_object<TCP_SupportAnalyzer>(*this);
+
+        ar & interp;
+        ar & buf_n;
+        ar & buf_len;
+
+        // Special handling of buffer
+        if (!Archive::is_loading::value)
+        { ar & boost::serialization::make_binary_object(msg_buf, buf_len); }
+        if (Archive::is_loading::value)
+        {
+            msg_buf = (u_char*)malloc(buf_len);
+            assert(msg_buf != NULL);
+            ar & boost::serialization::make_binary_object(msg_buf, buf_len);
+        }
+
+        ar & msg_size;
+        ar & state;
+    }
+template void Contents_DNS::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void Contents_DNS::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 DNS_Analyzer::DNS_Analyzer(Connection* conn)
 : TCP_ApplicationAnalyzer(AnalyzerTag::DNS, conn)
 	{
@@ -1165,3 +1213,25 @@ void DNS_Analyzer::ExpireTimer(double t)
 		ADD_ANALYZER_TIMER(&DNS_Analyzer::ExpireTimer,
 				t + dns_session_timeout, 1, TIMER_DNS_EXPIRE);
 	}
+
+BOOST_CLASS_EXPORT_GUID(DNS_Analyzer,"DNS_Analyzer")
+template<class Archive>
+void DNS_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:DNS_Analyzer:%d",__FILE__,__LINE__);
+
+        // Serialize TransportLayerAnalyzer
+        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
+
+        ar & interp;
+        ar & contents_dns_orig;
+        ar & contents_dns_resp;
+        ar & did_session_done;
+        SERIALIZE_PRINT("DNS_Analyzer:Done");
+    }
+template void DNS_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar,
+        const unsigned int file_version);
+template void DNS_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar,
+        const unsigned int file_version);
diff --git a/src/DNS.h b/src/DNS.h
index 83ca809..44ddc0d 100644
--- a/src/DNS.h
+++ b/src/DNS.h
@@ -5,6 +5,7 @@
 
 #include "TCP.h"
 #include "binpac_bro.h"
+#include <boost/serialization/access.hpp>
 
 typedef enum {
 	DNS_OP_QUERY = 0,		///< standard query
@@ -218,6 +219,12 @@ protected:
 					BroString* question_name);
 
 	Analyzer* analyzer;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    DNS_Interpreter() {}; // Dummy default constructor for serialization
 };
 
 
@@ -248,6 +255,12 @@ protected:
 	int buf_len;		///< size of msg_buf
 	int msg_size;		///< expected size of message
 	TCP_DNS_state state;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    Contents_DNS() {}; // Dummy default constructor for serialization
 };
 
 // Works for both TCP and UDP.
@@ -280,6 +293,12 @@ protected:
 	Contents_DNS* contents_dns_orig;
 	Contents_DNS* contents_dns_resp;
 	int did_session_done;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    DNS_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 // FIXME: Doesn't really fit into new analyzer structure. What to do?
diff --git a/src/FTP.cc b/src/FTP.cc
index 588348e..5b5dfec 100644
--- a/src/FTP.cc
+++ b/src/FTP.cc
@@ -8,6 +8,9 @@
 #include "FTP.h"
 #include "NVT.h"
 #include "Event.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 FTP_Analyzer::FTP_Analyzer(Connection* conn)
 : TCP_ApplicationAnalyzer(AnalyzerTag::FTP, conn)
@@ -166,3 +169,21 @@ void FTP_Analyzer::DeliverStream(int length, const u_char* data, bool orig)
 	ConnectionEvent(f, vl);
 	}
 
+BOOST_CLASS_EXPORT_GUID(FTP_Analyzer,"FTP_Analyzer")
+template<class Archive>
+void FTP_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize TCP_ApplicationAnalyzer 
+        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
+
+        ar & nvt_orig;
+        ar & nvt_resp;
+        ar & pending_reply;
+        ar & auth_requested;
+    }
+template void FTP_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void FTP_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/FTP.h b/src/FTP.h
index 4ef6c44..2522830 100644
--- a/src/FTP.h
+++ b/src/FTP.h
@@ -5,6 +5,7 @@
 
 #include "NVT.h"
 #include "TCP.h"
+#include <boost/serialization/access.hpp>
 
 class FTP_Analyzer : public TCP_ApplicationAnalyzer {
 public:
@@ -28,6 +29,10 @@ protected:
 	NVT_Analyzer* nvt_resp;
 	uint32 pending_reply;	// code associated with multi-line reply, or 0
 	string auth_requested;	// AUTH method requested
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff --git a/src/File.cc b/src/File.cc
index 3b9f3be..3089b19 100644
--- a/src/File.cc
+++ b/src/File.cc
@@ -29,6 +29,11 @@
 #include "Serializer.h"
 #include "Event.h"
 #include "Reporter.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include "SDMBNlocal.h"
 
 // Timer which on dispatching rotates the file.
 class RotateTimer : public Timer {
@@ -708,6 +713,7 @@ void BroFile::InitEncrypt(const char* keyfile)
 
 	int buf_size = MIN_BUFFER_SIZE + EVP_CIPHER_block_size(cipher_type);
 	cipher_buffer = new unsigned char[buf_size];
+    cipher_size = buf_size;
 	}
 
 void BroFile::FinishEncrypt()
@@ -974,3 +980,122 @@ bool BroFile::DoUnserialize(UnserialInfo* info)
 
 	return true;
 	}
+
+BOOST_CLASS_EXPORT_GUID(BroFile,"BroFile")
+template<class Archive>
+void BroFile::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:BroFile:%d",__FILE__,__LINE__);
+        // Serialize BroObj
+        ar & boost::serialization::base_object<BroObj>(*this);
+
+        //ar & f; //FIXME
+        if (Archive::is_loading::value) { f = NULL; } //TMPHACK
+        ar & t;
+
+        // Special handling of name
+        int name_size;
+        if (!Archive::is_loading::value)
+        {
+            if (name)
+            { name_size = strlen(name); }
+            else
+            { name_size = 0; }
+        }
+        ar & name_size;
+        if (!Archive::is_loading::value)
+        { 
+            if (name_size > 0)
+            { ar & boost::serialization::make_binary_object(name, name_size); }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (name_size > 0)
+            {
+                name = new char[name_size];
+                ar & boost::serialization::make_binary_object(name, name_size);
+            }
+            else
+            { name = NULL; }
+        }
+
+        // Special handling of access
+        int access_size;
+        if (!Archive::is_loading::value)
+        {
+            if (access)
+            { access_size = strlen(access); }
+            else
+            { access_size = 0; }
+        }
+        ar & access_size;
+        if (!Archive::is_loading::value)
+        { 
+            if (access_size > 0)
+            { 
+                ar & boost::serialization::make_binary_object(access,
+                        access_size); 
+            }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (access_size > 0)
+            {
+                access = new char[access_size];
+                ar & boost::serialization::make_binary_object(access,
+                       access_size);
+            }
+            else
+            { access = NULL; }
+        }
+
+        ar & is_in_cache;
+        ar & is_open;
+        ar & okay_to_manage;
+        ar & position;
+        ar & next;
+        ar & prev;
+        ar & attrs;
+        ar & rotate_interval;
+        ar & buffered;
+        ar & rotate_size;
+        ar & current_size;
+        //ar & rotate_timer; //FIXME
+        if (Archive::is_loading::value) { rotate_timer = NULL; } //TMPHACK
+        ar & open_time;
+        ar & dont_rotate;
+        ar & print_hook;
+        ar & raw_output;
+        //ar & pub_key; //FIXME
+        if (Archive::is_loading::value) { pub_key = NULL; } //TMPHACK
+        //ar & cipher_ctx; //FIXME
+        if (Archive::is_loading::value) { cipher_ctx = NULL; } //TMPHACK
+
+        // Special handling of cipher_buffer
+        ar & cipher_size;
+        if (!Archive::is_loading::value)
+        { 
+            if (cipher_size > 0)
+            { 
+                ar & boost::serialization::make_binary_object(cipher_buffer,
+                        cipher_size); 
+            }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (cipher_size > 0)
+            {
+                cipher_buffer = new u_char[cipher_size];
+                ar & boost::serialization::make_binary_object(cipher_buffer,
+                       cipher_size);
+            }
+            else
+            { cipher_buffer = NULL; }
+        }
+    }
+template void BroFile::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void BroFile::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/File.h b/src/File.h
index 37f8448..b5864af 100644
--- a/src/File.h
+++ b/src/File.h
@@ -7,6 +7,7 @@
 #include "util.h"
 #include "Obj.h"
 #include "Attr.h"
+#include <boost/serialization/access.hpp>
 
 # ifdef NEED_KRB5_H
 #  include <krb5.h>
@@ -159,7 +160,11 @@ protected:
 
 	static const int MIN_BUFFER_SIZE = 1024;
 	unsigned char* cipher_buffer;
+    int cipher_size;
 
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff --git a/src/FileAnalyzer.cc b/src/FileAnalyzer.cc
index d4064e8..c53d113 100644
--- a/src/FileAnalyzer.cc
+++ b/src/FileAnalyzer.cc
@@ -2,6 +2,9 @@
 
 #include "FileAnalyzer.h"
 #include "Reporter.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 magic_t File_Analyzer::magic = 0;
 magic_t File_Analyzer::magic_mime = 0;
@@ -76,3 +79,20 @@ void File_Analyzer::InitMagic(magic_t* magic, int flags)
 		*magic = 0;
 		}
 	}
+
+BOOST_CLASS_EXPORT_GUID(File_Analyzer,"File_Analyzer")
+template<class Archive>
+void File_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize TCP_ApplicationAnalyzer
+        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
+
+        ar & buffer;
+        ar & buffer_len;
+    }
+template void File_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void File_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/FileAnalyzer.h b/src/FileAnalyzer.h
index dcf9d22..bd37803 100644
--- a/src/FileAnalyzer.h
+++ b/src/FileAnalyzer.h
@@ -4,6 +4,7 @@
 #define FILEANALYZER_H
 
 #include "TCP.h"
+#include <boost/serialization/access.hpp>
 
 #include <magic.h>
 
@@ -33,6 +34,10 @@ protected:
 
 	static magic_t magic;
 	static magic_t magic_mime;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff --git a/src/HTTP.cc b/src/HTTP.cc
index 9d9f01b..7de6cfc 100644
--- a/src/HTTP.cc
+++ b/src/HTTP.cc
@@ -12,6 +12,11 @@
 #include "HTTP.h"
 #include "Event.h"
 #include "MIME.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/vector.hpp>
+#include "SDMBNlocal.h"
 
 const bool DEBUG_http = false;
 
@@ -462,6 +467,32 @@ void HTTP_Entity::SubmitAllHeaders()
 		}
 	}
 
+BOOST_CLASS_EXPORT_GUID(HTTP_Entity,"HTTP_Entity")
+template<class Archive>
+void HTTP_Entity::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:HTTP_Entity:%d\n",__FILE__,__LINE__);
+        // Serialize MIME_Entity
+        ar & boost::serialization::base_object<MIME_Entity>(*this);
+
+        ar & http_message;
+        ar & chunked_transfer_state;
+        ar & content_length;
+        ar & expect_data_length;
+        ar & expect_body;
+        ar & body_length;
+        ar & header_length;
+        ar & deliver_body;
+        ar & encoding;
+        ar & zip;
+    }
+template void HTTP_Entity::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void HTTP_Entity::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 HTTP_Message::HTTP_Message(HTTP_Analyzer* arg_analyzer,
 				ContentLine_Analyzer* arg_cl, bool arg_is_orig,
 				int expect_body, int64_t init_header_length)
@@ -475,6 +506,8 @@ HTTP_Message::HTTP_Message(HTTP_Analyzer* arg_analyzer,
 	top_level = new HTTP_Entity(this, 0, expect_body);
 	BeginEntity(top_level);
 
+    buffer_offset = 0;
+    buffer_size = 0;
 	data_buffer = 0;
 	total_buffer_size = 0;
 
@@ -704,7 +737,7 @@ void HTTP_Message::DeliverEntityData()
 	{
 	if ( http_entity_data )
 		{
-		const BroString* entity_data = 0;
+		BroString* entity_data = 0;
 
 		if ( data_buffer && buffer_offset > 0 )
 			{
@@ -786,6 +819,43 @@ void HTTP_Message::Weird(const char* msg)
 	analyzer->Weird(msg);
 	}
 
+
+BOOST_CLASS_EXPORT_GUID(HTTP_Message,"HTTP_Message")
+template<class Archive>
+void HTTP_Message::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:HTTP_Message:%d\n",__FILE__,__LINE__);
+
+        // (De)serialize buffers first, otherwise we run into problems 
+        // deserializing data_buf_data in MIME_Entity due to circular
+        // dependencies between HTTP_Message, MIME_Message, HTTP_Entity, and
+        // MIME_Entit.
+        ar & buffers;
+        ar & data_buffer;
+
+        // Serialize MIME_Message
+        ar & boost::serialization::base_object<MIME_Message>(*this);
+
+        ar & analyzer;
+        ar & content_line;
+        //ar & buffers;
+        ar & total_buffer_size;
+        ar & buffer_offset;
+        ar & buffer_size;
+        //ar & data_buffer;
+        ar & start_time;
+        ar & body_length;
+        ar & header_length;
+        ar & content_gap_length;
+        ar & current_entity;
+    }
+template void HTTP_Message::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void HTTP_Message::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 HTTP_Analyzer::HTTP_Analyzer(Connection* conn)
 	: TCP_ApplicationAnalyzer(AnalyzerTag::HTTP, conn)
 	{
@@ -800,7 +870,8 @@ HTTP_Analyzer::HTTP_Analyzer(Connection* conn)
 	reply_state = EXPECT_REPLY_LINE;
 
 	request_ongoing = 0;
-	request_method = request_URI = 0;
+	request_method = 0;
+    request_URI = 0;
 	unescaped_URI = 0;
 
 	reply_ongoing = 0;
@@ -1338,7 +1409,9 @@ void HTTP_Analyzer::RequestMade(const int interrupted, const char* msg)
 	Unref(unescaped_URI);
 	Unref(request_URI);
 
-	request_method = request_URI = unescaped_URI = 0;
+	request_method = 0;
+    request_URI = 0;
+    unescaped_URI = 0;
 
 	num_request_lines = 0;
 
@@ -1713,6 +1786,43 @@ void HTTP_Analyzer::SkipEntityData(int is_orig)
 		msg->SkipEntityData();
 	}
 
+BOOST_CLASS_EXPORT_GUID(HTTP_Analyzer,"HTTP_Analyzer")
+template<class Archive>
+void HTTP_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize TCP_ApplicationAnalyzer 
+        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
+
+        ar & request_state;
+        ar & reply_state;
+        ar & num_requests;
+        ar & num_replies;
+        ar & num_request_lines;
+        ar & num_reply_lines;
+        ar & request_version;
+        ar & reply_version;
+        ar & keep_alive;
+        ar & connection_close;
+        ar & request_ongoing;
+        ar & reply_ongoing;
+        ar & request_method;
+        ar & request_URI;
+        ar & unescaped_URI;
+        //ar & unanswered_requests; //FIXME
+        ar & reply_code;
+        ar & reply_reason_phrase;
+        ar & content_line_orig;
+        ar & content_line_resp;
+        ar & request_message;
+        ar & reply_message;
+    }
+template void HTTP_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void HTTP_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 int is_reserved_URI_char(unsigned char ch)
 	{ // see RFC 2396 (definition of URI)
 	return strchr(";/?:@&=+$,", ch) != 0;
diff --git a/src/HTTP.h b/src/HTTP.h
index c9d8ae5..7587e6d 100644
--- a/src/HTTP.h
+++ b/src/HTTP.h
@@ -9,6 +9,7 @@
 #include "binpac_bro.h"
 #include "ZIP.h"
 #include "IPAddr.h"
+#include <boost/serialization/access.hpp>
 
 enum CHUNKED_TRANSFER_STATE {
 	NON_CHUNKED_TRANSFER,
@@ -20,6 +21,8 @@ enum CHUNKED_TRANSFER_STATE {
 	EXPECT_NOTHING,
 };
 
+typedef enum { IDENTITY, GZIP, COMPRESS, DEFLATE } HTTPEncoding;
+
 class HTTP_Entity;
 class HTTP_Message;
 class HTTP_Analyzer;
@@ -53,7 +56,7 @@ protected:
 	int64_t body_length;
 	int64_t header_length;
 	int deliver_body;
-	enum { IDENTITY, GZIP, COMPRESS, DEFLATE } encoding;
+	HTTPEncoding encoding;
 	ZIP_Analyzer* zip;
 
 	MIME_Entity* NewChildEntity() { return new HTTP_Entity(http_message, this, 1); }
@@ -67,6 +70,12 @@ protected:
 
 	void SubmitHeader(MIME_Header* h);
 	void SubmitAllHeaders();
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    HTTP_Entity() {}; // Dummy default constructor for serialization
 };
 
 enum {
@@ -115,12 +124,33 @@ public:
 	void Weird(const char* msg);
 	bool IsOrig()	{ return is_orig; }
 
+    int GetBufferDiff(char *buf) 
+    { 
+        if (0 == data_buffer)
+            {
+            if (0 == buffers.size())
+            { return -1; }
+            return buf - (char *)buffers.back()->Bytes();
+            }
+        return buf - (char *)data_buffer->Bytes();
+    }
+    char* GetBuffer(int diff)
+    { 
+        if (0 == data_buffer)
+            {
+            if (0 == buffers.size())
+            { return NULL; }
+            return (char *)buffers.back()->Bytes() + diff;
+            }
+        return (char *)data_buffer->Bytes() + diff; 
+    }
+
 protected:
 	HTTP_Analyzer* analyzer;
 	ContentLine_Analyzer* content_line;
 	bool is_orig;
 
-	vector<const BroString*> buffers;
+	vector<BroString*> buffers;
 
 	// Controls the total buffer size within http_entity_data_delivery_size.
 	int total_buffer_size;
@@ -143,6 +173,25 @@ protected:
 	void DeliverEntityData();
 
 	Val* BuildMessageStat(const int interrupted, const char* msg);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    HTTP_Message() { 
+        analyzer = 0;
+        content_line = 0;
+        is_orig = 0;
+        total_buffer_size = 0;
+        buffer_offset = 0;
+        buffer_size = 0;
+    //    data_buffer = 0; 
+        start_time = 0;
+        body_length = 0;
+        header_length = 0;
+        content_gap_length = 0;
+        current_entity = 0; 
+    }; // Dummy default constructor for serialization
 };
 
 class HTTP_Analyzer : public TCP_ApplicationAnalyzer {
@@ -227,7 +276,7 @@ protected:
 	int connection_close;
 	int request_ongoing, reply_ongoing;
 
-	Val* request_method;
+	StringVal* request_method;
 
 	// request_URI is in the original form (may contain '%<hex><hex>'
 	// sequences).
@@ -246,6 +295,12 @@ protected:
 
 	HTTP_Message* request_message;
 	HTTP_Message* reply_message;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    HTTP_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 extern int is_reserved_URI_char(unsigned char ch);
diff --git a/src/Hash.cc b/src/Hash.cc
index 7873e39..d4da19b 100644
--- a/src/Hash.cc
+++ b/src/Hash.cc
@@ -18,6 +18,10 @@
 #include "config.h"
 
 #include "Hash.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
 
 #include "H3.h"
 const H3<hash_t, UHASH_KEY_SIZE>* h3;
@@ -36,6 +40,7 @@ HashKey::HashKey(bro_int_t i)
 	size = sizeof(i);
 	hash = HashBytes(key, size);
 	is_our_dynamic = 0;
+    type = HASH_KEY_TYPE_INT;
 	}
 
 HashKey::HashKey(bro_uint_t u)
@@ -45,6 +50,7 @@ HashKey::HashKey(bro_uint_t u)
 	size = sizeof(u);
 	hash = HashBytes(key, size);
 	is_our_dynamic = 0;
+    type = HASH_KEY_TYPE_INT;
 	}
 
 HashKey::HashKey(uint32 u)
@@ -54,6 +60,7 @@ HashKey::HashKey(uint32 u)
 	size = sizeof(u);
 	hash = HashBytes(key, size);
 	is_our_dynamic = 0;
+    type = HASH_KEY_TYPE_UINT;
 	}
 
 HashKey::HashKey(const uint32 u[], int n)
@@ -62,6 +69,7 @@ HashKey::HashKey(const uint32 u[], int n)
 	key = (void*) u;
 	hash = HashBytes(key, size);
 	is_our_dynamic = 0;
+    type = HASH_KEY_TYPE_NONE;
 	}
 
 HashKey::HashKey(double d)
@@ -76,6 +84,7 @@ HashKey::HashKey(double d)
 	size = sizeof(d);
 	hash = HashBytes(key, size);
 	is_our_dynamic = 0;
+    type = HASH_KEY_TYPE_DOUBLE;
 	}
 
 HashKey::HashKey(const void* p)
@@ -85,6 +94,7 @@ HashKey::HashKey(const void* p)
 	size = sizeof(p);
 	hash = HashBytes(key, size);
 	is_our_dynamic = 0;
+    type = HASH_KEY_TYPE_PTR;
 	}
 
 HashKey::HashKey(const char* s)
@@ -93,6 +103,7 @@ HashKey::HashKey(const char* s)
 	key = (void*) s;
 	hash = HashBytes(key, size);
 	is_our_dynamic = 0;
+    type = HASH_KEY_TYPE_NONE;
 	}
 
 HashKey::HashKey(const BroString* s)
@@ -101,6 +112,7 @@ HashKey::HashKey(const BroString* s)
 	key = (void*) s->Bytes();
 	hash = HashBytes(key, size);
 	is_our_dynamic = 0;
+    type = HASH_KEY_TYPE_NONE;
 	}
 
 HashKey::HashKey(int copy_key, void* arg_key, int arg_size)
@@ -117,6 +129,7 @@ HashKey::HashKey(int copy_key, void* arg_key, int arg_size)
 		key = arg_key;
 
 	hash = HashBytes(key, size);
+    type = HASH_KEY_TYPE_NONE;
 	}
 
 HashKey::HashKey(const void* arg_key, int arg_size, hash_t arg_hash)
@@ -125,6 +138,7 @@ HashKey::HashKey(const void* arg_key, int arg_size, hash_t arg_hash)
 	hash = arg_hash;
 	key = CopyKey(arg_key, size);
 	is_our_dynamic = 1;
+    type = HASH_KEY_TYPE_NONE;
 	}
 
 HashKey::HashKey(const void* arg_key, int arg_size, hash_t arg_hash,
@@ -134,6 +148,7 @@ HashKey::HashKey(const void* arg_key, int arg_size, hash_t arg_hash,
 	hash = arg_hash;
 	key = const_cast<void*>(arg_key);
 	is_our_dynamic = 0;
+    type = HASH_KEY_TYPE_NONE;
 	}
 
 HashKey::HashKey(const void* bytes, int arg_size)
@@ -142,6 +157,7 @@ HashKey::HashKey(const void* bytes, int arg_size)
 	key = CopyKey(bytes, size);
 	hash = HashBytes(key, size);
 	is_our_dynamic = 1;
+    type = HASH_KEY_TYPE_NONE;
 	}
 
 void* HashKey::TakeKey()
@@ -175,3 +191,72 @@ hash_t HashKey::HashBytes(const void* bytes, int size)
 	hmac_md5(size, (const unsigned char*) bytes, (unsigned char*) digest);
 	return digest[0];
 	}
+
+BOOST_CLASS_EXPORT_GUID(HashKey,"HashKey")
+template<class Archive>
+void HashKey::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & size;
+        ar & type;
+
+        // Special handling of void * pointer to key
+        if (!Archive::is_loading::value)
+        {
+            switch(type)
+            {
+            case HASH_KEY_TYPE_INT:
+                ar & key_u.i;
+                break;
+            case HASH_KEY_TYPE_UINT:
+                ar & key_u.u32;
+                break;
+            case HASH_KEY_TYPE_DOUBLE:
+                ar & key_u.d;
+                break;
+            case HASH_KEY_TYPE_PTR:
+            case HASH_KEY_TYPE_NONE:
+                char *ptr = (char *)key;
+                ar & boost::serialization::make_binary_object(ptr, size);
+                break;
+            }
+        }
+        if (Archive::is_loading::value)
+        {
+            switch(type)
+            {
+            case HASH_KEY_TYPE_INT:
+                ar & key_u.i;
+                key = (void*) &key_u;
+                break;
+            case HASH_KEY_TYPE_UINT:
+                ar & key_u.u32;
+                key = (void*) &key_u;
+                break;
+            case HASH_KEY_TYPE_DOUBLE:
+                ar & key_u.d;
+                key = (void*) &key_u;
+                break;
+            case HASH_KEY_TYPE_PTR:
+            case HASH_KEY_TYPE_NONE:
+                char *ptr = new char[size];
+                is_our_dynamic = true; // Force deallocation when destroyed
+                ar & boost::serialization::make_binary_object(ptr, size);
+                if (HASH_KEY_TYPE_PTR == type)
+                { 
+                    key_u.p = (void *)ptr; 
+                    key = (void*) &key_u;
+                }
+                else if (HASH_KEY_TYPE_NONE == type)
+                { key = (void *)ptr; }
+                break;
+            }
+        }
+        
+        ar & hash;
+    }
+template void HashKey::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void HashKey::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/Hash.h b/src/Hash.h
index 00db53d..17cba2b 100644
--- a/src/Hash.h
+++ b/src/Hash.h
@@ -7,6 +7,8 @@
 
 #include "BroString.h"
 
+#include <boost/serialization/access.hpp>
+
 #define UHASH_KEY_SIZE 36
 
 typedef uint64 hash_t;
@@ -18,6 +20,14 @@ typedef enum {
 #define NUM_HASH_KEYS (int(HASH_KEY_STRING) + 1)
 } HashKeyTag;
 
+typedef enum {
+    HASH_KEY_TYPE_INT,
+    HASH_KEY_TYPE_UINT,
+    HASH_KEY_TYPE_DOUBLE,
+    HASH_KEY_TYPE_PTR,
+    HASH_KEY_TYPE_NONE
+} HashKeyType;
+
 class HashKey {
 public:
 	HashKey(bro_int_t i);
@@ -82,6 +92,14 @@ protected:
 	void* key;
 	int is_our_dynamic;
 	int size, hash;
+
+    HashKeyType type;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    HashKey() {}; // Dummy default constructor for serialization
 };
 
 extern void init_hash_function();
diff --git a/src/ICMP.cc b/src/ICMP.cc
index b9b4e89..ed54f8a 100644
--- a/src/ICMP.cc
+++ b/src/ICMP.cc
@@ -10,6 +10,9 @@
 #include "ICMP.h"
 
 #include <netinet/icmp6.h>
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 ICMP_Analyzer::ICMP_Analyzer(Connection* c)
 : TransportLayerAnalyzer(AnalyzerTag::ICMP, c)
@@ -835,6 +838,29 @@ VectorVal* ICMP_Analyzer::BuildNDOptionsVal(int caplen, const u_char* data)
 	return vv;
 	}
 
+BOOST_CLASS_EXPORT_GUID(ICMP_Analyzer,"ICMP_Analyzer")
+template<class Archive>
+void ICMP_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        printf("%s:ICMP_Analyzer:%d",__FILE__,__LINE__);
+
+        // Serialize TransportLayerAnalyzer
+        ar & boost::serialization::base_object<TransportLayerAnalyzer>(*this);
+
+        ar & icmp_conn_val;
+        ar & type;
+        ar & code;
+        ar & request_len;
+        ar & reply_len;
+//        //ar & matcher_state; //FIXME
+    }
+template void ICMP_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void ICMP_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 int ICMP4_counterpart(int icmp_type, int icmp_code, bool& is_one_way)
 	{
 	is_one_way = false;
diff --git a/src/ICMP.h b/src/ICMP.h
index 1e30b7f..06bea75 100644
--- a/src/ICMP.h
+++ b/src/ICMP.h
@@ -4,6 +4,7 @@
 #define icmp_h
 
 #include "Analyzer.h"
+#include <boost/serialization/access.hpp>
 
 typedef enum {
 	ICMP_INACTIVE,	// no packet seen
@@ -87,6 +88,10 @@ protected:
 
 private:
 	void UpdateEndpointVal(RecordVal* endp, int is_orig);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 // Returns the counterpart type to the given type (e.g., the counterpart
diff --git a/src/ID.cc b/src/ID.cc
index a70aa3f..dbb2313 100644
--- a/src/ID.cc
+++ b/src/ID.cc
@@ -14,6 +14,11 @@
 #include "PersistenceSerializer.h"
 #include "Scope.h"
 #include "Traverse.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include "SDMBNlocal.h"
 
 ID::ID(const char* arg_name, IDScope arg_scope, bool arg_is_export)
 	{
@@ -767,3 +772,59 @@ void ID::UpdateValID()
 	}
 #endif
 
+BOOST_CLASS_EXPORT_GUID(ID,"ID")
+template<class Archive>
+void ID::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:ID:%d",__FILE__,__LINE__);
+        // Serialize BroObj
+        ar & boost::serialization::base_object<BroObj>(*this);
+
+        // Special handling of name
+        int name_len; 
+        if (!Archive::is_loading::value)
+        {
+            if (NULL == name)
+            { name_len = 0; }
+            else
+            { name_len = strlen(name) + 1; }
+        }
+        ar & name_len;
+        if (!Archive::is_loading::value)
+        { 
+            if (name_len > 0)
+            { 
+                ar & boost::serialization::make_binary_object((void *)name,
+                        name_len); 
+            }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (name_len > 0)
+            {
+                name = new char[name_len];
+                ar & boost::serialization::make_binary_object(
+                        const_cast<char * &>(name), name_len);
+            }
+            else
+            { name = NULL; }
+        }
+
+        ar & scope;
+        ar & is_export;
+        ar & type;
+        ar & is_const;
+        ar & is_enum_const;
+        ar & is_type;
+        ar & offset;
+        ar & val;
+        ar & attrs;
+        ar & infer_return_type;
+        ar & weak_ref;
+    }
+template void ID::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void ID::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/ID.h b/src/ID.h
index 9c1f56e..7e11c46 100644
--- a/src/ID.h
+++ b/src/ID.h
@@ -8,6 +8,7 @@
 #include "StateAccess.h"
 #include "TraverseTypes.h"
 #include <string>
+#include <boost/serialization/access.hpp>
 
 class Val;
 class SerialInfo;
@@ -118,6 +119,10 @@ protected:
 
 	bool infer_return_type;
 	bool weak_ref;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff --git a/src/IPAddr.cc b/src/IPAddr.cc
index 0ba5589..f0c9cde 100644
--- a/src/IPAddr.cc
+++ b/src/IPAddr.cc
@@ -7,6 +7,9 @@
 #include "Conn.h"
 #include "DPM.h"
 #include "bro_inet_ntop.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 const uint8_t IPAddr::v4_mapped_prefix[12] = { 0, 0, 0, 0,
                                                0, 0, 0, 0,
@@ -230,6 +233,19 @@ string IPAddr::PtrName() const
 		}
 	}
 
+BOOST_CLASS_EXPORT_GUID(IPAddr,"IPAddr")
+template<class Archive>
+void IPAddr::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & in6.s6_addr;
+    }
+template void IPAddr::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void IPAddr::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 IPPrefix::IPPrefix(const in4_addr& in4, uint8_t length)
 	: prefix(in4), length(96 + length)
 	{
@@ -284,3 +300,16 @@ string IPPrefix::AsString() const
 	return prefix.AsString() +"/" + l;
 	}
 
+BOOST_CLASS_EXPORT_GUID(IPPrefix,"IPPrefix")
+template<class Archive>
+void IPPrefix::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & prefix;
+        ar & length; 
+    }
+template void IPPrefix::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void IPPrefix::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/IPAddr.h b/src/IPAddr.h
index f664f64..6e0d6e6 100644
--- a/src/IPAddr.h
+++ b/src/IPAddr.h
@@ -12,6 +12,7 @@
 #include "util.h"
 #include "Type.h"
 #include "threading/SerialTypes.h"
+#include <boost/serialization/access.hpp>
 
 struct ConnID;
 class ExpectedConn;
@@ -351,6 +352,8 @@ public:
 	friend HashKey* BuildExpectedConnHashKey(const ExpectedConn& c);
 
 	unsigned int MemoryAllocation() const { return padded_sizeof(*this); }
+	
+    in6_addr in6; // IPv6 or v4-to-v6-mapped address
 
 private:
 	friend class IPPrefix;
@@ -363,9 +366,10 @@ private:
 	 */
 	void Init(const std::string& s);
 
-	in6_addr in6; // IPv6 or v4-to-v6-mapped address
-
 	static const uint8_t v4_mapped_prefix[12]; // top 96 bits of v4-mapped-addr
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 inline IPAddr::IPAddr(Family family, const uint32_t* bytes, ByteOrder order)
@@ -603,6 +607,10 @@ public:
 private:
 	IPAddr prefix;	// We store it as an address with the non-prefix bits masked out via Mask().
 	uint8_t length;	// The bit length of the prefix relative to full IPv6 addr.
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff --git a/src/List.cc b/src/List.cc
index 9a1af3f..14bfc73 100644
--- a/src/List.cc
+++ b/src/List.cc
@@ -5,6 +5,10 @@
 
 #include "List.h"
 #include "util.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include "SDMBNlocal.h"
 
 static const int DEFAULT_CHUNK_SIZE = 10;
 
@@ -230,3 +234,23 @@ int BaseList::member_pos(ent e) const
 
 	return (i == length()) ? -1 : i;
 	}
+
+BOOST_CLASS_EXPORT_GUID(BaseList,"BaseList")
+template<class Archive>
+void BaseList::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:BaseList:%d",__FILE__,__LINE__);
+
+        // Do not serialize ent -- this is handled by classes which inherit 
+        // from BaseList 
+
+        ar & chunk_size;
+        ar & max_entries;
+        ar & num_entries;
+    }
+template void BaseList::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void BaseList::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/List.h b/src/List.h
index bf87ade..335ac21 100644
--- a/src/List.h
+++ b/src/List.h
@@ -22,6 +22,7 @@
 
 #include <stdarg.h>
 #include "util.h"
+#include <boost/serialization/access.hpp>
 
 typedef void* ent;
 typedef int (*list_cmp_func)(const void* v1, const void* v2);
@@ -82,6 +83,10 @@ protected:
 	int chunk_size;		// increase size by this amount when necessary
 	int max_entries;
 	int num_entries;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 	};
 
 
@@ -178,7 +183,38 @@ PList(type)::PList(type)(type* ep1 ...) : BaseList()			\
 	      ep = va_arg(ap,type*) )					\
 		append(ep);						\
 	resize();							\
-	}
+	}   \
+\
+BOOST_CLASS_EXPORT_GUID(PList(type),"PList(type)")  \
+template<class Archive> \
+void PList(type)::serialize(Archive & ar, const unsigned int version)   \
+    {   \
+        SERIALIZE_PRINT("%s:PList(type):%d",__FILE__,__LINE__); \
+        ar & boost::serialization::base_object<BaseList>(*this);    \
+        if (!Archive::is_loading::value)    \
+        {   \
+            for (int i = 0; i < num_entries; i++)   \
+            {   \
+                type *item = (type *)(entry[i]);    \
+                ar & item;  \
+            }   \
+        }   \
+        if (Archive::is_loading::value) \
+        {   \
+            for (int i = 0; i < num_entries; i++)   \
+            {   \
+                type *item; \
+                ar & item;  \
+                enttry[i] = (ent)(item);    \
+            }   \
+        }   \
+    }   \
+template void BaseList::serialize<boost::archive::text_oarchive>(   \
+        boost::archive::text_oarchive & ar,     \
+        const unsigned int file_version);   \
+template void BaseList::serialize<boost::archive::text_iarchive>(   \
+        boost::archive::text_iarchive & ar,     \
+        const unsigned int file_version);
 
 
 #define declare(metatype,type) metatype ## declare (type)
diff --git a/src/MIME.cc b/src/MIME.cc
index 4a7c026..91825e5 100644
--- a/src/MIME.cc
+++ b/src/MIME.cc
@@ -5,6 +5,11 @@
 #include "Event.h"
 #include "Reporter.h"
 #include "digest.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/vector.hpp>
+#include <boost/serialization/binary_object.hpp>
 
 // Here are a few things to do:
 //
@@ -157,6 +162,19 @@ BroString* MIME_Multiline::get_concatenated_line()
 	return line;
 	}
 
+BOOST_CLASS_EXPORT_GUID(MIME_Multiline,"MIME_Multiline")
+template<class Archive>
+void MIME_Multiline::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & buffer;
+        ar & line; 
+    }
+template void MIME_Multiline::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void MIME_Multiline::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
 
 MIME_Header::MIME_Header(MIME_Multiline* hl)
 	{
@@ -225,6 +243,23 @@ data_chunk_t MIME_Header::get_value_after_token()
 	return rest_value;
 	}
 
+BOOST_CLASS_EXPORT_GUID(MIME_Header,"MIME_Header")
+template<class Archive>
+void MIME_Header::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & lines;
+        //ar & name; //FIXME
+        //ar & value; //FIXME
+        //ar & value_token; //FIXME
+        //ar & rest_value; //FIXME
+    }
+template void MIME_Header::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void MIME_Header::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 MIME_Entity::MIME_Entity(MIME_Message* output_message, MIME_Entity* parent_entity)
 	{
 	init();
@@ -939,6 +974,56 @@ void MIME_Entity::DebugPrintHeaders()
 #endif
 	}
 
+BOOST_CLASS_EXPORT_GUID(MIME_Entity,"MIME_Entity")
+template<class Archive>
+void MIME_Entity::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & in_header;
+        ar & end_of_data;
+        ar & current_header_line; 
+        ar & current_field_type;
+        ar & need_to_parse_parameters;
+        ar & content_type_str;
+        ar & content_subtype_str;
+        ar & content_encoding_str;
+        ar & multipart_boundary;
+        ar & content_type;
+        ar & content_subtype;
+        ar & content_encoding;
+        ar & headers;
+        ar & parent;
+        ar & current_child_entity;
+        ar & base64_decoder;
+        ar & data_buf_length;
+        ar & data_buf_offset;
+        ar & message;
+
+        // Special handling of data_buf_data
+        int diff;
+        if (!Archive::is_loading::value)
+        { 
+            if (0 == data_buf_data || 0 == message)
+            { diff = -1; }
+            else
+            { diff = message->GetBufferDiff(data_buf_data); }
+        }
+        ar & diff;
+        if (Archive::is_loading::value)
+        {
+            if (diff < 0)
+            { data_buf_data = 0; }
+            else
+            { data_buf_data = message->GetBuffer(diff); }
+        }
+
+    }
+template void MIME_Entity::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void MIME_Entity::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 RecordVal* MIME_Message::BuildHeaderVal(MIME_Header* h)
 	{
 	RecordVal* header_record = new RecordVal(mime_header_rec);
@@ -966,6 +1051,21 @@ TableVal* MIME_Message::BuildHeaderTable(MIME_HeaderList& hlist)
 	return t;
 	}
 
+BOOST_CLASS_EXPORT_GUID(MIME_Message,"MIME_Message")
+template<class Archive>
+void MIME_Message::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & analyzer;
+        ar & top_level;
+        ar & finished;
+    }
+template void MIME_Message::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void MIME_Message::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 MIME_Mail::MIME_Mail(Analyzer* mail_analyzer, int buf_size)
 : MIME_Message(mail_analyzer)
 	{
@@ -985,7 +1085,7 @@ MIME_Mail::MIME_Mail(Analyzer* mail_analyzer, int buf_size)
 		length = max_chunk_length;
 
 	buffer_start = data_start = 0;
-	data_buffer = new BroString(1, new u_char[length+1], length);
+	data_buffer = new BroString(1, new u_char[length+1], length); // FIXME?
 
 	if ( mime_content_hash )
 		{
@@ -1014,7 +1114,7 @@ void MIME_Mail::Done()
 		val_list* vl = new val_list;
 		vl->append(analyzer->BuildConnVal());
 		vl->append(new Val(content_hash_length, TYPE_COUNT));
-		vl->append(new StringVal(new BroString(1, digest, 16)));
+		vl->append(new StringVal(new BroString(1, digest, 16))); // FIXME?
 		analyzer->ConnectionEvent(mime_content_hash, vl);
 		}
 
@@ -1193,6 +1293,31 @@ void MIME_Mail::SubmitEvent(int event_type, const char* detail)
 		}
 	}
 
+BOOST_CLASS_EXPORT_GUID(MIME_Mail,"MIME_Mail")
+template<class Archive>
+void MIME_Mail::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize MIME_Message
+        ar & boost::serialization::base_object<MIME_Message>(*this);
+
+        ar & min_overlap_length;
+        ar & max_chunk_length;
+        ar & buffer_start;
+        ar & data_start;
+        ar & buffer_offset;
+        ar & compute_content_hash;
+        ar & content_hash_length;
+        //ar & md5_hash; //FIXME
+        ar & entity_content; 
+        ar & all_content;
+        ar & data_buffer;
+    }
+template void MIME_Mail::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void MIME_Mail::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
 
 int strcasecmp_n(data_chunk_t s, const char* t)
 	{
diff --git a/src/MIME.h b/src/MIME.h
index ffff30e..bdbe1b3 100644
--- a/src/MIME.h
+++ b/src/MIME.h
@@ -11,6 +11,7 @@ using namespace std;
 #include "Base64.h"
 #include "BroString.h"
 #include "Analyzer.h"
+#include <boost/serialization/access.hpp>
 
 // MIME: Multipurpose Internet Mail Extensions
 // Follows RFC 822 & 2822 (Internet Mail), 2045-2049 (MIME)
@@ -57,8 +58,12 @@ public:
 	BroString* get_concatenated_line();
 
 protected:
-	vector<const BroString*> buffer;
+	vector<BroString*> buffer;
 	BroString* line;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class MIME_Header {
@@ -79,6 +84,12 @@ protected:
 	data_chunk_t name;
 	data_chunk_t value;
 	data_chunk_t value_token, rest_value;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    MIME_Header() {}; // Dummy default constructor for serialization
 };
 
 
@@ -170,6 +181,33 @@ protected:
 	int data_buf_offset;
 
 	MIME_Message* message;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    MIME_Entity() 
+    {
+        in_header = 0;
+        end_of_data = 0;
+        current_header_line = 0;
+        current_field_type = 0;
+        need_to_parse_parameters = 0;
+        content_type_str = 0;
+        content_subtype_str = 0;
+        content_encoding_str = 0;
+        multipart_boundary = 0;
+        content_type = 0;
+        content_subtype = 0;
+        content_encoding = 0;
+        parent = 0;
+        current_child_entity = 0;
+        base64_decoder = 0;
+        data_buf_length = 0;
+        data_buf_data = 0;
+        data_buf_offset = 0;
+        message = 0;
+    }; // Dummy default constructor for serialization
 };
 
 // The reason I separate MIME_Message as an abstract class is to
@@ -214,6 +252,9 @@ public:
 	virtual int RequestBuffer(int* plen, char** pbuf) = 0;
 	virtual void SubmitEvent(int event_type, const char* detail) = 0;
 
+    virtual int GetBufferDiff(char *buf) = 0;
+    virtual char* GetBuffer(int diff) = 0;
+
 protected:
 	Analyzer* analyzer;
 
@@ -222,6 +263,12 @@ protected:
 
 	RecordVal* BuildHeaderVal(MIME_Header* h);
 	TableVal* BuildHeaderTable(MIME_HeaderList& hlist);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    MIME_Message() {}; // Dummy default constructor for serialization
 };
 
 class MIME_Mail : public MIME_Message {
@@ -239,6 +286,9 @@ public:
 	void SubmitAllData();
 	void SubmitEvent(int event_type, const char* detail);
 
+    int GetBufferDiff(char *buf) { return (0 == data_buffer ? -1 : buf - (char *)data_buffer->Bytes()); }
+    char* GetBuffer(int diff) { return (char *)data_buffer->Bytes() + diff; }
+
 protected:
 	int min_overlap_length;
 	int max_chunk_length;
@@ -248,10 +298,18 @@ protected:
 	int compute_content_hash;
 	int content_hash_length;
 	MD5_CTX md5_hash;
-	vector<const BroString*> entity_content;
-	vector<const BroString*> all_content;
+//	vector<const BroString*> entity_content;
+	vector<BroString*> entity_content;
+//	vector<const BroString*> all_content;
+	vector<BroString*> all_content;
 
 	BroString* data_buffer;
+    
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    MIME_Mail() {}; // Dummy default constructor for serialization
 };
 
 
diff --git a/src/NVT.cc b/src/NVT.cc
index 5ba12ac..7f97b45 100644
--- a/src/NVT.cc
+++ b/src/NVT.cc
@@ -8,6 +8,9 @@
 #include "NetVar.h"
 #include "Event.h"
 #include "TCP.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 #define IS_3_BYTE_OPTION(c) (c >= 251 && c <= 254)
 
@@ -701,3 +704,28 @@ void NVT_Analyzer::BadOptionTermination(unsigned int /* code */)
 	Event(bad_option_termination);
 	}
 
+BOOST_CLASS_EXPORT_GUID(NVT_Analyzer,"NVT_Analyzer")
+template<class Archive>
+void NVT_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize ContentLine_Analyzer
+        ar & boost::serialization::base_object<ContentLine_Analyzer>(*this);
+
+        ar & peer;
+        ar & pending_IAC;
+        ar & IAC_pos;
+        ar & is_suboption;
+        ar & last_was_IAC;
+        ar & binary_mode;
+        ar & encrypting_mode;
+        ar & authentication_has_been_accepted;
+        //ar & auth_name; //FIXME
+        //ar & options; //FIXME
+        ar & num_options;
+    }
+template void NVT_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void NVT_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/NVT.h b/src/NVT.h
index 61aa1ef..5bd0c8f 100644
--- a/src/NVT.h
+++ b/src/NVT.h
@@ -4,6 +4,7 @@
 #define nvt_h
 
 #include "ContentLine.h"
+#include <boost/serialization/access.hpp>
 
 
 #define TELNET_OPTION_BINARY 0
@@ -168,6 +169,12 @@ protected:
 
 	TelnetOption* options[NUM_TELNET_OPTIONS];
 	int num_options;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    NVT_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff --git a/src/Net.cc b/src/Net.cc
index 328998b..721e33f 100644
--- a/src/Net.cc
+++ b/src/Net.cc
@@ -314,6 +314,7 @@ void net_packet_dispatch(double t, const struct pcap_pkthdr* hdr,
 			const u_char* pkt, int hdr_size,
 			PktSrc* src_ps, PacketSortElement* pkt_elem)
 	{
+        //printf("\nFAST: I am at the beginning of net_packet_dispatch\n");
 	if ( ! bro_start_network_time )
 		bro_start_network_time = t;
 
@@ -349,7 +350,7 @@ void net_packet_dispatch(double t, const struct pcap_pkthdr* hdr,
 			sp = new SegmentProfiler(sample_logger, "load-samp");
 			}
 		}
-
+ 
 	sessions->DispatchPacket(t, hdr, pkt, hdr_size, src_ps, pkt_elem);
 	mgr.Drain();
 
@@ -387,7 +388,7 @@ int process_packet_sorter(double latest_packet_time)
 		++num_pkts_dispatched;
 		delete pkt_elem;
 		}
-
+        //printf("FAST: number of dispatch packets %d\n", num_pkts_dispatched);
 	return num_pkts_dispatched;
 	}
 
diff --git a/src/Obj.cc b/src/Obj.cc
index 0b82695..48ffee1 100644
--- a/src/Obj.cc
+++ b/src/Obj.cc
@@ -7,6 +7,11 @@
 #include "Obj.h"
 #include "Serializer.h"
 #include "File.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include "SDMBNlocal.h"
 
 Location no_location("<no location>", 0, 0, 0, 0);
 Location start_location("<start uninitialized>", 0, 0, 0, 0);
@@ -85,6 +90,74 @@ bool Location::operator==(const Location& l) const
 		return false;
 	}
 
+BOOST_CLASS_EXPORT_GUID(Location,"Location")
+template<class Archive>
+void Location::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:Location:%d",__FILE__,__LINE__);
+        // Serialize SerialObj?
+        //ar & boost::serialization::base_object<>(*this);
+        
+        // Special handling of filename & delete_data
+        int filename_len;
+        if (!Archive::is_loading::value)
+        { filename_len = strlen(filename)+1; }
+        ar & filename_len;
+        if (!Archive::is_loading::value)
+        { 
+            ar & boost::serialization::make_binary_object((void *)filename, 
+                    filename_len); 
+        }
+        if (Archive::is_loading::value)
+        {
+            filename = new char[filename_len];
+            ar & boost::serialization::make_binary_object(
+                    const_cast<char* &>(filename), filename_len);
+            delete_data = true;
+        }
+
+        SERIALIZE_PRINT("\t\tLocation:%d",__LINE__);
+        ar & first_line;
+        ar & last_line;
+        ar & first_column;
+        ar & last_column;
+        ar & timestamp;
+
+        // Special handling of text 
+        int text_len;
+        if (!Archive::is_loading::value)
+        {
+            if (text)
+            { text_len = strlen(text); }
+            else
+            { text_len = 0; }
+        }
+        ar & text_len;
+        if (!Archive::is_loading::value)
+        { 
+            if (text_len > 0)
+            { ar & boost::serialization::make_binary_object(text, text_len); }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (text_len > 0)
+            {
+                text = new char[text_len];
+                ar & boost::serialization::make_binary_object(text, text_len);
+            }
+            else
+            { text = NULL; }
+        }
+
+        SERIALIZE_PRINT("\t\tLocation:Done");
+    }
+template void Location::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void Location::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 int BroObj::suppress_errors = 0;
 
 BroObj::~BroObj()
@@ -237,6 +310,28 @@ bool BroObj::DoUnserialize(UnserialInfo* info)
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(BroObj,"BroObj")
+template<class Archive>
+void BroObj::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:BroObj:%d",__FILE__,__LINE__);
+        // Serialize SerialObj?
+        //ar & boost::serialization::base_object<>(*this);
+    
+        // Mark object as not in serialization cache
+        if (Archive::is_loading::value) { in_ser_cache = false; }
+
+        ar & location;
+        ar & ref_cnt;
+        SERIALIZE_PRINT("\t\t:BroObj:Done");
+    }
+template void BroObj::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void BroObj::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 void print(const BroObj* obj)
 	{
 	static BroFile fstderr(stderr);
diff --git a/src/Obj.h b/src/Obj.h
index be0d91b..96dfd08 100644
--- a/src/Obj.h
+++ b/src/Obj.h
@@ -8,6 +8,7 @@
 #include "input.h"
 #include "Desc.h"
 #include "SerialObj.h"
+#include <boost/serialization/access.hpp>
 
 class Serializer;
 class SerialInfo;
@@ -61,6 +62,10 @@ public:
 	char* text;
 protected:
 	DECLARE_SERIAL(Location);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #define YYLTYPE yyltype
@@ -186,6 +191,10 @@ private:
 	// If non-zero, do not print runtime errors.  Useful for
 	// speculative evaluation.
 	static int suppress_errors;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 // Prints obj to stderr, primarily for debugging.
diff --git a/src/PIA.cc b/src/PIA.cc
index 9adb4cc..4c32b64 100644
--- a/src/PIA.cc
+++ b/src/PIA.cc
@@ -1,6 +1,10 @@
 #include "PIA.h"
 #include "RuleMatcher.h"
 #include "TCP_Reassembler.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include "SDMBNlocal.h"
 
 PIA::PIA(Analyzer* arg_as_analyzer)
 	{
@@ -129,6 +133,40 @@ void PIA::DoMatch(const u_char* data, int len, bool is_orig, bool bol, bool eol,
 				bol, eol, clear_state);
 	}
 
+BOOST_CLASS_EXPORT_GUID(PIA,"PIA")
+template<class Archive>
+void PIA::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:PIA:%d",__FILE__,__LINE__);
+
+        // Serialize RuleMatcherState
+        ar & boost::serialization::base_object<RuleMatcherState>(*this);
+
+        //ar & pkt_buffer.head //FIXME
+        //ar & pkt_buffer.tail //FIXME
+        ar & pkt_buffer.size;
+        ar & pkt_buffer.state;
+
+        // Special check for analyzer serializability
+        if (!Archive::is_loading::value)
+        {
+            if (as_analyzer != NULL)
+            { assert(sdmbn_can_serialize(as_analyzer->GetTag())); }
+        }
+        SERIALIZE_PRINT("PIA:%d",__LINE__);
+        ar & as_analyzer;
+
+        ar & conn;
+        //ar & current_packet; //FIXME
+        SERIALIZE_PRINT("\t\tPIA:Done");
+    }
+template void PIA::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void PIA::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 void PIA_UDP::ActivateAnalyzer(AnalyzerTag::Tag tag, const Rule* rule)
 	{
 	if ( pkt_buffer.state == MATCHING_ONLY )
@@ -154,6 +192,25 @@ void PIA_UDP::DeactivateAnalyzer(AnalyzerTag::Tag tag)
 	reporter->InternalError("PIA_UDP::Deact not implemented yet");
 	}
 
+BOOST_CLASS_EXPORT_GUID(PIA_UDP,"PIA_UDP")
+template<class Archive>
+void PIA_UDP::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:PIA_UDP:%d",__FILE__,__LINE__);
+
+        // Serialize PIA
+        ar & boost::serialization::base_object<PIA>(*this);
+        // Serialize Analyzer
+        ar & boost::serialization::base_object<Analyzer>(*this);
+        SERIALIZE_PRINT("\t\tPIA_UDP:Done");
+    }
+template void PIA_UDP::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void PIA_UDP::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 //// TCP PIA
 
 PIA_TCP::~PIA_TCP()
@@ -388,3 +445,29 @@ void PIA_TCP::ReplayStreamBuffer(Analyzer* analyzer)
 			analyzer->NextUndelivered(b->seq, b->len, b->is_orig);
 		}
 	}
+
+BOOST_CLASS_EXPORT_GUID(PIA_TCP,"PIA_TCP")
+template<class Archive>
+void PIA_TCP::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:PIA_TCP:%d",__FILE__,__LINE__);
+
+        // Serialize PIA
+        ar & boost::serialization::base_object<PIA>(*this);
+        // Serialize TCP_ApplicationAnalyzer
+        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
+
+        //ar & stream_buffer.head; //FIXME
+        //ar & stream_buffer.tail; //FIXME
+        SERIALIZE_PRINT("\t\tPIA_TCP:%d",__LINE__);
+        ar & stream_buffer.size;
+        ar & stream_buffer.state;
+        ar & stream_mode;
+        SERIALIZE_PRINT("\t\tPIA_TCP:Done");
+    }
+template void PIA_TCP::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void PIA_TCP::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/PIA.h b/src/PIA.h
index 907350b..c7102ae 100644
--- a/src/PIA.h
+++ b/src/PIA.h
@@ -5,6 +5,8 @@
 
 #include "Analyzer.h"
 #include "TCP.h"
+#include <boost/serialization/access.hpp>
+#include <boost/serialization/export.hpp>
 
 class RuleEndpointState;
 
@@ -80,10 +82,16 @@ protected:
 
 	Buffer pkt_buffer;
 
+    PIA() {}; // Dummy default constructor for serialization
+
 private:
 	Analyzer* as_analyzer;
 	Connection* conn;
 	DataBlock current_packet;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 // PIA for UDP.
@@ -113,6 +121,12 @@ protected:
 
 	virtual void ActivateAnalyzer(AnalyzerTag::Tag tag, const Rule* rule);
 	virtual void DeactivateAnalyzer(AnalyzerTag::Tag tag);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+    
+    PIA_UDP() {}; // Dummy default constructor for serialization
 };
 
 // PIA for TCP.  Accepts both packet and stream input (and reassembles
@@ -169,6 +183,12 @@ private:
 	Buffer stream_buffer;
 
 	bool stream_mode;
+    
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    PIA_TCP() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff --git a/src/PktSrc.cc b/src/PktSrc.cc
index 9b974f7..10181d6 100644
--- a/src/PktSrc.cc
+++ b/src/PktSrc.cc
@@ -10,7 +10,7 @@
 #include "Hash.h"
 #include "Net.h"
 #include "Sessions.h"
-
+#include "SDMBNlocal.h"
 
 // ### This needs auto-confing.
 #ifdef HAVE_PCAP_INT_H
@@ -614,6 +614,7 @@ PktDumper::PktDumper(const char* arg_filename, bool arg_append)
 	append = arg_append;
 	dumper = 0;
 
+#ifndef WRITEIFACE
 	// We need a pcap_t with a reasonable link-layer type. We try to get it
 	// from the packet sources. If not available, we fall back to Ethernet.
 	// FIXME: Perhaps we should make this configurable?
@@ -631,6 +632,7 @@ PktDumper::PktDumper(const char* arg_filename, bool arg_append)
 		Error("error for pcap_open_dead");
 		return;
 		}
+#endif
 
 	if ( arg_filename )
 		Open(arg_filename);
@@ -646,13 +648,18 @@ bool PktDumper::Open(const char* arg_filename)
 
 	if ( arg_filename )
 		{
+#ifndef WRITEIFACE
 		if ( dumper && streq(arg_filename, filename) )
+#else
+		if ( live && streq(arg_filename, filename) )
+#endif
 			// Already open.
 			return true;
 
 		safe_strncpy(filename, arg_filename, FNBUF_LEN);
 		}
 
+#ifndef WRITEIFACE
 	if ( dumper )
 		Close();
 
@@ -681,7 +688,6 @@ bool PktDumper::Open(const char* arg_filename)
 			return false;
 			}
 		}
-
 	else
 		{
 		// Old file and we need to append, which, unfortunately,
@@ -695,6 +701,15 @@ bool PktDumper::Open(const char* arg_filename)
 			return false;
 			}
 		}
+#else
+    errbuf[0] = 0;
+    live =  pcap_open_live(filename, 0, 1, 10, errbuf);
+    if ( ! live )
+        {
+        Error(errbuf);
+        return false;
+        }
+#endif
 
 	open_time = network_time;
 	is_error = false;
@@ -703,25 +718,43 @@ bool PktDumper::Open(const char* arg_filename)
 
 bool PktDumper::Close()
 	{
+#ifndef WRITEIFACE
 	if ( dumper )
 		{
 		pcap_dump_close(dumper);
 		dumper = 0;
 		is_error = false;
 		}
+#else
+    if ( live )
+        {
+        pcap_close(live);
+        live = 0;
+        is_error = false;
+        }
+#endif
 
 	return true;
 	}
 
 bool PktDumper::Dump(const struct pcap_pkthdr* hdr, const u_char* pkt)
 	{
+#ifndef WRITEIFACE
 	if ( ! dumper )
+#else
+    if ( ! live )
+#endif
 		return false;
 
 	if ( ! open_time )
 		open_time = network_time;
 
+#ifndef WRITEIFACE
 	pcap_dump((u_char*) dumper, hdr, pkt);
+#else
+	if (pcap_inject(live, pkt, hdr->caplen) < 0)
+        return false;
+#endif
 
 	return true;
 	}
diff --git a/src/PktSrc.h b/src/PktSrc.h
index 70eef4d..0c85fb7 100644
--- a/src/PktSrc.h
+++ b/src/PktSrc.h
@@ -249,7 +249,13 @@ private:
 	bool append;
 	pcap_dumper_t* dumper;
 	pcap_t* pd;
-	double open_time;
+    double open_time;
+
+    // The "live" field is only needed if WRITEIFACE is defined, but 
+    // including the header where it's defined causes compilation errors,
+    // so we just always include the field
+	pcap_t* live;
+
 
 	bool is_error;
 	char errbuf[BRO_PCAP_ERRBUF_SIZE];
diff --git a/src/Reassem.cc b/src/Reassem.cc
index c3c19ff..eef43f2 100644
--- a/src/Reassem.cc
+++ b/src/Reassem.cc
@@ -6,6 +6,11 @@
 
 #include "Reassem.h"
 #include "Serializer.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include "SDMBNlocal.h"
 
 const bool DEBUG_reassem = false;
 
@@ -41,6 +46,42 @@ DataBlock::DataBlock(const u_char* data, int size, int arg_seq,
 	Reassembler::total_size += pad_size(size) + padded_sizeof(DataBlock);
 	}
 
+BOOST_CLASS_EXPORT_GUID(DataBlock,"DataBlock")
+template<class Archive>
+void DataBlock::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:DataBlock:%d",__FILE__,__LINE__);
+
+        ar & next;
+        ar & prev;
+        ar & seq;
+        ar & upper;
+
+        // Special handling of block
+        int size = upper-seq;
+        if (!Archive::is_loading::value)
+        { 
+            if (size > 0)
+            { ar & boost::serialization::make_binary_object(block, size); }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (size > 0)
+            {
+                block = new u_char[size];
+                ar & boost::serialization::make_binary_object(block, size);
+            }
+            else
+            { block = 0; }
+        }
+    }
+template void DataBlock::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void DataBlock::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 unsigned int Reassembler::total_size = 0;
 
 Reassembler::Reassembler(int init_seq, ReassemblerType arg_type)
@@ -310,3 +351,21 @@ bool Reassembler::DoUnserialize(UnserialInfo* info)
 
 	return  true;
 	}
+
+BOOST_CLASS_EXPORT_GUID(Reassembler,"Reassembler")
+template<class Archive>
+void Reassembler::serialize(Archive & ar, const unsigned int version)
+    {
+        //FIXME: Serialize parent BroObj?
+        
+        ar & blocks;
+        ar & last_block;
+        ar & last_reassem_seq;
+        ar & trim_seq;
+    }
+template void Reassembler::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void Reassembler::serialize<boost::archive::text_iarchive>(
+boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/Reassem.h b/src/Reassem.h
index 1f65059..759a594 100644
--- a/src/Reassem.h
+++ b/src/Reassem.h
@@ -5,6 +5,7 @@
 
 #include "Obj.h"
 #include "IPAddr.h"
+#include <boost/serialization/access.hpp>
 
 class DataBlock {
 public:
@@ -19,6 +20,12 @@ public:
 	DataBlock* prev;	// previous block with lower seq #
 	int seq, upper;
 	u_char* block;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    DataBlock() {}; // Dummy default constructor for serialization
 };
 
 
@@ -72,6 +79,11 @@ protected:
 	int trim_seq;	// how far we've trimmed
 
 	static unsigned int total_size;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
 };
 
 inline DataBlock::~DataBlock()
diff --git a/src/RuleMatcher.cc b/src/RuleMatcher.cc
index c9cf1f5..9d5c89c 100644
--- a/src/RuleMatcher.cc
+++ b/src/RuleMatcher.cc
@@ -9,6 +9,9 @@
 #include "Scope.h"
 #include "File.h"
 #include "Reporter.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 // FIXME: Things that are not fully implemented/working yet:
 //
@@ -159,6 +162,28 @@ RuleEndpointState::~RuleEndpointState()
 		delete matched_text[j];
 	}
 
+BOOST_CLASS_EXPORT_GUID(RuleEndpointState,"RuleEndpointState")
+template<class Archive>
+void RuleEndpointState::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & is_orig;
+        ar & analyzer;
+        ar & opposite;
+        //ar & pia; //FIXME
+        //ar & matchers; //FIXME
+        //ar & hdr_tests; //FIXME
+        //ar & matched_by_patterns; //FIXME
+        //ar & matched_test; //FIXME
+        ar & payload_size;
+        //ar & matched_rules; //FIXME
+    }
+template void RuleEndpointState::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void RuleEndpointState::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 RuleMatcher::RuleMatcher(int arg_RE_level)
 	{
 	root = new RuleHdrTest(RuleHdrTest::NOPROT, 0, 0, RuleHdrTest::EQ,
@@ -1244,3 +1269,17 @@ void RuleMatcherState::ClearMatchState(bool orig)
 	if ( resp_match_state )
 		rule_matcher->ClearEndpointState(resp_match_state);
 	}
+
+BOOST_CLASS_EXPORT_GUID(RuleMatcherState,"RuleMatcherState")
+template<class Archive>
+void RuleMatcherState::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & orig_match_state;
+        ar & resp_match_state;
+    }
+template void RuleMatcherState::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void RuleMatcherState::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/RuleMatcher.h b/src/RuleMatcher.h
index 5bba69e..4984963 100644
--- a/src/RuleMatcher.h
+++ b/src/RuleMatcher.h
@@ -13,6 +13,7 @@
 #include "Rule.h"
 #include "RuleAction.h"
 #include "RuleCondition.h"
+#include <boost/serialization/access.hpp>
 
 //#define MATCHER_PRINT_STATS
 
@@ -182,6 +183,12 @@ private:
 	int payload_size;
 
 	int_list matched_rules;		// Rules for which all conditions have matched
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+    
+    RuleEndpointState() {}; // Dummy default constructor for serialization
 };
 
 
@@ -322,6 +329,10 @@ public:
 private:
 	RuleEndpointState* orig_match_state;
 	RuleEndpointState* resp_match_state;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff --git a/src/SDMBNlocal.cc b/src/SDMBNlocal.cc
new file mode 100644
index 0000000..6264d9e
--- /dev/null
+++ b/src/SDMBNlocal.cc
@@ -0,0 +1,30 @@
+#include "SDMBNlocal.h"
+
+int sdmbn_can_serialize(AnalyzerTag::Tag check)
+{
+    switch(check)
+    {
+    case AnalyzerTag::PIA_TCP: //1
+    case AnalyzerTag::PIA_UDP: //2
+    case AnalyzerTag::ICMP: //3
+    case AnalyzerTag::TCP: //4
+    case AnalyzerTag::UDP: //5
+    case AnalyzerTag::DNS: //9
+    case AnalyzerTag::FTP: //11
+    case AnalyzerTag::HTTP: //13
+    case AnalyzerTag::SMTP: //27
+    case AnalyzerTag::SSH: //28
+    case AnalyzerTag::SSL: //34
+    case AnalyzerTag::Teredo: //38
+    case AnalyzerTag::File: //39
+    case AnalyzerTag::ConnSize: //44
+    case AnalyzerTag::ContentLine: //46
+    case AnalyzerTag::NVT: //47
+    case AnalyzerTag::Zip: //48
+        return 1;
+        break;
+    default:
+        fprintf(stderr,"UNHANDLED ANALYZER: %d\n", check);
+        return 0;
+    }
+}
diff --git a/src/SDMBNlocal.h b/src/SDMBNlocal.h
new file mode 100644
index 0000000..bb7d780
--- /dev/null
+++ b/src/SDMBNlocal.h
@@ -0,0 +1,48 @@
+#ifndef _SDMBNLocal_H_
+#define _SDMBNLocal_H_
+
+#include <stdio.h>
+#include "Conn.h"
+#include "AnalyzerTags.h"
+#include <SDMBN.h>
+
+// Enable the define below to output to a device when using the -w option and // a device name (instead of a filename)
+#define WRITEIFACE
+
+///// DEBUGGING MACROS ///////////////////////////////////////////////////////
+//#define SDMBN_SERIALIZE
+
+#define SDMBN_INFO
+//#define SDMBN_ERROR
+
+#ifdef SDMBN_SERIALIZE
+    #define SERIALIZE_PRINT(...) printf(__VA_ARGS__); printf("\n");
+#else
+    #define SERIALIZE_PRINT(...)
+#endif
+
+#ifdef SDMBN_INFO
+    #define INFO_PRINT(...) printf(__VA_ARGS__); printf("\n");
+    #ifndef SDMBN_ERROR
+        #define SDMBN_ERROR
+    #endif
+#else
+    #define INFO_PRINT(...)
+#endif
+
+#ifdef SDMBN_ERROR
+    #define ERROR_PRINT(...) printf(__VA_ARGS__); printf("\n");
+#else
+    #define ERROR_PRINT(...)
+#endif
+
+///// TYPEDEFS ///////////////////////////////////////////////////////////////
+int sdmbn_can_serialize(AnalyzerTag::Tag check);
+
+///// FUNCTION PROTOTYPES ////////////////////////////////////////////////////
+int local_get_perflow(PerflowKey *key, int id, int raiseEvents, SDMBNExt *unused);
+int local_put_perflow(int hashkey, PerflowKey *key, char *state);
+int local_get_shared(int id);
+int local_put_shared(int hashkey, char *state);
+
+#endif
diff --git a/src/SMTP.cc b/src/SMTP.cc
index 85a3bc7..81c41d8 100644
--- a/src/SMTP.cc
+++ b/src/SMTP.cc
@@ -9,6 +9,10 @@
 #include "Event.h"
 #include "ContentLine.h"
 #include "Reporter.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/list.hpp>
 
 #undef SMTP_CMD_DEF
 #define SMTP_CMD_DEF(cmd)	#cmd,
@@ -882,3 +886,31 @@ void SMTP_Analyzer::EndData()
 		mail = 0;
 		}
 	}
+
+BOOST_CLASS_EXPORT_GUID(SMTP_Analyzer,"SMTP_Analyzer")
+template<class Archive>
+void SMTP_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize TCP_ApplicationAnalyzer
+        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
+
+        ar & orig_is_sender;
+        ar & expect_sender;
+        ar & expect_recver;
+        ar & state;
+        ar & last_replied_cmd;
+        ar & first_cmd;
+        ar & pending_reply;
+        ar & pipelining;
+        ar & pending_cmd_q;
+        ar & skip_data;
+        ar & orig_record_contents;
+        ar & line_after_gap;
+        ar & mail;
+    }
+template void SMTP_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void SMTP_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/SMTP.h b/src/SMTP.h
index 5b15dc4..3113797 100644
--- a/src/SMTP.h
+++ b/src/SMTP.h
@@ -8,6 +8,7 @@ using namespace std;
 
 #include "TCP.h"
 #include "MIME.h"
+#include <boost/serialization/access.hpp>
 
 
 #undef SMTP_CMD_DEF
@@ -94,6 +95,12 @@ protected:
 					// after a gap
 
 	MIME_Mail* mail;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    SMTP_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff --git a/src/SSH.cc b/src/SSH.cc
index 3a8f468..67a60ef 100644
--- a/src/SSH.cc
+++ b/src/SSH.cc
@@ -8,6 +8,9 @@
 #include "SSH.h"
 #include "Event.h"
 #include "ContentLine.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 SSH_Analyzer::SSH_Analyzer(Connection* c)
 : TCP_ApplicationAnalyzer(AnalyzerTag::SSH, c)
@@ -99,3 +102,20 @@ void SSH_Analyzer::DeliverStream(int length, const u_char* data, bool is_orig)
 
 	ConnectionEvent(event, vl);
 	}
+
+BOOST_CLASS_EXPORT_GUID(SSH_Analyzer,"SSH_Analyzer")
+template<class Archive>
+void SSH_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize TCP_ApplicationAnalyzer
+        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
+
+        ar & orig;
+        ar & resp;
+    }
+template void SSH_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void SSH_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/SSH.h b/src/SSH.h
index ccdcd76..7908c04 100644
--- a/src/SSH.h
+++ b/src/SSH.h
@@ -5,6 +5,7 @@
 
 #include "TCP.h"
 #include "ContentLine.h"
+#include <boost/serialization/access.hpp>
 
 class SSH_Analyzer : public TCP_ApplicationAnalyzer {
 public:
@@ -21,6 +22,12 @@ public:
 private:
 	ContentLine_Analyzer* orig;
 	ContentLine_Analyzer* resp;
+    
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    SSH_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff --git a/src/SSL.cc b/src/SSL.cc
index 4658bbb..f42e30f 100644
--- a/src/SSL.cc
+++ b/src/SSL.cc
@@ -2,6 +2,9 @@
 #include "TCP_Reassembler.h"
 #include "Reporter.h"
 #include "util.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 SSL_Analyzer::SSL_Analyzer(Connection* c)
 : TCP_ApplicationAnalyzer(AnalyzerTag::SSL, c)
@@ -58,3 +61,20 @@ void SSL_Analyzer::Undelivered(int seq, int len, bool orig)
 	had_gap = true;
 	interp->NewGap(orig, len);
 	}
+
+BOOST_CLASS_EXPORT_GUID(SSL_Analyzer,"SSL_Analyzer")
+template<class Archive>
+void SSL_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize TCP_ApplicationAnalyzer
+        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
+        //ar & interp; //FIXME
+        if (Archive::is_loading::value) { interp = new binpac::SSL::SSL_Conn(this); } //TMPHACK
+        ar & had_gap;
+    }
+template void SSL_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void SSL_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/SSL.h b/src/SSL.h
index d0ef164..8994a8f 100644
--- a/src/SSL.h
+++ b/src/SSL.h
@@ -3,6 +3,7 @@
 
 #include "TCP.h"
 #include "ssl_pac.h"
+#include <boost/serialization/access.hpp>
 
 class SSL_Analyzer : public TCP_ApplicationAnalyzer {
 public:
@@ -31,6 +32,11 @@ protected:
 	binpac::SSL::SSL_Conn* interp;
 	bool had_gap;
 
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    SSL_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff --git a/src/Sessions.cc b/src/Sessions.cc
index 6f42e57..f0d57c3 100644
--- a/src/Sessions.cc
+++ b/src/Sessions.cc
@@ -32,6 +32,12 @@
 #include "PacketSort.h"
 #include "TunnelEncapsulation.h"
 
+extern "C" {
+#include <SDMBN.h>
+}
+#include "SDMBNlocal.h"
+#include <sys/time.h>
+
 // These represent NetBIOS services on ephemeral ports.  They're numbered
 // so that we can use a single int to hold either an actual TCP/UDP server
 // port or one of these.
@@ -164,9 +170,10 @@ void NetSessions::Done()
 	}
 
 void NetSessions::DispatchPacket(double t, const struct pcap_pkthdr* hdr,
-			const u_char* pkt, int hdr_size,
-			PktSrc* src_ps, PacketSortElement* pkt_elem)
+    const u_char* pkt, int hdr_size,
+    PktSrc* src_ps, PacketSortElement* pkt_elem)
 	{
+        //printf("\nFAST: I am the beginning of dispatch\n");
 	const struct ip* ip_hdr = 0;
 	const u_char* ip_data = 0;
 	int proto = 0;
@@ -186,6 +193,7 @@ void NetSessions::DispatchPacket(double t, const struct pcap_pkthdr* hdr,
 		NextPacket(t, hdr, pkt, hdr_size, pkt_elem);
 	else
 		NextPacketSecondary(t, hdr, pkt, hdr_size, src_ps);
+             
 	}
 
 void NetSessions::NextPacket(double t, const struct pcap_pkthdr* hdr,
@@ -198,6 +206,8 @@ void NetSessions::NextPacket(double t, const struct pcap_pkthdr* hdr,
 
 	++num_packets_processed;
 
+        //printf("\nFAST: number of packets processed %d\n",num_packets_processed);
+
 	dump_this_packet = 0;
 
 	if ( record_all_packets )
@@ -209,7 +219,6 @@ void NetSessions::NextPacket(double t, const struct pcap_pkthdr* hdr,
 		// the code below tries to extract the IP header, the
 		// difference here is that header extraction in
 		// PacketSort does not generate Weird events.
-
 		DoNextPacket(t, hdr, pkt_elem->IPHdr(), pkt, hdr_size, 0);
 
 	else
@@ -264,7 +273,31 @@ void NetSessions::NextPacket(double t, const struct pcap_pkthdr* hdr,
 		}
 
 	if ( dump_this_packet && ! record_all_packets )
+#ifndef WRITEIFACE
 		DumpPacket(hdr, pkt);
+#else
+		{
+		// Force packet to be dumped    
+		unsigned char writeablepkt[1514];
+		if (hdr->caplen > 1514)
+			{ 
+			printf("Packet of length %d (%d) is too large\n", hdr->caplen,
+				hdr->len);
+			}
+		else
+			{
+			memcpy(writeablepkt, pkt, hdr->caplen);
+			writeablepkt[6] = 0xAA;
+			writeablepkt[7] = 0xBB;
+			writeablepkt[8] = 0xCC;
+			writeablepkt[9] = 0xDD;
+			writeablepkt[10] = 0xEE;
+			writeablepkt[11] = 0xFF;
+
+			DumpPacket(hdr, writeablepkt);
+			}
+		}
+#endif
 	}
 
 void NetSessions::NextPacketSecondary(double /* t */, const struct pcap_pkthdr* hdr,
@@ -367,10 +400,18 @@ int NetSessions::CheckConnectionTag(Connection* conn)
 	return 1;
 	}
 
+// added to count the packets that were received at the src NF after the
+// move
+int drop_counter = 0;
+
+
 void NetSessions::DoNextPacket(double t, const struct pcap_pkthdr* hdr,
 				const IP_Hdr* ip_hdr, const u_char* const pkt,
 				int hdr_size, const EncapsulationStack* encapsulation)
 	{
+	struct timeval recv_time;
+	gettimeofday(&recv_time,NULL);
+
 	uint32 caplen = hdr->caplen - hdr_size;
 	const struct ip* ip4 = ip_hdr->IP4_Hdr();
 
@@ -625,6 +666,15 @@ void NetSessions::DoNextPacket(double t, const struct pcap_pkthdr* hdr,
 		return;
 	}
 
+	char pkttype[10]; 
+	if (80 == ntohs(id.src_port) || 80 == ntohs(id.dst_port))
+	{ sprintf(pkttype, "HTTP"); }
+	else if (443 == ntohs(id.src_port) || 443 == ntohs(id.dst_port))
+	{ sprintf(pkttype, "TLS"); }
+	else
+	{ sprintf(pkttype, "UNKNOWN"); }
+	sdmbn_notify_packet_received(pkttype, &recv_time);
+
 	HashKey* h = BuildConnIDHashKey(id);
 	if ( ! h )
 		reporter->InternalError("hash computation failed");
@@ -636,13 +686,29 @@ void NetSessions::DoNextPacket(double t, const struct pcap_pkthdr* hdr,
 	conn = (Connection*) d->Lookup(h);
 	if ( ! conn )
 		{
+		printf("[SIGDEBUG] Creating a new connection\n");
+		sdmbn_notify_flow_created();
 		conn = NewConn(h, t, &id, data, proto, ip_hdr->FlowLabel(), encapsulation);
+                //printf("\nFAST: after NewConn init\n");
 		if ( conn )
+			{
+                        //printf("\nFAST: going to initiate lock\n");
+			conn->initLock();
 			d->Insert(h, conn);
+			}
 		}
 	else
 		{
 		// We already know that connection.
+		if(conn->HasMoved()) {
+			printf("[SIGDEBUG] The state of connection has moved\n");
+			drop_counter++;
+			printf("[SIGMOVE] Drop counter = %d\n", drop_counter);
+			}
+		else {
+			printf("[SIGDEBUG] The state is not moved\n"); 
+			}
+
 		int consistent = CheckConnectionTag(conn);
 		if ( consistent < 0 )
 			{
@@ -657,7 +723,9 @@ void NetSessions::DoNextPacket(double t, const struct pcap_pkthdr* hdr,
 				conn->Event(connection_reused, 0);
 
 			Remove(conn);
+			printf("[SIGDEBUG] Removing and creating a new connection in the consistency check clause\n");
 			conn = NewConn(h, t, &id, data, proto, ip_hdr->FlowLabel(), encapsulation);
+                        sdmbn_notify_flow_created(); 
 			if ( conn )
 				d->Insert(h, conn);
 			}
@@ -681,6 +749,26 @@ void NetSessions::DoNextPacket(double t, const struct pcap_pkthdr* hdr,
 	int is_orig = (id.src_addr == conn->OrigAddr()) &&
 			(id.src_port == conn->OrigPort());
 
+        //printf("\nFAST: Before lock assigned\n");
+        pthread_mutex_t conn_lock;
+        pthread_mutex_init(&conn_lock, NULL);
+        pthread_mutex_lock(&conn_lock);
+	//pthread_mutex_lock(&conn->lock);
+        //printf("\nFAST: After lock assgined\n");
+	// If marked as MOVED - raise an event
+	if (conn->HasMoved())
+		{
+		/* NO REDIRECT EVENTS
+		sdmbn_raise_reprocess(conn->getGetOpId(), conn->Key()->Hash(), 
+				(struct pcap_pkthdr *)hdr, (u_char *)pkt);
+				*/
+		/* return to stop further processing, in case of reprocess we will
+		* not return */
+                pthread_mutex_unlock(&conn_lock);
+		//pthread_mutex_unlock(&conn->lock);
+		return;
+		}
+
 	conn->CheckFlowLabel(is_orig, ip_hdr->FlowLabel());
 
 	Val* pkt_hdr_val = 0;
@@ -699,6 +787,8 @@ void NetSessions::DoNextPacket(double t, const struct pcap_pkthdr* hdr,
 				record_packet, record_content,
 			        hdr, pkt, hdr_size);
 
+	//pthread_mutex_unlock(&conn->lock);
+        pthread_mutex_unlock(&conn_lock);
 	if ( f )
 		{
 		// Above we already recorded the fragment in its entirety.
@@ -958,22 +1048,26 @@ void NetSessions::Remove(Connection* c)
 		{
 		c->CancelTimers();
 
-		TCP_Analyzer* ta = (TCP_Analyzer*) c->GetRootAnalyzer();
-		if ( ta && c->ConnTransport() == TRANSPORT_TCP )
+		if (!c->HasMoved())
 			{
-			assert(ta->GetTag() == AnalyzerTag::TCP);
-			TCP_Endpoint* to = ta->Orig();
-			TCP_Endpoint* tr = ta->Resp();
+			TCP_Analyzer* ta = (TCP_Analyzer*) c->GetRootAnalyzer();
+			if ( ta && c->ConnTransport() == TRANSPORT_TCP )
+				{
+				assert(ta->GetTag() == AnalyzerTag::TCP);
+				TCP_Endpoint* to = ta->Orig();
+				TCP_Endpoint* tr = ta->Resp();
 
-			tcp_stats.StateLeft(to->state, tr->state);
+				tcp_stats.StateLeft(to->state, tr->state);
+				}
 			}
 
 		if ( c->IsPersistent() )
 			persistence_serializer->Unregister(c);
+	
+		if (!c->HasMoved())
+			{ c->Done(); }
 
-		c->Done();
-
-		if ( connection_state_remove )
+		if (!c->HasMoved() && connection_state_remove ) 
 			c->Event(connection_state_remove, 0);
 
 		// Zero out c's copy of the key, so that if c has been Ref()'d
@@ -983,17 +1077,17 @@ void NetSessions::Remove(Connection* c)
 
 		switch ( c->ConnTransport() ) {
 		case TRANSPORT_TCP:
-			if ( ! tcp_conns.RemoveEntry(k) )
+			if ( ! tcp_conns.RemoveEntry(k) && !c->HasMoved() )
 				reporter->InternalError("connection missing");
 			break;
 
 		case TRANSPORT_UDP:
-			if ( ! udp_conns.RemoveEntry(k) )
+			if ( ! udp_conns.RemoveEntry(k) && !c->HasMoved() )
 				reporter->InternalError("connection missing");
 			break;
 
 		case TRANSPORT_ICMP:
-			if ( ! icmp_conns.RemoveEntry(k) )
+			if ( ! icmp_conns.RemoveEntry(k) && !c->HasMoved() )
 				reporter->InternalError("connection missing");
 			break;
 
@@ -1001,7 +1095,7 @@ void NetSessions::Remove(Connection* c)
 			reporter->InternalError("unknown transport when removing connection");
 			break;
 		}
-
+		sdmbn_notify_flow_destroyed();
 		Unref(c);
 		delete k;
 		}
@@ -1169,7 +1263,7 @@ Connection* NetSessions::NewConn(HashKey* k, double t, const ConnID* id,
 
 		id = &flip_id;
 		}
-
+        //printf("\nFAST: initiate a new connection\n");
 	Connection* conn = new Connection(this, k, t, id, flow_label, encapsulation);
 	conn->SetTransport(tproto);
 	dpm->BuildInitialAnalyzerTree(tproto, conn, data);
@@ -1182,6 +1276,7 @@ Connection* NetSessions::NewConn(HashKey* k, double t, const ConnID* id,
 
 	if ( new_connection )
 		{
+                //printf("\nFAST: this is truly new connection\n");
 		conn->Event(new_connection, 0);
 
 		if ( external )
@@ -1192,7 +1287,7 @@ Connection* NetSessions::NewConn(HashKey* k, double t, const ConnID* id,
 			conn->ConnectionEvent(connection_external, 0, vl);
 			}
 		}
-
+        //printf("\nFAST: going to exit this method\n");
 	return conn;
 	}
 
diff --git a/src/Sessions.h b/src/Sessions.h
index abaa8b4..39c0482 100644
--- a/src/Sessions.h
+++ b/src/Sessions.h
@@ -185,6 +185,10 @@ public:
 	unsigned int MemoryAllocation();
 	TCPStateStats tcp_stats;	// keeps statistics on TCP states
 
+	PDict(Connection) tcp_conns;
+	PDict(Connection) udp_conns;
+	PDict(Connection) icmp_conns;
+
 protected:
 	friend class RemoteSerializer;
 	friend class ConnCompressor;
@@ -245,9 +249,6 @@ protected:
 			      const EncapsulationStack* encap);
 
 	CompositeHash* ch;
-	PDict(Connection) tcp_conns;
-	PDict(Connection) udp_conns;
-	PDict(Connection) icmp_conns;
 	PDict(FragReassembler) fragments;
 
 	typedef pair<IPAddr, IPAddr> IPPair;
diff --git a/src/TCP.cc b/src/TCP.cc
index 555adf1..9c7cc5c 100644
--- a/src/TCP.cc
+++ b/src/TCP.cc
@@ -9,6 +9,11 @@
 #include "TCP_Reassembler.h"
 #include "OSFinger.h"
 #include "Event.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/list.hpp>
+#include "SDMBNlocal.h"
 
 namespace { // local namespace
 	const bool DEBUG_tcp_data_sent = false;
@@ -1833,6 +1838,64 @@ bool TCP_Analyzer::IsReuse(double t, const u_char* pkt)
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(TCP_Analyzer,"TCP_Analyzer")
+template<class Archive>
+void TCP_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TCP_Analyzer:%d",__FILE__,__LINE__);
+
+        // Serialize TransportLayerAnalyzer
+        ar & boost::serialization::base_object<TransportLayerAnalyzer>(*this);
+
+        SERIALIZE_PRINT("\t\tTCP_Analyzer:%d",__LINE__);
+        ar & orig;
+        SERIALIZE_PRINT("\t\tTCP_Analyzer:%d",__LINE__);
+        ar & resp;
+
+        // Special check for analyzer serializability
+        if (!Archive::is_loading::value)
+        {
+            for (std::list<Analyzer*>::iterator it = packet_children.begin();
+                    it != packet_children.end(); it++)
+            { assert(sdmbn_can_serialize((*it)->GetTag())); }
+        }
+        SERIALIZE_PRINT("\t\tTCP_Analyzer:%d",__LINE__);
+        ar & packet_children;
+        
+        // Special handling of bit fields
+        unsigned int bitfields = 0;
+        if (!Archive::is_loading::value)
+        {
+            bitfields |= (first_packet_seen << 0); // 2 bits
+            bitfields |= (reassembling << 2);
+            bitfields |= (is_partial << 3);
+            bitfields |= (is_active << 4);
+            bitfields |= (finished << 5);
+            bitfields |= (close_deferred << 6);
+            bitfields |= (deferred_gen_event << 7);
+            bitfields |= (seen_first_ACK << 8);
+        }
+        ar & bitfields;
+        if (Archive::is_loading::value)
+        {
+            first_packet_seen = (bitfields >> 0) & 0x3; // 2 bits
+            reassembling = (bitfields >> 2) & 0x1;
+            is_partial = (bitfields >> 3) & 0x1;
+            is_active = (bitfields >> 4) & 0x1;
+            finished = (bitfields >> 5) & 0x1;
+            close_deferred = (bitfields >> 6) & 0x1;
+            deferred_gen_event = (bitfields >> 7) & 0x1;
+            seen_first_ACK = (bitfields >> 8) & 0x1;
+        }
+        SERIALIZE_PRINT("\t\tTCP_Analyzer:Done");
+    }
+template void TCP_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar,
+        const unsigned int file_version);
+template void TCP_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar,
+        const unsigned int file_version);
+
 void TCP_ApplicationAnalyzer::Init()
 	{
 	Analyzer::Init();
@@ -1918,6 +1981,41 @@ void TCP_ApplicationAnalyzer::PacketWithRST()
 		static_cast<TCP_SupportAnalyzer*>(sa)->PacketWithRST();
 	}
 
+BOOST_CLASS_EXPORT_GUID(TCP_ApplicationAnalyzer,"TCP_ApplicationAnalyzer")
+template<class Archive>
+void TCP_ApplicationAnalyzer::serialize(Archive & ar, 
+        const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TCP_ApplicationAnalyzer:%d",__FILE__,__LINE__);
+
+        // Serialize Analyzer
+        ar & boost::serialization::base_object<Analyzer>( *this );
+        
+        SERIALIZE_PRINT("\t\tTCP_ApplicationAnalyzer:%d",__LINE__);
+        ar & tcp; 
+        SERIALIZE_PRINT("\t\tTCP_ApplicationAnalyzer:Done");
+    }
+template void TCP_ApplicationAnalyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar,
+        const unsigned int file_version);
+template void TCP_ApplicationAnalyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar,
+        const unsigned int file_version);
+
+BOOST_CLASS_EXPORT_GUID(TCP_SupportAnalyzer,"TCP_SupportAnalyzer")
+template<class Archive>
+void TCP_SupportAnalyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize SupportAnalyzer
+        ar & boost::serialization::base_object<SupportAnalyzer>(*this);
+    }
+template void TCP_SupportAnalyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TCP_SupportAnalyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 TCPStats_Endpoint::TCPStats_Endpoint(TCP_Endpoint* e)
 	{
 	endp = e;
@@ -2049,6 +2147,28 @@ RecordVal* TCPStats_Endpoint::BuildStats()
 	return stats;
 	}
 
+BOOST_CLASS_EXPORT_GUID(TCPStats_Endpoint,"TCPStats_Endpoint")
+template<class Archive>
+void TCPStats_Endpoint::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & endp;
+        ar & num_pkts;
+        ar & num_rxmit;
+        ar & num_rxmit_bytes;
+        ar & num_in_order;
+        ar & num_OO;
+        ar & num_repl;
+        ar & max_top_seq;
+        ar & last_id;
+        ar & endian_type;
+    }
+template void TCPStats_Endpoint::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar,
+        const unsigned int file_version);
+template void TCPStats_Endpoint::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar,
+        const unsigned int file_version);
+
 TCPStats_Analyzer::TCPStats_Analyzer(Connection* c)
 : TCP_ApplicationAnalyzer(AnalyzerTag::TCPStats, c)
 	{
@@ -2088,3 +2208,20 @@ void TCPStats_Analyzer::DeliverPacket(int len, const u_char* data, bool is_orig,
 	else
 		resp_stats->DataSent(network_time, seq, len, caplen, data, ip, 0);
 	}
+
+BOOST_CLASS_EXPORT_GUID(TCPStats_Analyzer,"TCPStats_Analyzer")
+template<class Archive>
+void TCPStats_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize TCP_ApplicationAnalyzer
+        ar & boost::serialization::base_object<TCP_ApplicationAnalyzer>(*this);
+
+        ar & orig_stats;
+        ar & resp_stats;
+    }
+template void TCPStats_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar,
+        const unsigned int file_version);
+template void TCPStats_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar,
+        const unsigned int file_version);
diff --git a/src/TCP.h b/src/TCP.h
index c84202f..0263699 100644
--- a/src/TCP.h
+++ b/src/TCP.h
@@ -7,6 +7,7 @@
 #include "TCP.h"
 #include "PacketDumper.h"
 #include "IPAddr.h"
+#include <boost/serialization/access.hpp>
 
 // We define two classes here:
 // - TCP_Analyzer is the analyzer for the TCP protocol itself.
@@ -256,6 +257,12 @@ private:
 
 	// Whether we have seen the first ACK from the originator.
 	unsigned int seen_first_ACK: 1;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+    
+    TCP_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 class TCP_ApplicationAnalyzer : public Analyzer {
@@ -312,6 +319,10 @@ protected:
 
 private:
 	TCP_Analyzer* tcp;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class TCP_SupportAnalyzer : public SupportAnalyzer {
@@ -328,6 +339,12 @@ public:
 	virtual void ConnectionFinished(int half_finished)	{ }
 	virtual void ConnectionReset()	{ }
 	virtual void PacketWithRST()	{ }
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+    
+    TCP_SupportAnalyzer() {}; // Dummy default constructor for serialization
 };
 
 
@@ -351,6 +368,12 @@ protected:
 	int max_top_seq;
 	int last_id;
 	int endian_type;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+    
+    TCPStats_Endpoint() {}; // Dummy default constructor for serialization
 };
 
 class TCPStats_Analyzer : public TCP_ApplicationAnalyzer {
@@ -372,6 +395,12 @@ protected:
 
 	TCPStats_Endpoint* orig_stats;
 	TCPStats_Endpoint* resp_stats;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    TCPStats_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff --git a/src/TCP_Endpoint.cc b/src/TCP_Endpoint.cc
index 69c0887..b896b79 100644
--- a/src/TCP_Endpoint.cc
+++ b/src/TCP_Endpoint.cc
@@ -8,6 +8,10 @@
 #include "Event.h"
 #include "File.h"
 #include "Val.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include "SDMBNlocal.h"
 
 TCP_Endpoint::TCP_Endpoint(TCP_Analyzer* arg_analyzer, int arg_is_orig)
 	{
@@ -21,11 +25,13 @@ TCP_Endpoint::TCP_Endpoint(TCP_Analyzer* arg_analyzer, int arg_is_orig)
 	window_scale = 0;
 	window_seq = window_ack_seq = 0;
 	contents_start_seq = 0;
+    FIN_seq = 0;
 	SYN_cnt = FIN_cnt = RST_cnt = 0;
 	did_close = 0;
 	contents_file = 0;
 	tcp_analyzer = arg_analyzer;
 	is_orig = arg_is_orig;
+    hist_last_SYN = hist_last_FIN = hist_last_RST = 0;
 
 	src_addr = is_orig ? tcp_analyzer->Conn()->RespAddr() :
 				tcp_analyzer->Conn()->OrigAddr();
@@ -245,3 +251,47 @@ void TCP_Endpoint::AddHistory(char code)
 	tcp_analyzer->Conn()->AddHistory(code);
 	}
 
+BOOST_CLASS_EXPORT_GUID(TCP_Endpoint,"TCP_Endpoint")
+template<class Archive>
+void TCP_Endpoint::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TCP_Endpoint:%d",__FILE__,__LINE__);
+
+        ar & state;
+        ar & prev_state;
+        ar & peer;
+        ar & contents_processor;
+        ar & tcp_analyzer;
+        ar & contents_file;
+        ar & checksum_base;
+        ar & start_time;
+        ar & last_time;
+        ar & src_addr;
+        ar & dst_addr;
+        ar & window;
+        ar & window_scale;
+        ar & window_ack_seq;
+        ar & window_seq;
+        ar & contents_start_seq;
+        ar & FIN_seq;
+        ar & SYN_cnt;
+        ar & FIN_cnt;
+        ar & RST_cnt;
+        ar & did_close;
+        ar & is_orig;
+        ar & hist_last_SYN;
+        ar & hist_last_FIN;
+        ar & hist_last_RST;
+        ar & start_seq;
+        ar & last_seq;
+        ar & ack_seq;
+        ar & last_seq_high;
+        ar & ack_seq_high;
+        SERIALIZE_PRINT("\t\tTCP_Endpoint:Done");
+    }   
+template void TCP_Endpoint::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TCP_Endpoint::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/TCP_Endpoint.h b/src/TCP_Endpoint.h
index 52a757b..b99bc2d 100644
--- a/src/TCP_Endpoint.h
+++ b/src/TCP_Endpoint.h
@@ -4,6 +4,7 @@
 #define tcpendpoint_h
 
 #include "IPAddr.h"
+#include <boost/serialization/access.hpp>
 
 typedef enum {
 	TCP_ENDPOINT_INACTIVE,	// no SYN (or other packets) seen for this side
@@ -150,6 +151,12 @@ public:
 protected:
 	uint32 start_seq, last_seq, ack_seq;	// in host order
 	uint32 last_seq_high, ack_seq_high;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    TCP_Endpoint() {}; // Dummy default constructor for serialization
 };
 
 #define ENDIAN_UNKNOWN 0
diff --git a/src/TCP_Reassembler.cc b/src/TCP_Reassembler.cc
index eb27093..3034ac6 100644
--- a/src/TCP_Reassembler.cc
+++ b/src/TCP_Reassembler.cc
@@ -4,6 +4,10 @@
 #include "TCP_Reassembler.h"
 #include "TCP.h"
 #include "TCP_Endpoint.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include "SDMBNlocal.h"
 
 // Only needed for gap_report events.
 #include "Event.h"
@@ -665,3 +669,65 @@ int TCP_Reassembler::DataPending() const
 
 	return 0;
 	}
+
+BOOST_CLASS_EXPORT_GUID(TCP_Reassembler,"TCP_Reassembler")
+template<class Archive>
+void TCP_Reassembler::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TCP_Reassembler:%d",__FILE__,__LINE__);
+
+        // Serialize Reassembler
+        ar & boost::serialization::base_object<Reassembler>(*this);
+
+        SERIALIZE_PRINT("\t\tTCP_Reassembler:%d",__LINE__);
+        ar & endp;
+
+        // Special handling of bit fields
+        unsigned int bitfields = 0;
+        if (!Archive::is_loading::value)
+        {
+            bitfields |= (deliver_tcp_contents << 0);
+            bitfields |= (had_gap << 1);
+            bitfields |= (did_EOF << 2);
+            bitfields |= (skip_deliveries << 3);
+        }
+        ar & bitfields;
+        if (Archive::is_loading::value)
+        {
+            deliver_tcp_contents = (bitfields >> 0) & 0x1;
+            had_gap = (bitfields >> 1) & 0x1;
+            did_EOF = (bitfields >> 2) & 0x1;
+            skip_deliveries = (bitfields >> 3) & 0x1;
+        }
+     
+#ifdef ENABLE_SEQ_TO_SKIP
+	    ar & seq_to_skip;
+#endif
+        SERIALIZE_PRINT("\t\tTCP_Reassembler:%d",__LINE__);
+        ar & in_delivery;
+        //ar & record_contents_file; //FIXME
+        if (Archive::is_loading::value) { record_contents_file = NULL; } //TMPHACK
+        
+        // Special check for analyzer serializability
+        if (!Archive::is_loading::value)
+        {
+            if (dst_analyzer != NULL)
+            { assert(sdmbn_can_serialize(dst_analyzer->GetTag())); }
+
+            if (tcp_analyzer != NULL)
+            { assert(sdmbn_can_serialize(tcp_analyzer->GetTag())); }
+        }
+        ar & dst_analyzer;
+        ar & tcp_analyzer;
+
+        SERIALIZE_PRINT("\t\tTCP_Reassembler:%d",__LINE__);
+        ar & type;
+        ar & is_orig;
+        SERIALIZE_PRINT("\t\tTCP_Reassembler:Done");
+    }
+template void TCP_Reassembler::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TCP_Reassembler::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/TCP_Reassembler.h b/src/TCP_Reassembler.h
index cb1750e..98abff4 100644
--- a/src/TCP_Reassembler.h
+++ b/src/TCP_Reassembler.h
@@ -3,6 +3,7 @@
 
 #include "Reassem.h"
 #include "TCP_Endpoint.h"
+#include <boost/serialization/access.hpp>
 
 // The skip_to_seq feature does not work correctly with connections >2GB due
 // to use of 32 bit signed ints (see comments in TCP_Reassembler.cc) Since
@@ -130,6 +131,10 @@ private:
 
 	Type type;
 	bool is_orig;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff --git a/src/Teredo.cc b/src/Teredo.cc
index 54676c3..aa1733d 100644
--- a/src/Teredo.cc
+++ b/src/Teredo.cc
@@ -2,6 +2,9 @@
 #include "Teredo.h"
 #include "IP.h"
 #include "Reporter.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
 
 void Teredo_Analyzer::Done()
 	{
@@ -9,6 +12,20 @@ void Teredo_Analyzer::Done()
 	Event(udp_session_done);
 	}
 
+BOOST_CLASS_EXPORT_GUID(Teredo_Analyzer,"Teredo_Analyzer")
+template<class Archive>
+void Teredo_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        // Serialize Analyzer 
+        ar & boost::serialization::base_object<Analyzer>(*this);
+    }
+template void Teredo_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void Teredo_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 bool TeredoEncapsulation::DoParse(const u_char* data, int& len,
                                   bool found_origin, bool found_auth)
 	{
diff --git a/src/Teredo.h b/src/Teredo.h
index 84ff8dd..a3502a9 100644
--- a/src/Teredo.h
+++ b/src/Teredo.h
@@ -3,6 +3,7 @@
 
 #include "Analyzer.h"
 #include "NetVar.h"
+#include <boost/serialization/access.hpp>
 
 class Teredo_Analyzer : public Analyzer {
 public:
@@ -38,6 +39,12 @@ public:
 protected:
 	friend class AnalyzerTimer;
 	void ExpireTimer(double t);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    Teredo_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 class TeredoEncapsulation {
diff --git a/src/Timer.cc b/src/Timer.cc
index c2a8bb3..8756102 100644
--- a/src/Timer.cc
+++ b/src/Timer.cc
@@ -6,6 +6,10 @@
 #include "Timer.h"
 #include "Desc.h"
 #include "Serializer.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include "SDMBNlocal.h"
 
 // Names of timers in same order than in TimerType.
 const char* TimerNames[] = {
@@ -86,6 +90,33 @@ bool Timer::DoUnserialize(UnserialInfo* info)
 	return UNSERIALIZE(&time);
 	}
 
+BOOST_CLASS_EXPORT_GUID(Timer,"Timer")
+template<class Archive>
+void Timer::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:Timer:%d",__FILE__,__LINE__);
+        // Serialize PQ_Element
+//        ar & boost::serialization::base_object<PQ_Element>(*this);
+
+        // Special handling of bit field
+        unsigned int bitfields = 0;
+        if (!Archive::is_loading::value)
+        {
+            bitfields |= (type << 0);
+        }
+        ar & bitfields;
+        if (Archive::is_loading::value)
+        {
+            type = (bitfields >> 0) & 0xFF;
+        } 
+    }
+template void Timer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void Timer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 unsigned int TimerMgr::current_timers[NUM_TIMER_TYPES];
 
 TimerMgr::~TimerMgr()
@@ -106,6 +137,24 @@ int TimerMgr::Advance(double arg_t, int max_expire)
 	return DoAdvance(t, max_expire);
 	}
 
+BOOST_CLASS_EXPORT_GUID(TimerMgr,"TimerMgr")
+template<class Archive>
+void TimerMgr::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TimerMgr:%d",__FILE__,__LINE__);
+
+        ar & t;
+        ar & last_timestamp;
+        ar & last_advance;
+        ar & tag;
+        ar & num_expired;
+    }
+template void TimerMgr::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TimerMgr::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
 
 PQ_TimerMgr::PQ_TimerMgr(const Tag& tag) : TimerMgr(tag)
 	{
@@ -178,6 +227,24 @@ void PQ_TimerMgr::Remove(Timer* timer)
 	delete timer;
 	}
 
+BOOST_CLASS_EXPORT_GUID(PQ_TimerMgr,"PQ_TimerMgr")
+template<class Archive>
+void PQ_TimerMgr::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:PQ_TimerMgr:%d",__FILE__,__LINE__);
+        // Serialize TimerMgr
+        ar & boost::serialization::base_object<TimerMgr>(*this);
+
+        //ar & q; //FIXME
+        if (Archive::is_loading::value) { q = NULL; } //TMPHACK
+    }
+template void PQ_TimerMgr::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void PQ_TimerMgr::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 CQ_TimerMgr::CQ_TimerMgr(const Tag& tag) : TimerMgr(tag)
 	{
 	cq = cq_init(60.0, 1.0);
@@ -260,3 +327,21 @@ void CQ_TimerMgr::Remove(Timer* timer)
 		delete timer;
 		}
 	}
+
+BOOST_CLASS_EXPORT_GUID(CQ_TimerMgr,"CQ_TimerMgr")
+template<class Archive>
+void CQ_TimerMgr::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:CQ_TimerMgr:%d",__FILE__,__LINE__);
+        // Serialize TimerMgr
+        ar & boost::serialization::base_object<TimerMgr>(*this);
+
+        //ar & cq; //FIXME
+        if (Archive::is_loading::value) { cq = NULL; } //TMPHACK
+    }
+template void CQ_TimerMgr::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void CQ_TimerMgr::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/Timer.h b/src/Timer.h
index 310e72b..e436846 100644
--- a/src/Timer.h
+++ b/src/Timer.h
@@ -8,6 +8,7 @@
 #include <string>
 #include "SerialObj.h"
 #include "PriorityQueue.h"
+#include <boost/serialization/access.hpp>
 
 extern "C" {
 #include "cq.h"
@@ -75,6 +76,10 @@ protected:
 	DECLARE_ABSTRACT_SERIAL(Timer);
 
 	unsigned int type:8;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class TimerMgr {
@@ -135,6 +140,12 @@ protected:
 	int num_expired;
 
 	static unsigned int current_timers[NUM_TIMER_TYPES];
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    TimerMgr() {}; // Dummy default constructor for serialization
 };
 
 class PQ_TimerMgr : public TimerMgr {
@@ -157,6 +168,12 @@ protected:
 	Timer* Top()			{ return (Timer*) q->Top(); }
 
 	PriorityQueue* q;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    PQ_TimerMgr() {}; // Dummy default constructor for serialization
 };
 
 class CQ_TimerMgr : public TimerMgr {
@@ -176,6 +193,12 @@ protected:
 	void Remove(Timer* timer);
 
 	struct cq_handle *cq;
+    
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    CQ_TimerMgr() {}; // Dummy default constructor for serialization
 };
 
 extern TimerMgr* timer_mgr;
diff --git a/src/TunnelEncapsulation.cc b/src/TunnelEncapsulation.cc
index edbabef..99da88b 100644
--- a/src/TunnelEncapsulation.cc
+++ b/src/TunnelEncapsulation.cc
@@ -3,6 +3,10 @@
 #include "TunnelEncapsulation.h"
 #include "util.h"
 #include "Conn.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/vector.hpp>
 
 EncapsulatingConn::EncapsulatingConn(Connection* c, BifEnum::Tunnel::Type t)
 		: src_addr(c->OrigAddr()), dst_addr(c->RespAddr()),
@@ -34,6 +38,25 @@ RecordVal* EncapsulatingConn::GetRecordVal() const
 	return rv;
 	}
 
+BOOST_CLASS_EXPORT_GUID(EncapsulatingConn,"EncapsulatingConn")
+template<class Archive>
+void EncapsulatingConn::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & src_addr;
+        ar & dst_addr;
+        ar & src_port;
+        ar & dst_port;
+        ar & proto;
+        ar & type;
+        ar & uid;
+    }
+template void EncapsulatingConn::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void EncapsulatingConn::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 bool operator==(const EncapsulationStack& e1, const EncapsulationStack& e2)
 	{
 	if ( ! e1.conns )
@@ -53,3 +76,17 @@ bool operator==(const EncapsulationStack& e1, const EncapsulationStack& e2)
 
 	return true;
 	}
+
+BOOST_CLASS_EXPORT_GUID(EncapsulationStack,"EncapsulationStack")
+template<class Archive>
+void EncapsulationStack::serialize(Archive & ar, const unsigned int version)
+    {
+        printf("%s:EncapsulationStack:%d\n",__FILE__,__LINE__);
+//        ar & conns; //REINCLUDE
+    }
+template void EncapsulationStack::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void EncapsulationStack::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/TunnelEncapsulation.h b/src/TunnelEncapsulation.h
index e8ca7a4..9904dc4 100644
--- a/src/TunnelEncapsulation.h
+++ b/src/TunnelEncapsulation.h
@@ -8,6 +8,8 @@
 #include "IPAddr.h"
 #include "Val.h"
 #include <vector>
+#include <boost/serialization/access.hpp>
+#include <boost/serialization/vector.hpp>
 
 class Connection;
 
@@ -109,6 +111,10 @@ protected:
 	TransportProto proto;
 	BifEnum::Tunnel::Type type;
 	uint64 uid;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 /**
@@ -203,6 +209,10 @@ public:
 
 protected:
 	vector<EncapsulatingConn>* conns;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #endif
diff --git a/src/Type.cc b/src/Type.cc
index 414c07d..9035f06 100644
--- a/src/Type.cc
+++ b/src/Type.cc
@@ -8,6 +8,12 @@
 #include "Scope.h"
 #include "Serializer.h"
 #include "Reporter.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/binary_object.hpp>
+#include <boost/serialization/list.hpp>
+#include "SDMBNlocal.h"
 
 #include <string>
 #include <list>
@@ -290,6 +296,59 @@ bool BroType::DoUnserialize(UnserialInfo* info)
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(BroType,"BroType")
+template<class Archive>
+void BroType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:BroType:%d",__FILE__,__LINE__);
+        // Serialize BroObj
+        ar & boost::serialization::base_object<BroObj>(*this);
+
+        SERIALIZE_PRINT("\t\tBroType:%d",__LINE__);
+        ar & tag;
+        ar & internal_tag;
+        ar & is_network_order;
+        ar & base_type;
+
+        // Special handling of type_id 
+        SERIALIZE_PRINT("\t\tBroType:%d",__LINE__);
+        int type_id_len;
+        if (!Archive::is_loading::value)
+        {   
+            if (NULL == type_id)
+            { type_id_len = 0; }
+            else
+            { type_id_len = strlen(type_id)+1; } 
+        }
+        ar & type_id_len;
+        if (!Archive::is_loading::value)
+        { 
+            if (type_id_len > 0)
+            {
+                ar & boost::serialization::make_binary_object((void *)type_id, 
+                        type_id_len); 
+            }
+        }
+        if (Archive::is_loading::value)
+        {
+            if (type_id_len > 0)
+            {
+                type_id = new char[type_id_len];
+                ar & boost::serialization::make_binary_object(
+                        const_cast<char* &>(type_id), type_id_len);
+            }
+            else
+            { type_id = NULL; }
+        }
+        SERIALIZE_PRINT("\t\tBroType:Done");
+    }
+template void BroType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void BroType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 TypeList::~TypeList()
 	{
 	loop_over_list(types, i)
@@ -393,6 +452,24 @@ bool TypeList::DoUnserialize(UnserialInfo* info)
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(TypeList,"TypeList")
+template<class Archive>
+void TypeList::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TypeList:%d",__FILE__,__LINE__);
+        // Serialize BroType
+        ar & boost::serialization::base_object<BroType>(*this);
+
+        ar & pure_type;
+        ar & types;
+    }
+template void TypeList::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TypeList::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 IndexType::~IndexType()
 	{
 	Unref(indices);
@@ -513,6 +590,24 @@ bool IndexType::DoUnserialize(UnserialInfo* info)
 	return indices != 0;
 	}
 
+BOOST_CLASS_EXPORT_GUID(IndexType,"IndexType")
+template<class Archive>
+void IndexType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:IndexType:%d",__FILE__,__LINE__);
+        // Serialize BroType
+        ar & boost::serialization::base_object<BroType>(*this);
+
+        ar & indices;
+        ar & yield_type;
+    }
+template void IndexType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void IndexType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 TableType::TableType(TypeList* ind, BroType* yield)
 : IndexType(TYPE_TABLE, ind, yield)
 	{
@@ -628,6 +723,21 @@ bool TableType::DoUnserialize(UnserialInfo* info)
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(TableType,"TableType")
+template<class Archive>
+void TableType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TableType:%d",__FILE__,__LINE__);
+        // Serialize IndexType
+        ar & boost::serialization::base_object<IndexType>(*this);
+    }
+template void TableType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TableType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 SetType::~SetType()
 	{
 	Unref(elements);
@@ -651,6 +761,24 @@ bool SetType::DoUnserialize(UnserialInfo* info)
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(SetType,"SetType")
+template<class Archive>
+void SetType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:SetType:%d",__FILE__,__LINE__);
+        // Serialize TableType
+        ar & boost::serialization::base_object<TableType>(*this);
+
+        //ar & elements; //FIXME
+        if (Archive::is_loading::value) { elements = NULL; } //TMPHACK
+    }
+template void SetType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void SetType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 FuncType::FuncType(RecordType* arg_args, BroType* arg_yield, int arg_is_event)
 : BroType(TYPE_FUNC)
 	{
@@ -777,6 +905,42 @@ bool FuncType::DoUnserialize(UnserialInfo* info)
 	return UNSERIALIZE(&is_event);
 	}
 
+BOOST_CLASS_EXPORT_GUID(FuncType,"FuncType")
+template<class Archive>
+void FuncType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:FuncType:%d",__FILE__,__LINE__);
+        // Serialize BroType
+        ar & boost::serialization::base_object<BroType>(*this);
+
+        ar & args;
+        ar & arg_types;
+        ar & yield;
+        ar & is_event;
+        ar & return_value;
+    }
+template void FuncType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void FuncType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
+BOOST_CLASS_EXPORT_GUID(TypeType,"TypeType")
+template<class Archive>
+void TypeType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TypeType:%d",__FILE__,__LINE__);
+        // Serialize BroType
+        ar & boost::serialization::base_object<BroType>(*this);
+    }
+template void TypeType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TypeType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 TypeDecl::TypeDecl(BroType* t, const char* i, attr_list* arg_attrs, bool in_record)
 	{
 	type = t;
@@ -841,6 +1005,24 @@ void TypeDecl::DescribeReST(ODesc* d) const
 		}
 	}
 
+BOOST_CLASS_EXPORT_GUID(TypeDecl,"TypeDecl")
+template<class Archive>
+void TypeDecl::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TypeDecl:%d",__FILE__,__LINE__);
+
+        ar & type;
+        ar & attrs;
+        //ar & id; //FIXME
+        if (Archive::is_loading::value) { id = NULL; } //TMPHACK
+    }
+template void TypeDecl::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TypeDecl::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 CommentedTypeDecl::CommentedTypeDecl(BroType* t, const char* i,
 			attr_list* attrs, bool in_record, std::list<std::string>* cmnt_list)
 	: TypeDecl(t, i, attrs, in_record)
@@ -872,6 +1054,23 @@ void CommentedTypeDecl::DescribeReST(ODesc* d) const
 		}
 	}
 
+BOOST_CLASS_EXPORT_GUID(CommentedTypeDecl,"CommentedTypeDecl")
+template<class Archive>
+void CommentedTypeDecl::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:CommentedTypeDecl:%d",__FILE__,__LINE__);
+        // Serialize TypeDecl
+        ar & boost::serialization::base_object<TypeDecl>(*this);
+
+        ar & comments;
+    }
+template void CommentedTypeDecl::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void CommentedTypeDecl::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 RecordType::RecordType(type_decl_list* arg_types) : BroType(TYPE_RECORD)
 	{
 	types = arg_types;
@@ -1128,6 +1327,24 @@ bool RecordType::DoUnserialize(UnserialInfo* info)
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(RecordType,"RecordType")
+template<class Archive>
+void RecordType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:RecordType:%d",__FILE__,__LINE__);
+        // Serialize BroType
+        ar & boost::serialization::base_object<BroType>(*this);
+
+        ar & num_fields;
+        ar & types; 
+    }
+template void RecordType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void RecordType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 SubNetType::SubNetType() : BroType(TYPE_SUBNET)
 	{
 	}
@@ -1154,6 +1371,21 @@ bool SubNetType::DoUnserialize(UnserialInfo* info)
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(SubNetType,"SubNetType")
+template<class Archive>
+void SubNetType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:SubNetType:%d",__FILE__,__LINE__);
+        // Serialize BroType
+        ar & boost::serialization::base_object<BroType>(*this);
+    }
+template void SubNetType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void SubNetType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 FileType::FileType(BroType* yield_type)
 : BroType(TYPE_FILE)
 	{
@@ -1202,6 +1434,23 @@ bool FileType::DoUnserialize(UnserialInfo* info)
 	return yield != 0;
 	}
 
+BOOST_CLASS_EXPORT_GUID(FileType,"FileType")
+template<class Archive>
+void FileType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:FileType:%d",__FILE__,__LINE__);
+        // Serialize BroType
+        ar & boost::serialization::base_object<BroType>(*this);
+
+        ar & yield;
+    }
+template void FileType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void FileType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 EnumType::EnumType()
 : BroType(TYPE_ENUM)
 	{
@@ -1418,6 +1667,41 @@ bool EnumType::DoUnserialize(UnserialInfo* info)
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(EnumType,"EnumType")
+template<class Archive>
+void EnumType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:EnumType:%d",__FILE__,__LINE__);
+        // Serialize BroType
+        ar & boost::serialization::base_object<BroType>(*this);
+
+        //ar & names; //FIXME
+        ar & counter;
+    }
+template void EnumType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void EnumType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
+BOOST_CLASS_EXPORT_GUID(CommentedEnumType,"CommentedEnumType")
+template<class Archive>
+void CommentedEnumType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:CommentedEnumType:%d",__FILE__,__LINE__);
+        // Serialize EnumType
+        ar & boost::serialization::base_object<EnumType>(*this);
+
+        //ar & comments; //FIXME
+    }
+template void CommentedEnumType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void CommentedEnumType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 VectorType::VectorType(BroType* element_type)
 : BroType(TYPE_VECTOR)
 	{
@@ -1477,6 +1761,23 @@ void VectorType::Describe(ODesc* d) const
 	yield_type->Describe(d);
 	}
 
+BOOST_CLASS_EXPORT_GUID(VectorType,"VectorType")
+template<class Archive>
+void VectorType::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:VectorType:%d",__FILE__,__LINE__);
+        // Serialize BroType
+        ar & boost::serialization::base_object<BroType>(*this);
+
+        ar & yield_type;
+    }
+template void VectorType::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void VectorType::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 BroType* base_type(TypeTag tag)
 	{
 	static BroType* base_types[NUM_TYPES];
diff --git a/src/Type.h b/src/Type.h
index efe15e6..45372b1 100644
--- a/src/Type.h
+++ b/src/Type.h
@@ -11,6 +11,7 @@
 #include "Attr.h"
 #include "BroList.h"
 #include "Dict.h"
+#include <boost/serialization/access.hpp>
 
 // BRO types.
 
@@ -241,6 +242,10 @@ private:
 	// This type_id field is only used by the documentation framework to
 	// track the names of declared types.
 	const char* type_id;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class TypeList : public BroType {
@@ -285,6 +290,10 @@ protected:
 
 	BroType* pure_type;
 	type_list types;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class IndexType : public BroType {
@@ -315,6 +324,10 @@ protected:
 
 	TypeList* indices;
 	BroType* yield_type;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class TableType : public IndexType {
@@ -331,6 +344,10 @@ protected:
 	TypeList* ExpandRecordIndex(RecordType* rt) const;
 
 	DECLARE_SERIAL(TableType)
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class SetType : public TableType {
@@ -346,6 +363,10 @@ protected:
 	ListExpr* elements;
 
 	DECLARE_SERIAL(SetType)
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class FuncType : public BroType {
@@ -382,6 +403,10 @@ protected:
 	BroType* yield;
 	int is_event;
 	ID* return_value;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class TypeType : public BroType {
@@ -395,6 +420,10 @@ protected:
 	TypeType()	{}
 
 	BroType* type;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class TypeDecl {
@@ -413,6 +442,12 @@ public:
 	BroType* type;
 	Attributes* attrs;
 	const char* id;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+    
+    TypeDecl() {}; // Dummy default constructor for serialization
 };
 
 class CommentedTypeDecl : public TypeDecl {
@@ -424,6 +459,12 @@ public:
 	void DescribeReST(ODesc* d) const;
 
 	std::list<std::string>* comments;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    CommentedTypeDecl() {}; // Dummy default constructor for serialization
 };
 
 class RecordType : public BroType {
@@ -468,6 +509,10 @@ protected:
 
 	int num_fields;
 	type_decl_list* types;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class SubNetType : public BroType {
@@ -476,6 +521,10 @@ public:
 	void Describe(ODesc* d) const;
 protected:
 	DECLARE_SERIAL(SubNetType)
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class FileType : public BroType {
@@ -493,6 +542,10 @@ protected:
 	DECLARE_SERIAL(FileType)
 
 	BroType* yield;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class EnumType : public BroType {
@@ -529,6 +582,10 @@ protected:
 	// as a flag to prevent mixing of auto-increment and explicit
 	// enumerator specifications.
 	bro_int_t counter;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class CommentedEnumType: public EnumType {
@@ -550,6 +607,10 @@ protected:
 	// Comments are only filled when in "documentation mode".
 	typedef std::map< const char*, std::list<std::string>*, ltstr > CommentMap;
 	CommentMap comments;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class VectorType : public BroType {
@@ -572,6 +633,10 @@ protected:
 	DECLARE_SERIAL(VectorType)
 
 	BroType* yield_type;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 // Returns the BRO basic (non-parameterized) type with the given type.
diff --git a/src/UDP.cc b/src/UDP.cc
index d85cb39..b4a4e66 100644
--- a/src/UDP.cc
+++ b/src/UDP.cc
@@ -8,6 +8,10 @@
 #include "NetVar.h"
 #include "UDP.h"
 #include "Reporter.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include "SDMBNlocal.h"
 
 UDP_Analyzer::UDP_Analyzer(Connection* conn)
 : TransportLayerAnalyzer(AnalyzerTag::UDP, conn)
@@ -227,3 +231,22 @@ bool UDP_Analyzer::ValidateChecksum(const IP_Hdr* ip, const udphdr* up, int len)
 
 	return sum == 0xffff;
 	}
+
+BOOST_CLASS_EXPORT_GUID(UDP_Analyzer,"UDP_Analyzer")
+template<class Archive>
+void UDP_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:UDP_Analyzer:%d",__FILE__,__LINE__);
+
+        // Serialize TransportLayerAnalyzer
+        ar & boost::serialization::base_object<TransportLayerAnalyzer>(*this); 
+        ar & request_len;
+        ar & reply_len;
+        SERIALIZE_PRINT("\t\tUDP_Analyzer:Done");
+    }
+template void UDP_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void UDP_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/UDP.h b/src/UDP.h
index b93d4da..3085023 100644
--- a/src/UDP.h
+++ b/src/UDP.h
@@ -5,6 +5,7 @@
 
 #include "Analyzer.h"
 #include <netinet/udp.h>
+#include <boost/serialization/access.hpp>
 
 typedef enum {
 	UDP_INACTIVE,	// no packet seen
@@ -45,6 +46,12 @@ private:
 #define HIST_RESP_DATA_PKT 0x2
 #define HIST_ORIG_CORRUPT_PKT 0x4
 #define HIST_RESP_CORRUPT_PKT 0x8
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    UDP_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff --git a/src/Val.cc b/src/Val.cc
index 79fa8a0..46123a5 100644
--- a/src/Val.cc
+++ b/src/Val.cc
@@ -26,10 +26,17 @@
 #include "Conn.h"
 #include "Reporter.h"
 #include "IPAddr.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <boost/serialization/list.hpp>
+#include <boost/serialization/vector.hpp>
+#include "SDMBNlocal.h"
 
 Val::Val(Func* f)
 	{
 	val.func_val = f;
+    val_type = BROVALUNION_FUNC;
 	type = f->FType()->Ref();
 	attribs = 0;
 #ifdef DEBUG
@@ -44,6 +51,7 @@ Val::Val(BroFile* f)
 		string_file_type = new FileType(base_type(TYPE_STRING));
 
 	val.file_val = f;
+    val_type = BROVALUNION_FILE;
 
 	assert(f->FType()->Tag() == TYPE_STRING);
 	type = string_file_type->Ref();
@@ -163,6 +171,7 @@ Val* Val::Unserialize(UnserialInfo* info, TypeTag type, const BroType* exact_typ
 					// Different, so let's bind the val
 					// to the local type.
 					v->val.int_val = lv;
+                    v->val_type = BROVALUNION_INT;
 					Unref(rt);
 					v->type = lt;
 					::Ref(lt);
@@ -270,18 +279,21 @@ bool Val::DoUnserialize(UnserialInfo* info)
 			return false;
 
 		val.string_val = new BroString((u_char*) str, len, 1);
+        val_type = BROVALUNION_STRING;
 		delete [] str;
 		return true;
 
 	case TYPE_INTERNAL_ADDR:
 		{
 		val.addr_val = new IPAddr();
+        val_type = BROVALUNION_ADDR;
 		return UNSERIALIZE(val.addr_val);
 		}
 
 	case TYPE_INTERNAL_SUBNET:
 		{
 		val.subnet_val = new IPPrefix();
+        val_type = BROVALUNION_SUBNET;
 		return UNSERIALIZE(val.subnet_val);
 		}
 
@@ -292,11 +304,13 @@ bool Val::DoUnserialize(UnserialInfo* info)
 		if ( type->Tag() == TYPE_FUNC )
 			{
 			val.func_val = Func::Unserialize(info);
+            val_type = BROVALUNION_FUNC;
 			return val.func_val != 0;
 			}
 		else if ( type->Tag() == TYPE_FILE )
 			{
 			val.file_val = BroFile::Unserialize(info);
+            val_type = BROVALUNION_FILE;
 			return val.file_val != 0;
 			}
 		return true;
@@ -532,6 +546,112 @@ void Val::ValDescribeReST(ODesc* d) const
 	}
 	}
 
+BOOST_CLASS_EXPORT_GUID(Val,"Val")
+template<class Archive>
+void Val::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:Val:%d",__FILE__,__LINE__);
+        // Serialize BroObj
+        ar & boost::serialization::base_object<BroObj>(*this);
+        
+        ar & val_type;
+
+        // Special handling of value union
+        if (!Archive::is_loading::value)
+        {
+            switch(val_type)
+            {
+            case BROVALUNION_INT:
+                ar & val.int_val;
+                break;
+            case BROVALUNION_UINT:
+                ar & val.uint_val;
+                break;
+            case BROVALUNION_ADDR:
+                ar & val.addr_val;
+                break;
+            case BROVALUNION_SUBNET:
+                ar & val.subnet_val;
+                break;
+            case BROVALUNION_DOUBLE:
+                ar & val.double_val;
+                break;
+            case BROVALUNION_STRING:
+                ar & val.string_val;
+                break;
+            case BROVALUNION_FUNC:
+                break;
+            case BROVALUNION_FILE:
+                ar & val.file_val;
+                break;
+            case BROVALUNION_RE:
+            case BROVALUNION_TABLE:
+            case BROVALUNION_LIST:
+                break;
+            case BROVALUNION_VECTOR:
+                ar & val.vector_val;
+                break;
+            default:
+                SERIALIZE_PRINT("ERROR: Unknown type for Val");
+                break;
+            }
+        }
+        if (Archive::is_loading::value)
+        {
+            switch(val_type)
+            {
+            case BROVALUNION_INT:
+                ar & val.int_val;
+                break;
+            case BROVALUNION_UINT:
+                ar & val.uint_val;
+                break;
+            case BROVALUNION_ADDR:
+                ar & val.addr_val;
+                break;
+            case BROVALUNION_SUBNET:
+                ar & val.subnet_val;
+                break;
+            case BROVALUNION_DOUBLE:
+                ar & val.double_val;
+                break;
+            case BROVALUNION_STRING:
+                ar & val.string_val;
+                break;
+            case BROVALUNION_FUNC:
+                val.func_val = NULL; //TMPHACK
+                break;
+            case BROVALUNION_FILE:
+                ar & val.file_val;
+                break;
+            case BROVALUNION_RE:
+                val.re_val = NULL; //TMPHACK
+                break;
+            case BROVALUNION_TABLE:
+                val.table_val = NULL; //TMPHACK
+                break;
+            case BROVALUNION_LIST:
+                val.val_list_val = NULL; //TMPHACK
+                break;
+            case BROVALUNION_VECTOR:
+                ar & val.vector_val;
+                break;
+            default:
+                SERIALIZE_PRINT("ERROR: Unknown type for Val");
+                break;
+            }
+        }
+
+        ar & type; 
+        ar & attribs;
+    }
+template void Val::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void Val::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 MutableVal::~MutableVal()
 	{
 	for ( list<ID*>::iterator i = aliases.begin(); i != aliases.end(); ++i )
@@ -709,6 +829,26 @@ bool MutableVal::DoUnserialize(UnserialInfo* info)
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(MutableVal,"MutableVal")
+template<class Archive>
+void MutableVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:MutableVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+
+        ar & id;
+        ar & aliases;
+        ar & props;
+        ar & last_modified;
+    }
+template void MutableVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void MutableVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 IntervalVal::IntervalVal(double quantity, double units) :
 	Val(quantity * units, TYPE_INTERVAL)
 	{
@@ -765,6 +905,21 @@ bool IntervalVal::DoUnserialize(UnserialInfo* info)
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(IntervalVal,"IntervalVal")
+template<class Archive>
+void IntervalVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:IntervalVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+    }
+template void IntervalVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void IntervalVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 PortVal::PortVal(uint32 p, TransportProto port_type) : Val(TYPE_PORT)
 	{
 	// Note, for ICMP one-way connections:
@@ -794,6 +949,7 @@ PortVal::PortVal(uint32 p, TransportProto port_type) : Val(TYPE_PORT)
 	}
 
 	val.uint_val = static_cast<bro_uint_t>(p);
+    val_type = BROVALUNION_UINT;
 	}
 
 PortVal::PortVal(uint32 p) : Val(TYPE_PORT)
@@ -805,6 +961,7 @@ PortVal::PortVal(uint32 p) : Val(TYPE_PORT)
 		}
 
 	val.uint_val = static_cast<bro_uint_t>(p);
+    val_type = BROVALUNION_UINT;
 	}
 
 uint32 PortVal::Port() const
@@ -856,25 +1013,44 @@ bool PortVal::DoUnserialize(UnserialInfo* info)
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(PortVal,"PortVal")
+template<class Archive>
+void PortVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:PortVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+    }
+template void PortVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void PortVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 AddrVal::AddrVal(const char* text) : Val(TYPE_ADDR)
 	{
 	val.addr_val = new IPAddr(text);
+    val_type = BROVALUNION_ADDR;
 	}
 
 AddrVal::AddrVal(uint32 addr) : Val(TYPE_ADDR)
 	{
 	// ### perhaps do gethostbyaddr here?
 	val.addr_val = new IPAddr(IPv4, &addr, IPAddr::Network);
+    val_type = BROVALUNION_ADDR;
 	}
 
 AddrVal::AddrVal(const uint32 addr[4]) : Val(TYPE_ADDR)
 	{
 	val.addr_val = new IPAddr(IPv6, addr, IPAddr::Network);
+    val_type = BROVALUNION_ADDR;
 	}
 
 AddrVal::AddrVal(const IPAddr& addr) : Val(TYPE_ADDR)
 	{
 	val.addr_val = new IPAddr(addr);
+    val_type = BROVALUNION_ADDR;
 	}
 
 AddrVal::~AddrVal()
@@ -909,6 +1085,21 @@ bool AddrVal::DoUnserialize(UnserialInfo* info)
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(AddrVal,"AddrVal")
+template<class Archive>
+void AddrVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:AddrVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+    }
+template void AddrVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void AddrVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 SubNetVal::SubNetVal(const char* text) : Val(TYPE_SUBNET)
 	{
 	string s(text);
@@ -918,39 +1109,46 @@ SubNetVal::SubNetVal(const char* text) : Val(TYPE_SUBNET)
 		{
 		reporter->Error("Bad string in SubNetVal ctor: %s", text);
 		val.subnet_val = new IPPrefix();
+        val_type = BROVALUNION_SUBNET;
 		}
 	else
 		{
 		val.subnet_val = new IPPrefix(s.substr(0, slash_loc),
 		                              atoi(s.substr(slash_loc + 1).c_str()));
+        val_type = BROVALUNION_SUBNET;
 		}
 	}
 
 SubNetVal::SubNetVal(const char* text, int width) : Val(TYPE_SUBNET)
 	{
 	val.subnet_val = new IPPrefix(text, width);
+    val_type = BROVALUNION_SUBNET;
 	}
 
 SubNetVal::SubNetVal(uint32 addr, int width) : Val(TYPE_SUBNET)
 	{
 	IPAddr a(IPv4, &addr, IPAddr::Network);
 	val.subnet_val = new IPPrefix(a, width);
+    val_type = BROVALUNION_SUBNET;
 	}
 
 SubNetVal::SubNetVal(const uint32* addr, int width) : Val(TYPE_SUBNET)
 	{
 	IPAddr a(IPv6, addr, IPAddr::Network);
 	val.subnet_val = new IPPrefix(a, width);
+    val_type = BROVALUNION_SUBNET;
 	}
 
 SubNetVal::SubNetVal(const IPAddr& addr, int width) : Val(TYPE_SUBNET)
 	{
 	val.subnet_val = new IPPrefix(addr, width);
+    val_type = BROVALUNION_SUBNET;
 	}
 
 SubNetVal::SubNetVal(const IPPrefix& prefix) : Val(TYPE_SUBNET)
 	{
 	val.subnet_val = new IPPrefix(prefix);
+    val_type = BROVALUNION_SUBNET;
 	}
 
 SubNetVal::~SubNetVal()
@@ -1033,20 +1231,38 @@ bool SubNetVal::DoUnserialize(UnserialInfo* info)
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(SubNetVal,"SubNetVal")
+template<class Archive>
+void SubNetVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:SubNetVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+    }
+template void SubNetVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void SubNetVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 StringVal::StringVal(BroString* s) : Val(TYPE_STRING)
 	{
 	val.string_val = s;
+    val_type = BROVALUNION_STRING;
 	}
 
 StringVal::StringVal(int length, const char* s) : Val(TYPE_STRING)
 	{
 	// The following adds a NUL at the end.
 	val.string_val = new BroString((const u_char*)  s, length, 1);
+    val_type = BROVALUNION_STRING;
 	}
 
 StringVal::StringVal(const char* s) : Val(TYPE_STRING)
 	{
 	val.string_val = new BroString(s);
+    val_type = BROVALUNION_STRING;
 	}
 
 StringVal* StringVal::ToUpper()
@@ -1084,9 +1300,25 @@ bool StringVal::DoUnserialize(UnserialInfo* info)
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(StringVal,"StringVal")
+template<class Archive>
+void StringVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:StringVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+    }
+template void StringVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void StringVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 PatternVal::PatternVal(RE_Matcher* re) : Val(base_type(TYPE_PATTERN))
 	{
 	val.re_val = re;
+    val_type = BROVALUNION_RE;
 	}
 
 PatternVal::~PatternVal()
@@ -1118,6 +1350,7 @@ void PatternVal::SetMatcher(RE_Matcher* re)
 	{
 	delete AsPattern();
 	val.re_val = re;
+    val_type = BROVALUNION_RE;
 	}
 
 void PatternVal::ValDescribe(ODesc* d) const
@@ -1145,9 +1378,25 @@ bool PatternVal::DoUnserialize(UnserialInfo* info)
 	DO_UNSERIALIZE(Val);
 
 	val.re_val = RE_Matcher::Unserialize(info);
+    val_type = BROVALUNION_RE;
 	return val.re_val != 0;
 	}
 
+BOOST_CLASS_EXPORT_GUID(PatternVal,"PatternVal")
+template<class Archive>
+void PatternVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:PatternVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+    }
+template void PatternVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void PatternVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 ListVal::ListVal(TypeTag t)
 : Val(new TypeList(t == TYPE_ANY ? 0 : base_type(t)))
 	{
@@ -1303,7 +1552,39 @@ unsigned int ListVal::MemoryAllocation() const
 		+ type->MemoryAllocation();
 	}
 
-
+BOOST_CLASS_EXPORT_GUID(ListVal,"ListVal")
+template<class Archive>
+void ListVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:ListVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+
+        ar & vals; 
+        ar & tag;
+    }
+template void ListVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void ListVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
+BOOST_CLASS_EXPORT_GUID(TableEntryVal,"TableEntryVal")
+template<class Archive>
+void TableEntryVal::serialize(Archive & ar, const unsigned int version)
+    {
+        ar & val;
+        ar & last_access_time;
+        ar & expire_access_time;
+        ar & last_read_update;
+    }
+template void TableEntryVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TableEntryVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
 TableValTimer::TableValTimer(TableVal* val, double t) : Timer(t, TIMER_TABLE_VAL)
 	{
 	table = val;
@@ -1353,6 +1634,7 @@ void TableVal::Init(TableType* t)
 
 	table_hash = new CompositeHash(table_type->Indices());
 	val.table_val = new PDict(TableEntryVal);
+    val_type = BROVALUNION_TABLE;
 	val.table_val->SetDeleteFunc(table_entry_val_delete_func);
 	}
 
@@ -1375,6 +1657,7 @@ void TableVal::RemoveAll()
 	// Here we take the brute force approach.
 	delete AsTable();
 	val.table_val = new PDict(TableEntryVal);
+    val_type = BROVALUNION_TABLE;
 	val.table_val->SetDeleteFunc(table_entry_val_delete_func);
 	}
 
@@ -2547,11 +2830,41 @@ unsigned int TableVal::MemoryAllocation() const
 		+ table_hash->MemoryAllocation();
 	}
 
+BOOST_CLASS_EXPORT_GUID(TableVal,"TableVal")
+template<class Archive>
+void TableVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:TableVal:%d",__FILE__,__LINE__);
+        // Serialize MutableVal
+        ar & boost::serialization::base_object<MutableVal>(*this);
+
+        ar & table_type;
+        ar & table_hash;
+        ar & attrs;
+        ar & expire_time;
+        //ar & expire_expr; //FIXME
+        if (Archive::is_loading::value) { expire_expr = NULL; } //TMPHACK
+        //ar & timer; //FIXME
+        if (Archive::is_loading::value) { timer = NULL; } //TMPHACK
+        //ar & expire_cookie; //FIXME
+        if (Archive::is_loading::value) { expire_cookie = NULL; } //TMPHACK
+        //ar & subnets; //FIXME
+        if (Archive::is_loading::value) { subnets = NULL; } //TMPHACK
+        ar & def_val;
+    }
+template void TableVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void TableVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 RecordVal::RecordVal(RecordType* t) : MutableVal(t)
 	{
 	record_type = t;
 	int n = record_type->NumFields();
 	val_list* vl = val.val_list_val = new val_list(n);
+    val_type = BROVALUNION_LIST;
 
 	// Initialize to default values from RecordType (which are nil
 	// by default).
@@ -2815,10 +3128,12 @@ bool RecordVal::DoUnserialize(UnserialInfo* info)
 	if ( ! UNSERIALIZE(&len) )
 		{
 		val.val_list_val = new val_list;
+        val_type = BROVALUNION_LIST;
 		return false;
 		}
 
 	val.val_list_val = new val_list(len);
+    val_type = BROVALUNION_LIST;
 
 	for ( int i = 0; i < len; ++i )
 		{
@@ -2881,6 +3196,25 @@ unsigned int RecordVal::MemoryAllocation() const
 	return size + padded_sizeof(*this) + val.val_list_val->MemoryAllocation();
 	}
 
+BOOST_CLASS_EXPORT_GUID(RecordVal,"RecordVal")
+template<class Archive>
+void RecordVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:RecordVal:%d",__FILE__,__LINE__);
+        // Serialize MutableVal
+        ar & boost::serialization::base_object<MutableVal>(*this);
+
+        ar & record_type;
+//        ar & origin; //REINCLUDE
+        if (Archive::is_loading::value) { origin = NULL; } //TMPHACK
+    }
+template void RecordVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void RecordVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 void EnumVal::ValDescribe(ODesc* d) const
 	{
 	const char* ename = type->AsEnumType()->Lookup(val.int_val);
@@ -2905,10 +3239,26 @@ bool EnumVal::DoUnserialize(UnserialInfo* info)
 	return true;
 	}
 
+BOOST_CLASS_EXPORT_GUID(EnumVal,"EnumVal")
+template<class Archive>
+void EnumVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:EnumVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+    }
+template void EnumVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void EnumVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
 VectorVal::VectorVal(VectorType* t) : MutableVal(t)
 	{
 	vector_type = t->Ref()->AsVectorType();
 	val.vector_val = new vector<Val*>();
+    val_type = BROVALUNION_VECTOR;
 	}
 
 VectorVal::~VectorVal()
@@ -3079,6 +3429,7 @@ bool VectorVal::DoUnserialize(UnserialInfo* info)
 	DO_UNSERIALIZE(MutableVal);
 
 	val.vector_val = new vector<Val*>;
+    val_type = BROVALUNION_VECTOR;
 	vector_type = type->Ref()->AsVectorType();
 
 	int len;
@@ -3114,6 +3465,22 @@ void VectorVal::ValDescribe(ODesc* d) const
 	d->Add("]");
 	}
 
+BOOST_CLASS_EXPORT_GUID(VectorVal,"VectorVal")
+template<class Archive>
+void VectorVal::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:VectorVal:%d",__FILE__,__LINE__);
+        // Serialize Val
+        ar & boost::serialization::base_object<Val>(*this);
+
+        ar & vector_type;
+    }
+template void VectorVal::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void VectorVal::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
 
 Val* check_and_promote(Val* v, const BroType* t, int is_init)
 	{
diff --git a/src/Val.h b/src/Val.h
index c3ec5b0..21a7722 100644
--- a/src/Val.h
+++ b/src/Val.h
@@ -19,6 +19,7 @@
 #include "Scope.h"
 #include "StateAccess.h"
 #include "IPAddr.h"
+#include <boost/serialization/access.hpp>
 
 class Val;
 class Func;
@@ -47,6 +48,21 @@ class VectorVal;
 class TableEntryVal;
 declare(PDict,TableEntryVal);
 
+typedef enum {
+    BROVALUNION_INT,
+    BROVALUNION_UINT,
+    BROVALUNION_ADDR,
+    BROVALUNION_SUBNET,
+    BROVALUNION_DOUBLE,
+    BROVALUNION_STRING,
+    BROVALUNION_FUNC,
+    BROVALUNION_FILE,
+    BROVALUNION_RE,
+    BROVALUNION_TABLE,
+    BROVALUNION_LIST,
+    BROVALUNION_VECTOR
+} BroValUnionType;
+
 typedef union {
 	// Used for bool, int, enum.
 	bro_int_t int_val;
@@ -79,6 +95,7 @@ public:
 	Val(bool b, TypeTag t)
 		{
 		val.int_val = b;
+        val_type = BROVALUNION_INT;
 		type = base_type(t);
 		attribs = 0;
 #ifdef DEBUG
@@ -89,6 +106,7 @@ public:
 	Val(int32 i, TypeTag t)
 		{
 		val.int_val = bro_int_t(i);
+        val_type = BROVALUNION_INT;
 		type = base_type(t);
 		attribs = 0;
 #ifdef DEBUG
@@ -99,6 +117,7 @@ public:
 	Val(uint32 u, TypeTag t)
 		{
 		val.uint_val = bro_uint_t(u);
+        val_type = BROVALUNION_UINT;
 		type = base_type(t);
 		attribs = 0;
 #ifdef DEBUG
@@ -109,6 +128,7 @@ public:
 	Val(int64 i, TypeTag t)
 		{
 		val.int_val = i;
+        val_type = BROVALUNION_INT;
 		type = base_type(t);
 		attribs = 0;
 #ifdef DEBUG
@@ -119,6 +139,7 @@ public:
 	Val(uint64 u, TypeTag t)
 		{
 		val.uint_val = u;
+        val_type = BROVALUNION_UINT;
 		type = base_type(t);
 		attribs = 0;
 #ifdef DEBUG
@@ -129,6 +150,7 @@ public:
 	Val(double d, TypeTag t)
 		{
 		val.double_val = d;
+        val_type = BROVALUNION_DOUBLE;
 		type = base_type(t);
 		attribs = 0;
 #ifdef DEBUG
@@ -154,6 +176,7 @@ public:
 	Val()
 		{
 		val.int_val = 0;
+        val_type = BROVALUNION_INT;
 		type = base_type(TYPE_ERROR);
 		attribs = 0;
 #ifdef DEBUG
@@ -363,6 +386,7 @@ protected:
 	Val(BroString* s, TypeTag t)
 		{
 		val.string_val = s;
+        val_type = BROVALUNION_STRING;
 		type = base_type(t);
 		attribs = 0;
 #ifdef DEBUG
@@ -399,6 +423,7 @@ protected:
 			const BroType* exact_type);
 
 	BroValUnion val;
+    BroValUnionType val_type;
 	BroType* type;
 	RecordVal* attribs;
 
@@ -407,6 +432,9 @@ protected:
 	const char* bound_id;
 #endif
 
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class MutableVal : public Val {
@@ -483,6 +511,10 @@ private:
 	list<ID*> aliases;
 	Properties props;
 	uint64 last_modified;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 #define Microseconds 1e-6
@@ -502,6 +534,10 @@ protected:
 	void ValDescribe(ODesc* d) const;
 
 	DECLARE_SERIAL(IntervalVal);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 
@@ -550,6 +586,10 @@ protected:
 	void ValDescribe(ODesc* d) const;
 
 	DECLARE_SERIAL(PortVal);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class AddrVal : public Val {
@@ -573,6 +613,10 @@ protected:
 	AddrVal(BroType* t) : Val(t)	{ }
 
 	DECLARE_SERIAL(AddrVal);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class SubNetVal : public Val {
@@ -602,6 +646,10 @@ protected:
 	void ValDescribe(ODesc* d) const;
 
 	DECLARE_SERIAL(SubNetVal);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class StringVal : public Val {
@@ -633,6 +681,10 @@ protected:
 	void ValDescribe(ODesc* d) const;
 
 	DECLARE_SERIAL(StringVal);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class PatternVal : public Val {
@@ -653,6 +705,10 @@ protected:
 	void ValDescribe(ODesc* d) const;
 
 	DECLARE_SERIAL(PatternVal);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class ListVal : public Val {
@@ -705,6 +761,10 @@ protected:
 
 	val_list vals;
 	TypeTag tag;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 extern double bro_start_network_time;
@@ -748,6 +808,12 @@ protected:
 	// for these anyway.
 	int expire_access_time;
 	int last_read_update;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+    
+    TableEntryVal() {}; // Dummy default constructor for serialization
 };
 
 class TableValTimer : public Timer {
@@ -880,6 +946,10 @@ protected:
 	IterCookie* expire_cookie;
 	PrefixTable* subnets;
 	Val* def_val;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class RecordVal : public MutableVal {
@@ -929,6 +999,10 @@ protected:
 
 	RecordType* record_type;
 	BroObj* origin;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 class EnumVal : public Val {
@@ -949,6 +1023,10 @@ protected:
 	void ValDescribe(ODesc* d) const;
 
 	DECLARE_SERIAL(EnumVal);
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 
@@ -1011,6 +1089,10 @@ protected:
 	DECLARE_SERIAL(VectorVal);
 
 	VectorType* vector_type;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
 };
 
 
diff --git a/src/ZIP.cc b/src/ZIP.cc
index 0ebe93a..d8cecff 100644
--- a/src/ZIP.cc
+++ b/src/ZIP.cc
@@ -1,6 +1,10 @@
 // See the file "COPYING" in the main distribution directory for copyright.
 
 #include "ZIP.h"
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include "SDMBNlocal.h"
 
 ZIP_Analyzer::ZIP_Analyzer(Connection* conn, bool orig, Method arg_method)
 : TCP_SupportAnalyzer(AnalyzerTag::Zip, conn, orig)
@@ -87,3 +91,51 @@ void ZIP_Analyzer::DeliverStream(int len, const u_char* data, bool orig)
 		}
 	while ( zip->avail_out == 0 );
 	}
+
+BOOST_CLASS_EXPORT_GUID(ZIP_Analyzer,"ZIP_Analyzer")
+template<class Archive>
+void ZIP_Analyzer::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s:ZIP_Analzyer:%d\n",__FILE__,__LINE__);
+        // Serialize TCP_SupportAnalyzer 
+        ar & boost::serialization::base_object<TCP_SupportAnalyzer>(*this);
+
+        //ar & zip; //FIXME
+//        int zipnull;
+//        if (!Archive::is_loading::value)
+//        {
+//            if (NULL == zip)
+//            { zipnull = 1; }
+//            else
+//            { zipnull = 0; }
+//        }
+//        ar & zipnull;
+//        if (!zipnull)
+//        {
+//            //ar & zip->next_in; //FIXME
+//            ar & zip->avail_in;
+//            ar & zip->total_in;
+//            //ar & zip->next_out; //FIXME
+//            ar & zip->avail_out;
+//            ar & zip->total_out;
+//            //ar & zip->msg; //FIXME
+//            //ar & zip->state; //FIXME
+//            //zalloc, zfree, and opaque are always null? //FIXME
+//            ar & zip->data_type;
+//            ar & zip->adler;
+//            ar & zip->reserved;
+//        }
+//        else
+//        { zip = NULL; }
+//
+        if (Archive::is_loading::value) { zip = NULL; } //TMPHACK
+        ar & zip_status;
+        if (Archive::is_loading::value) { zip_status = Z_BUF_ERROR; } //TMPHACK
+        ar & method;
+    }
+template void ZIP_Analyzer::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void ZIP_Analyzer::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
diff --git a/src/ZIP.h b/src/ZIP.h
index 6a8a180..3387d97 100644
--- a/src/ZIP.h
+++ b/src/ZIP.h
@@ -7,6 +7,7 @@
 
 #include "zlib.h"
 #include "TCP.h"
+#include <boost/serialization/access.hpp>
 
 class ZIP_Analyzer : public TCP_SupportAnalyzer {
 public:
@@ -24,6 +25,12 @@ protected:
 	z_stream* zip;
 	int zip_status;
 	Method method;
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    ZIP_Analyzer() {}; // Dummy default constructor for serialization
 };
 
 #endif
diff --git a/src/code.tmp b/src/code.tmp
new file mode 100644
index 0000000..3f00ef0
--- /dev/null
+++ b/src/code.tmp
@@ -0,0 +1,45 @@
+        if (Archive::is_loading::value) {  = NULL; } //TMPHACK
+
+#include <boost/archive/text_oarchive.hpp>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/serialization/export.hpp>
+#include <SDMBN.h>
+#include "SDMBNlocal.h"
+
+#include <boost/serialization/list.hpp>
+
+BOOST_CLASS_EXPORT_GUID(,"")
+template<class Archive>
+void ::serialize(Archive & ar, const unsigned int version)
+    {
+        SERIALIZE_PRINT("%s::%d",__FILE__,__LINE__);
+        // Serialize 
+        ar & boost::serialization::base_object<>(*this);
+    }
+template void ::serialize<boost::archive::text_oarchive>(
+        boost::archive::text_oarchive & ar, 
+        const unsigned int file_version);
+template void ::serialize<boost::archive::text_iarchive>(
+        boost::archive::text_iarchive & ar, 
+        const unsigned int file_version);
+
+#include <boost/serialization/binary_object.hpp>
+
+        // Special handling of buffer
+        if (!Archive::is_loading::value)
+        { ar & boost::serialization::make_binary_object(buf, buf_len); }
+        if (Archive::is_loading::value)
+        {
+            buf = new u_char[buf_len];
+            ar & boost::serialization::make_binary_object(buf, buf_len);
+        }
+
+#include <boost/serialization/access.hpp>
+
+    friend class boost::serialization::access;
+    template<class Archive>
+    void serialize(Archive & ar, const unsigned int version);
+
+    () {}; // Dummy default constructor for serialization
+
+
diff --git a/src/main.cc b/src/main.cc
index 5999186..54bc19f 100644
--- a/src/main.cc
+++ b/src/main.cc
@@ -59,6 +59,16 @@ extern "C" void OPENSSL_add_all_algorithms_conf(void);
 #include "logging/writers/Ascii.h"
 
 #include "binpac_bro.h"
+extern "C" {
+#include <SDMBN.h>
+}
+#include "SDMBNlocal.h"
+#include <fstream>
+#include <boost/archive/text_iarchive.hpp>
+#include <boost/archive/text_oarchive.hpp>
+
+#define STATE_TMP_OUTFILE "stateout.tmp"
+#define STATE_TMP_INFILE "statein.tmp"
 
 Brofiler brofiler;
 
@@ -339,6 +349,8 @@ void terminate_bro()
 	delete reporter;
 
 	reporter = 0;
+
+    sdmbn_cleanup();
 	}
 
 void termination_signal()
@@ -494,13 +506,15 @@ int main(int argc, char** argv)
 	opterr = 0;
 
 	char opts[256];
-	safe_strncpy(opts, "B:D:e:f:I:i:K:l:n:p:R:r:s:T:t:U:w:x:X:y:Y:z:CFGLOPSWbdghvZ",
+	safe_strncpy(opts, "B:D:e:f:I:i:K:l:n:p:R:r:s:T:t:U:w:x:X:y:Y:z:CFGLOPSWbdghvZJ:",
 		     sizeof(opts));
 
 #ifdef USE_PERFTOOLS_DEBUG
 	strncat(opts, "mM", 2);
 #endif
 
+    char *device = NULL;
+
 	int op;
 	while ( (op = getopt_long(argc, argv, opts, long_opts, &long_optsind)) != EOF )
 		switch ( op ) {
@@ -527,6 +541,7 @@ int main(int argc, char** argv)
 
 		case 'i':
 			interfaces.append(optarg);
+            device = optarg;
 			break;
 
 		case 'p':
@@ -701,6 +716,15 @@ int main(int argc, char** argv)
 	atexit(atexit_handler);
 	set_processing_status("INITIALIZING", "main");
 
+    // Initialize SDMBN
+    SDMBNLocals locals;
+    bzero(&locals, sizeof(locals));
+    locals.get_perflow = &local_get_perflow;
+    locals.put_perflow = &local_put_perflow;
+    locals.device = device;
+    sdmbn_init(&locals);
+		
+
 	bro_start_time = current_time(true);
 
 	reporter = new Reporter();
@@ -1094,3 +1118,280 @@ int main(int argc, char** argv)
 
 	return 0;
 	}
+
+static Connection *sdmbn_boost_decode(char *state)
+{	
+	long state_size = strlen(state);
+    FILE *file;
+    file = fopen(STATE_TMP_INFILE,"w+b");
+    if (!file) 
+    { 
+        ERROR_PRINT("Could not open serialization file");
+        return NULL;
+    }
+
+    if (int result = fwrite(state, state_size, 1, file) != 1)
+    { 
+        ERROR_PRINT("Could not write serialized state: %d", result);
+        fclose(file);
+        return NULL;
+    }
+    fclose(file);
+
+    // Unserialize connection from temporary archive file
+    Connection *conn;
+    std::ifstream filestream(STATE_TMP_INFILE);
+    {
+        boost::archive::text_iarchive ar(filestream);
+        try
+        {
+            ar & conn;
+        }
+        catch(const std::exception & ex)
+        {
+            ERROR_PRINT("Exception during unserialize: %s",ex.what());
+        }
+    }
+    filestream.close();
+	return conn;
+}
+
+int local_put_perflow(int hashkey, PerflowKey *key, char *state)
+{
+	if (NULL == key || NULL == state)
+	{ return -1; }
+	Connection *conn = sdmbn_boost_decode(state);
+	conn->setGetOpId(0);
+	if (NULL == conn)
+    {
+            ERROR_PRINT("Failed to parse connection");
+            return 0;
+    }
+	sessions->Insert(conn);
+	INFO_PRINT("Connection inserted");
+    return 1;
+}
+
+static char *sdmbn_boost_encode(Connection *conn)
+{
+    // Serialize connection to temporary archive file
+//    try
+//    {
+        std::ofstream filestream(STATE_TMP_OUTFILE);
+        {
+            boost::archive::text_oarchive ar(filestream);
+            ar & conn;
+        }
+        filestream.close();
+//    }
+//    catch(const std::exception & ex)
+//    catch(const boost::archive::archive_exception & ex)
+//    {
+//        ERROR_PRINT("Exception during serialize: %s",ex.what());
+//        assert(false);
+//    }
+
+    // Read serialized connection from temporary archive file
+    FILE *file;
+    long state_size;
+    char *state;
+    file = fopen(STATE_TMP_OUTFILE,"rb");
+    if (!file) 
+    { 
+        ERROR_PRINT("Could not open serialization file");
+        return NULL;
+    }
+    fseek(file,0L,SEEK_END);
+    state_size = ftell(file);
+    rewind(file);
+    state = (char *)malloc(state_size+1);
+    if (!state)
+    { 
+        ERROR_PRINT("Could not allocate space for serialized state");
+        fclose(file);
+        return NULL;
+    }
+    if (int result = fread(state, state_size, 1, file) != 1)
+    { 
+        ERROR_PRINT("Could not read serialized state: %d", result);
+        fclose(file);
+        free(state);
+        return NULL;
+    }
+    fclose(file);
+    state[state_size] = '\0';
+    return state;
+}
+
+static int handle_get_proto(PerflowKey *key, int proto, int id, int raiseEvents)
+{
+    INFO_PRINT("FAST: I am handle_get_proto at the beginning");
+	// Match based on nw_proto
+    Dictionary *d = NULL;
+    switch(proto)
+    {
+    case IPPROTO_TCP:
+        d = &(sessions->tcp_conns);
+        break;
+    case IPPROTO_UDP:
+        d = &(sessions->udp_conns);
+        break;
+    case IPPROTO_ICMP:
+    case IPPROTO_ICMPV6:
+        d = &(sessions->icmp_conns);
+        break;
+    case IPPROTO_IPV4:
+    case IPPROTO_IPV6:
+    default:
+        ERROR_PRINT("Cannot handle proto %d", proto);
+        return 0;
+    }
+	
+	IterCookie *cookie = d->InitForIteration();
+    d->MakeRobustCookie(cookie);
+    int count = 0;
+	while (1)
+    {
+        INFO_PRINT("FAST: I am in loop");
+		HashKey *hashkey;
+        Connection *conn = (Connection *)(d->NextEntry(hashkey, 
+                    cookie, 0));
+        INFO_PRINT("FAST: NOT Conn issue");
+        if (NULL == conn)
+        { 
+           INFO_PRINT("FAST: I AM in NULL check");
+           break; }
+
+        if (conn->HasMoved())
+        {
+           INFO_PRINT("FAST: some state is moved"); 
+           continue;
+         }
+        
+        // Check tp_src
+        if (!(key->wildcards & WILDCARD_TP_SRC) &&
+                !(conn->OrigPort() == key->tp_src
+                    || (key->tp_flip && conn->RespPort() == key->tp_src)))
+        { 
+          INFO_PRINT("FAST: I am in check tp_src");
+          continue; }
+
+        // Check tp_dst
+        if (!(key->wildcards & WILDCARD_TP_DST) &&
+                !(conn->RespPort() == key->tp_dst
+                    || (key->tp_flip && conn->OrigPort() == key->tp_dst)))
+        { 
+         INFO_PRINT("FAST: I am in check tp_dst");
+         continue; }
+
+        INFO_PRINT("FAST: temp check in loop");
+
+        int nw_src_mask = 0xFFFFFFFF;
+        if (!(key->wildcards & WILDCARD_NW_SRC_MASK))
+        { nw_src_mask = nw_src_mask << (32 - key->nw_src_mask); }
+
+        // Check nw_src
+        if (!(key->wildcards & WILDCARD_NW_SRC) &&
+                (nw_src_mask & conn->OrigAddr().in6.s6_addr32[0]) 
+                    != key->nw_src)
+        { 
+        INFO_PRINT("FAST: I am in check nw_src");
+        continue; }
+
+        int nw_dst_mask = 0xFFFFFFFF;
+        if (!(key->wildcards & WILDCARD_NW_DST_MASK))
+        { nw_dst_mask = nw_dst_mask << (32 - key->nw_dst_mask); }
+
+        // Check nw_dst
+        if (!(key->wildcards & WILDCARD_NW_DST) &&
+                (nw_dst_mask & conn->RespAddr().in6.s6_addr32[0]) 
+                    != key->nw_dst)
+        { 
+        INFO_PRINT("FAST: I am in check nw_dst");
+        continue; }
+
+		// treat the matched connections
+
+        // send conn now 
+		// Create supporting field from Connection object
+        INFO_PRINT("FAST: before thread lock check");
+        pthread_mutex_t conn_lock;
+        pthread_mutex_init(&conn_lock, NULL);
+        INFO_PRINT("FAST: Successfully initiate lock");
+        pthread_mutex_lock(&conn_lock);
+        //pthread_mutex_lock(&conn->lock);
+        INFO_PRINT("FAST: before state ini.");
+        char *state = sdmbn_boost_encode(conn);
+        conn->setGetOpId(id);
+	if (raiseEvents)
+        	conn->Moved();
+
+        if (NULL == state)
+        {
+            ERROR_PRINT("Failed to serialize connection");
+            continue;
+        }
+        INFO_PRINT("FAST: state %s",state);
+        // Save hash for use later
+        int hash = conn->Key()->Hash();
+
+        // Get the UID
+        // char uid[20];
+        // uitoa_n(conn->GetUID(), uid, sizeof(uid), 62);
+
+        // Create Perflow key field from connection identification information
+        PerflowKey connkey;
+        connkey.wildcards = WILDCARD_DL_TYPE;
+        in_addr tmpaddr;
+        conn->OrigAddr().CopyIPv4(&tmpaddr);
+        connkey.nw_src = tmpaddr.s_addr;
+        conn->RespAddr().CopyIPv4(&tmpaddr);
+        connkey.nw_dst = tmpaddr.s_addr;
+        connkey.tp_src = conn->OrigPort();
+        connkey.tp_dst = conn->RespPort();
+        switch (conn->ConnTransport())
+        {
+        case TRANSPORT_TCP:
+            connkey.nw_proto = IPPROTO_TCP;
+            break;
+        case TRANSPORT_UDP:
+            connkey.nw_proto = IPPROTO_UDP;
+            break;
+        case TRANSPORT_ICMP:
+            connkey.nw_proto = IPPROTO_ICMP;
+            break;
+        default:
+            connkey.wildcards |= WILDCARD_NW_PROTO;
+            break;
+        }
+       INFO_PRINT("FAST: Thread issue");
+       pthread_mutex_unlock(&conn_lock);  
+       //pthread_mutex_unlock(&conn->lock);
+       INFO_PRINT("FAST: Not the thread issue");
+		int result = sdmbn_send_perflow(id, &connkey, state, hash, count);
+		count++;
+       INFO_PRINT("FAST: must be sdmbn send perflow call");
+		free(state);
+	}
+       INFO_PRINT("FAST: I can reach here");
+       return count;
+}
+
+int local_get_perflow(PerflowKey *key, int id, int raiseEvents, SDMBNExt *unused)
+{
+    INFO_PRINT("FAST: I am in local get flow");
+	if (NULL == key)
+	{ return -1; }
+
+	int count = 0;
+    if (0 == key->nw_proto)
+    {
+        count += handle_get_proto(key, IPPROTO_TCP, id, raiseEvents);
+        count += handle_get_proto(key, IPPROTO_UDP, id, raiseEvents);
+        count += handle_get_proto(key, IPPROTO_ICMP, id, raiseEvents);
+    }
+    else
+    { count = handle_get_proto(key, key->nw_proto, id, raiseEvents); }
+    INFO_PRINT("FAST: Right before exit local get per flow");
+	return count;
+}
diff --git a/statein.tmp b/statein.tmp
new file mode 100644
index 0000000..135f210
--- /dev/null
+++ b/statein.tmp
@@ -0,0 +1,28 @@
+22 serialization::archive 12 0 1 0
+0 1 0
+1 -1 2 3 1 0
+2 36 4
+
+AAAAAAAAAAAAAP//rcK8CQAAAAAAAAAAAAD//8CoBaQBu5YI
+312464743 1 0
+3 16 0 0 0 0 0 0 0 0 0 0 255 255 192 168 5 164
+4 16 0 0 0 0 0 0 0 0 0 0 255 255 173 194 188 9 2198 47873 1 0 0 1.60796431707432699e+09 1.60796431707432699e+09 0.00000000000000000e+00 0 0 3796 1 C 128 5 12 TCP_Analyzer 1 0
+5 0 0 1 0
+6 4 1 0 0 -1 0 0 2 0 9 12 SSL_Analyzer 1 0
+7 1 0
+8
+9 34 3 0 0 5 5 0 0 -1 -1 0 0 0 0 0 0 0 5 5 0 12 7 PIA_TCP 1 0
+10 0 0 1 0
+11 -1 -1 0 0 12 10 0 0
+12
+13 1 2 0 0 5 5 0 0 -1 -1 0 0 0 0 0 0 0 5 5 0 0 0 -1 -1 0 0 0 0 0 0 0 12 10 16 1 0
+14 0 0 16
+15 0 0 16 14 17 1 0
+16 0 0 -1 -1 1 1 16 15 0 0 5 5 5 5 1 0 5 5 -1 7984 0.00000000000000000e+00 0.00000000000000000e+00
+17 16 0 0 0 0 0 0 0 0 0 0 255 255 192 168 5 164
+18 16 0 0 0 0 0 0 0 0 0 0 255 255 173 194 188 9 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 17
+19 -1 -1 1 1 16 14 0 0 5 5 5 5 1 1 5 5 -1 7984 0.00000000000000000e+00 0.00000000000000000e+00
+20 16 0 0 0 0 0 0 0 0 0 0 255 255 173 194 188 9
+21 16 0 0 0 0 0 0 0 0 0 0 255 255 192 168 5 164 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 16 15 1 0 21 17 ConnSize_Analyzer 1 0
+22
+23 44 4 0 0 5 5 0 0 -1 -1 0 0 0 0 0 0 0 0 0 0 0 20 12 10 16590077821343738635
diff --git a/stateout.tmp b/stateout.tmp
new file mode 100644
index 0000000..edacd0a
--- /dev/null
+++ b/stateout.tmp
@@ -0,0 +1,30 @@
+22 serialization::archive 12 0 1 0
+0 1 0
+1 -1 3 3 1 0
+2 36 4
+
+AAAAAAAAAAAAAP//rNkVwgAAAAAAAAAAAAD//8CoBaQBu+VP
+-394947337 1 0
+3 16 0 0 0 0 0 0 0 0 0 0 255 255 192 168 5 164
+4 16 0 0 0 0 0 0 0 0 0 0 255 255 172 217 21 194 20453 47873 1 0 0 1.60840148098253989e+09 1.60840149672781205e+09 3.00000000000000000e+02 0 0 7892 4 CafA 2228384 5 12 TCP_Analyzer 1 0
+5 0 0 1 0
+6 4 1879 0 0 -1 0 0 2 0 9 12 SSL_Analyzer 1 0
+7 1 0
+8
+9 34 1881 0 0 5 5 0 0 -1 -1 0 0 0 0 0 0 0 5 5 0 12 7 PIA_TCP 1 0
+10 0 0 1 0
+11 15 1 0
+12 1 12 10 15
+13 0 12 10 15 12 0 0 15 13 0 0 12 10 0 0
+14
+15 1 1880 0 0 5 5 0 0 -1 -1 0 0 0 0 0 0 0 5 5 0 0 0 -1 -1 0 0 0 1 0 0 0 12 10 16 1 0
+16 3 0 16
+17 5 3 16 16 17 1 0
+18 0 0 -1 -1 1 1 16 17 4 0 5 5 5 5 1 0 5 5 -1 61064 1.60840148098294091e+09 1.60840149672741199e+09
+19 16 0 0 0 0 0 0 0 0 0 0 255 255 192 168 5 164
+20 16 0 0 0 0 0 0 0 0 0 0 255 255 172 217 21 194 0 0 0 0 0 2 0 1 0 1 0 0 1979020663 0 1979020662 1979020664 1979020664 0 0 17
+21 -1 -1 1 1 16 16 0 0 5 5 5 5 1 1 5 5 -1 61064 1.60840149672781205e+09 1.60840149672781205e+09
+22 16 0 0 0 0 0 0 0 0 0 0 255 255 172 217 21 194
+23 16 0 0 0 0 0 0 0 0 0 0 255 255 192 168 5 164 0 0 0 0 0 0 0 0 0 0 1 0 0 0 2662036781 2662036782 2662036781 0 0 16 17 1 0 21 17 ConnSize_Analyzer 1 0
+24
+25 44 1882 0 0 5 5 0 0 -1 -1 0 0 0 0 0 0 0 40 520 1 13 15 12 10 8424552976885544552
diff --git a/weird.log b/weird.log
new file mode 100644
index 0000000..6f5b4dc
--- /dev/null
+++ b/weird.log
@@ -0,0 +1,218 @@
+#separator \x09
+#set_separator	,
+#empty_field	(empty)
+#unset_field	-
+#path	weird
+#open	2020-12-19-19-10-22
+#fields	ts	uid	id.orig_h	id.orig_p	id.resp_h	id.resp_p	name	addl	notice	peer
+#types	time	string	addr	port	addr	port	string	string	bool	string
+1608401422.182936	-	-	-	-	-	unknown_packet_type	-	F	bro
+1608401431.874918	kikzvx6kOu5	192.168.5.164	38408	173.194.188.9	443	bad_TCP_checksum	-	F	bro
+1608401432.962910	mnH4Z46y4Pa	192.168.5.164	42080	34.213.232.200	443	active_connection_reuse	-	F	bro
+1608401432.962910	9XlIMPF5QNa	7078:7d02:0:0:e00::	24757	502f:5503::1984:6b36:fb7f:0	0	bad_TCP_checksum	-	F	bro
+1608401432.979042	kikzvx6kOu5	192.168.5.164	38408	173.194.188.9	443	above_hole_data_without_any_acks	-	F	bro
+1608401435.586935	DTfmqv6q7Ef	192.168.5.164	49310	172.217.21.238	443	active_connection_reuse	-	F	bro
+1608401439.738968	qNo9lWlx51h	192.168.5.164	46473	173.194.188.134	443	active_connection_reuse	-	F	bro
+1608401439.770973	sV5gldO2PH9	192.168.5.164	46474	173.194.188.134	443	active_connection_reuse	-	F	bro
+1608401439.778928	hONkipZSdpb	192.168.5.164	49266	172.217.21.238	443	above_hole_data_without_any_acks	-	F	bro
+1608401439.794941	7WpfT6NuHUf	192.168.5.164	41020	172.217.23.142	443	above_hole_data_without_any_acks	-	F	bro
+1608401439.811027	YR0ZNanwJJi	192.168.5.164	41021	172.217.23.142	443	above_hole_data_without_any_acks	-	F	bro
+1608401439.811027	tojONienEx1	192.168.5.164	57526	172.217.18.161	443	active_connection_reuse	-	F	bro
+1608401439.834941	YufAB2MN1Q9	192.168.5.164	60003	74.125.173.202	443	active_connection_reuse	-	F	bro
+1608401439.858920	WgzAEsBnxAj	192.168.5.164	57544	172.217.16.182	443	above_hole_data_without_any_acks	-	F	bro
+1608401439.866945	5xWsLyJ26A1	192.168.5.164	60833	172.217.23.162	443	active_connection_reuse	-	F	bro
+1608401439.875013	qbwu1ntqzTj	192.168.5.164	51234	172.217.22.54	443	above_hole_data_without_any_acks	-	F	bro
+1608401439.875013	lPA5Nz0jJO3	192.168.5.164	39979	74.125.13.142	443	active_connection_reuse	-	F	bro
+1608401440.195001	ettXeuiLvz6	192.168.5.164	53944	172.217.16.142	443	active_connection_reuse	-	F	bro
+1608401440.210926	Foqal8sKV1d	192.168.5.164	51233	172.217.22.54	443	above_hole_data_without_any_acks	-	F	bro
+1608401441.146948	jvCrN1fp674	192.168.5.164	53970	74.125.11.104	443	active_connection_reuse	-	F	bro
+1608401441.202950	JkO8Qv8Fe2g	192.168.5.164	41019	172.217.23.142	443	above_hole_data_without_any_acks	-	F	bro
+1608401441.210944	HUCWpiHD7Cb	192.168.5.164	58711	172.217.22.97	443	above_hole_data_without_any_acks	-	F	bro
+1608401441.210944	rZveGRxBo23	192.168.5.164	58721	172.217.22.97	443	above_hole_data_without_any_acks	-	F	bro
+1608401441.234962	mK53MGt56el	192.168.5.164	51235	172.217.22.54	443	above_hole_data_without_any_acks	-	F	bro
+1608401441.242964	MCYWj4ivl0l	192.168.5.164	57540	172.217.16.182	443	above_hole_data_without_any_acks	-	F	bro
+1608401441.258969	eXy9tXKtb87	192.168.5.164	58740	172.217.22.97	443	above_hole_data_without_any_acks	-	F	bro
+1608401441.290972	6eKC0FK45N6	192.168.5.164	56873	173.194.188.231	443	active_connection_reuse	-	F	bro
+1608401441.290972	SD9ikhr8Oil	192.168.5.164	56874	173.194.188.231	443	active_connection_reuse	-	F	bro
+1608401441.322954	HUythVC8x7d	192.168.5.164	46710	172.217.16.130	443	active_connection_reuse	-	F	bro
+1608401441.330913	OKQlYHD6TBl	192.168.5.164	56733	173.194.188.103	443	active_connection_reuse	-	F	bro
+1608401441.346954	fXYYKU6Fokd	192.168.5.164	40228	172.217.22.3	443	active_connection_reuse	-	F	bro
+1608401441.362931	RVviofhPXZj	192.168.5.164	56735	173.194.188.103	443	active_connection_reuse	-	F	bro
+1608401441.458919	al07fkzx2Gb	192.168.5.164	49138	173.194.182.231	443	active_connection_reuse	-	F	bro
+1608401441.466936	lU6EdION3dk	192.168.5.164	49139	173.194.182.231	443	active_connection_reuse	-	F	bro
+1608401441.554937	0Jnx87FCTYb	192.168.5.164	53698	173.194.151.89	443	active_connection_reuse	-	F	bro
+1608401441.563003	mBiwcIFtTc5	192.168.5.164	53699	173.194.151.89	443	active_connection_reuse	-	F	bro
+1608401441.619026	raH28tOaGV7	192.168.5.164	54224	172.217.16.178	443	active_connection_reuse	-	F	bro
+1608401441.619026	0sFZcDj5864	192.168.5.164	48425	172.217.23.178	443	active_connection_reuse	-	F	bro
+1608401441.699001	CmaxzKpOOgh	192.168.5.164	53894	172.217.16.142	443	above_hole_data_without_any_acks	-	F	bro
+1608401441.739035	5uU5c6ECUd8	192.168.5.164	51025	173.194.182.232	443	active_connection_reuse	-	F	bro
+1608401441.763006	rZd9TYLzYo8	192.168.5.164	51026	173.194.182.232	443	active_connection_reuse	-	F	bro
+1608401441.779004	4PLslP8C96	192.168.5.164	42508	172.217.22.46	443	active_connection_reuse	-	F	bro
+1608401441.787020	R7QXqaVkcr8	192.168.5.164	42509	172.217.22.46	443	active_connection_reuse	-	F	bro
+1608401441.802935	utLPCypQAe	192.168.5.164	42510	172.217.22.46	443	active_connection_reuse	-	F	bro
+1608401441.802935	wBWRBWWidAf	192.168.5.164	57549	172.217.18.161	443	active_connection_reuse	-	F	bro
+1608401441.818913	1UsymF4ubki	192.168.5.164	42512	172.217.22.46	443	active_connection_reuse	-	F	bro
+1608401441.826959	w2OgQMdW8Df	192.168.5.164	42513	172.217.22.46	443	active_connection_reuse	-	F	bro
+1608401441.851001	vY1TixdVUri	192.168.5.164	42514	172.217.22.46	443	active_connection_reuse	-	F	bro
+1608401441.859003	2Ybnsqa05Hd	192.168.5.164	60431	173.194.187.42	443	active_connection_reuse	-	F	bro
+1608401442.378973	nJ1TiywCMVl	192.168.5.164	43571	172.217.18.2	443	active_connection_reuse	-	F	bro
+1608401442.378973	aqyAf3H8n4c	192.168.5.164	43572	172.217.18.2	443	active_connection_reuse	-	F	bro
+1608401442.498951	gG5M1RsAG75	192.168.5.164	43576	172.217.18.2	443	active_connection_reuse	-	F	bro
+1608401442.498951	JW9RjCtxIv6	192.168.5.164	43575	172.217.18.2	443	active_connection_reuse	-	F	bro
+1608401442.498951	pB99KPVA4Il	192.168.5.164	42518	172.217.22.46	443	active_connection_reuse	-	F	bro
+1608401442.506963	RPYvZIfcfQ7	192.168.5.164	42519	172.217.22.46	443	active_connection_reuse	-	F	bro
+1608401443.410943	6d7f0XL5Nu3	192.168.5.164	46509	173.194.188.134	443	active_connection_reuse	-	F	bro
+1608401443.458948	WfQ4KJGMJW1	192.168.5.164	46510	173.194.188.134	443	active_connection_reuse	-	F	bro
+1608401443.498959	ljvItEgSX9a	192.168.5.164	46511	173.194.188.134	443	active_connection_reuse	-	F	bro
+1608401443.498959	mXpNQmUmuu	192.168.5.164	46512	173.194.188.134	443	active_connection_reuse	-	F	bro
+1608401443.738924	9ahMmiHW27a	192.168.5.164	49351	172.217.21.238	443	active_connection_reuse	-	F	bro
+1608401445.202951	ojcxOoAnHN5	192.168.5.164	58718	172.217.22.97	443	above_hole_data_without_any_acks	-	F	bro
+1608401445.202951	fMSEHFGyLJg	192.168.5.164	56707	173.194.188.232	443	active_connection_reuse	-	F	bro
+1608401445.738941	LcMeabqDb1i	192.168.5.164	33881	216.58.207.78	443	active_connection_reuse	-	F	bro
+1608401445.850952	qhu2FA1LDcf	192.168.5.164	42529	172.217.22.46	443	active_connection_reuse	-	F	bro
+1608401445.858935	k7GJ916T4Ig	192.168.5.164	42531	172.217.22.46	443	active_connection_reuse	-	F	bro
+1608401445.858935	Ku041FbG9Sd	192.168.5.164	42530	172.217.22.46	443	active_connection_reuse	-	F	bro
+1608401445.858935	n9xJ4elZ2Wd	192.168.5.164	42533	172.217.22.46	443	active_connection_reuse	-	F	bro
+1608401445.858935	wQtRc0NxB2i	192.168.5.164	42532	172.217.22.46	443	active_connection_reuse	-	F	bro
+1608401446.026974	XlpLhFTZpY1	192.168.5.164	36950	172.217.16.162	443	active_connection_reuse	-	F	bro
+1608401446.066977	zmWGDx7izy	192.168.5.164	36951	172.217.16.162	443	active_connection_reuse	-	F	bro
+1608401446.450971	hf3aUgQGZP1	192.168.5.164	56772	173.194.188.103	443	active_connection_reuse	-	F	bro
+1608401446.490917	6jMlkc5p46a	192.168.5.164	32975	172.217.18.109	443	active_connection_reuse	-	F	bro
+1608401446.538949	AOhAAf8A4u6	192.168.5.164	54826	172.217.16.131	443	active_connection_reuse	-	F	bro
+1608401446.538949	gtAUVMBGyO7	192.168.5.164	54827	172.217.16.131	443	active_connection_reuse	-	F	bro
+1608401446.546908	HX9jsf8Vm95	192.168.5.164	33893	216.58.207.78	443	active_connection_reuse	-	F	bro
+1608401446.546908	GSGubf89Rb6	192.168.5.164	54829	172.217.16.131	443	active_connection_reuse	-	F	bro
+1608401446.546908	qNx5gDlPHB7	192.168.5.164	54830	172.217.16.131	443	active_connection_reuse	-	F	bro
+1608401446.626915	0tJ46IY2Czk	192.168.5.164	33896	216.58.207.78	443	active_connection_reuse	-	F	bro
+1608401446.626915	xcdOt7vCSpd	192.168.5.164	33897	216.58.207.78	443	active_connection_reuse	-	F	bro
+1608401448.174974	yyshEHWCNc2	192.168.5.164	35745	172.217.23.163	443	active_connection_reuse	-	F	bro
+1608401448.342913	6tLU0NjC4Ze	192.168.5.164	32984	172.217.18.109	443	active_connection_reuse	-	F	bro
+1608401448.398937	zAj5KfQf9Jh	192.168.5.164	40571	216.58.210.4	443	active_connection_reuse	-	F	bro
+1608401448.398937	omDgr9fhlhg	192.168.5.164	40572	216.58.210.4	443	active_connection_reuse	-	F	bro
+1608401448.758924	VOgP0gko2Gh	192.168.5.164	46510	173.194.188.134	443	above_hole_data_without_any_acks	-	F	bro
+1608401448.822940	XgknCtgKVwj	192.168.5.164	49518	172.217.18.174	443	active_connection_reuse	-	F	bro
+1608401449.746967	AXI5R1mVZZa	192.168.5.164	55978	172.217.18.3	443	active_connection_reuse	-	F	bro
+1608401449.963008	23pLwaqlzJ4	192.168.5.164	42551	172.217.22.46	443	active_connection_reuse	-	F	bro
+1608401450.003052	DWTmCEKTrx7	192.168.5.164	51550	216.58.210.3	443	active_connection_reuse	-	F	bro
+1608401450.098912	4LvxDP6hww4	192.168.5.164	59090	216.58.205.234	443	active_connection_reuse	-	F	bro
+1608401450.242950	ziYQKvCs4U5	192.168.5.164	37498	172.217.22.78	443	active_connection_reuse	-	F	bro
+1608401450.434959	D70IHBz2gL4	192.168.5.164	55983	172.217.18.3	443	active_connection_reuse	-	F	bro
+1608401450.434959	AEEf76BCX56	192.168.5.164	55984	172.217.18.3	443	active_connection_reuse	-	F	bro
+1608401450.442935	wF6XJmBKLv7	192.168.5.164	55985	172.217.18.3	443	active_connection_reuse	-	F	bro
+1608401451.154937	uxMYwDmRzd7	192.168.5.164	33911	216.58.207.78	443	active_connection_reuse	-	F	bro
+1608401451.786546	Hf69od1zye7	192.168.5.164	56707	173.194.188.232	443	above_hole_data_without_any_acks	-	F	bro
+1608401451.970916	VPvPwexcmEc	192.168.5.164	40146	172.217.16.161	443	active_connection_reuse	-	F	bro
+1608401454.466929	l84uiQ2cTg2	192.168.5.164	41816	216.58.206.6	443	active_connection_reuse	-	F	bro
+1608401456.714930	L0IL9VNHvvf	192.168.5.164	55484	216.58.206.2	443	active_connection_reuse	-	F	bro
+1608401456.747020	mtDDYoOPfei	192.168.5.164	42346	172.217.21.226	443	active_connection_reuse	-	F	bro
+1608401456.850991	qkMCuHn4rwi	192.168.5.164	49430	172.217.21.202	443	active_connection_reuse	-	F	bro
+1608401456.850991	0go4jlsWC6h	192.168.5.164	49431	172.217.21.202	443	active_connection_reuse	-	F	bro
+1608401456.882963	trL3DDA7j	192.168.5.164	57800	100.24.142.9	443	active_connection_reuse	-	F	bro
+1608401456.890942	IfCjMorBex8	192.168.5.164	38789	52.56.172.244	443	active_connection_reuse	-	F	bro
+1608401456.898939	fzCDCXrP9q1	192.168.5.164	57801	100.24.142.9	443	active_connection_reuse	-	F	bro
+1608401456.922959	FsX1FgRRGh5	192.168.5.164	41277	172.217.16.198	443	active_connection_reuse	-	F	bro
+1608401456.946939	ms983wWjx18	192.168.5.164	38635	23.42.150.222	443	active_connection_reuse	-	F	bro
+1608401456.954935	oUc76qxd3H6	192.168.5.164	38636	23.42.150.222	443	active_connection_reuse	-	F	bro
+1608401456.986931	ggAAlYbFi98	192.168.5.164	32953	172.217.21.206	443	active_connection_reuse	-	F	bro
+1608401457.050927	CIy19JK3G4k	192.168.5.164	36470	18.130.64.138	443	active_connection_reuse	-	F	bro
+1608401457.050927	Z2UENupQYLb	192.168.5.164	45713	172.217.21.195	443	active_connection_reuse	-	F	bro
+1608401457.059011	hRvFG9MWMbd	192.168.5.164	51788	3.9.227.4	443	active_connection_reuse	-	F	bro
+1608401457.098969	rAUxc2VOmUb	192.168.5.164	38641	23.42.150.222	443	active_connection_reuse	-	F	bro
+1608401457.114932	Zy1iKPUwwnl	192.168.5.164	38642	23.42.150.222	443	active_connection_reuse	-	F	bro
+1608401457.138920	41gv99tBtdd	192.168.5.164	38643	23.42.150.222	443	active_connection_reuse	-	F	bro
+1608401457.154912	lDUbWM3dLvl	192.168.5.164	38644	23.42.150.222	443	active_connection_reuse	-	F	bro
+1608401463.554995	yoLhxacRwT3	192.168.5.164	42579	172.217.22.46	443	active_connection_reuse	-	F	bro
+1608401463.562890	5oNrayq4nF6	192.168.5.164	42580	172.217.22.46	443	active_connection_reuse	-	F	bro
+1608401465.651033	94rksXgtvi8	192.168.5.164	46341	52.39.194.243	443	active_connection_reuse	-	F	bro
+1608401465.659000	GROuBfHINr1	192.168.5.164	46342	52.39.194.243	443	active_connection_reuse	-	F	bro
+1608401465.659000	A9SgB4gCZ1	192.168.5.164	36182	3.8.13.74	443	active_connection_reuse	-	F	bro
+1608401465.659000	nrlXCdiU3W9	192.168.5.164	36183	3.8.13.74	443	active_connection_reuse	-	F	bro
+1608401465.666958	IrGh7g6BKpe	192.168.5.164	42585	172.217.22.46	443	active_connection_reuse	-	F	bro
+1608401465.675025	MmyL6o1GeKf	192.168.5.164	42586	172.217.22.46	443	active_connection_reuse	-	F	bro
+1608401465.675025	GSJNhRMC927	192.168.5.164	46961	35.177.15.101	443	active_connection_reuse	-	F	bro
+1608401465.675025	TXpF7Ia4Zc4	192.168.5.164	60365	3.9.61.237	443	active_connection_reuse	-	F	bro
+1608401465.722958	gC0E6BDXkj5	192.168.5.164	49430	172.217.21.202	443	above_hole_data_without_any_acks	-	F	bro
+1608401467.874950	RVJ9srVLbl4	192.168.5.164	42840	35.162.37.53	443	active_connection_reuse	-	F	bro
+1608401467.874950	TXXUfRyFnV2	192.168.5.164	39921	34.209.209.121	443	active_connection_reuse	-	F	bro
+1608401467.882941	DCGOufB00Oc	192.168.5.164	39923	34.209.209.121	443	active_connection_reuse	-	F	bro
+1608401467.882941	HdGDOjLVvtb	192.168.5.164	42842	35.162.37.53	443	active_connection_reuse	-	F	bro
+1608401467.890967	0EfZ7767tOj	192.168.5.164	59968	93.184.220.29	80	active_connection_reuse	-	F	bro
+1608401467.890967	8Dxro8vdX8l	192.168.5.164	59969	93.184.220.29	80	active_connection_reuse	-	F	bro
+1608401467.890967	eDQRowP9nCi	192.168.5.164	59970	93.184.220.29	80	active_connection_reuse	-	F	bro
+1608401467.898931	esT7Gmxtwch	192.168.5.164	59971	93.184.220.29	80	active_connection_reuse	-	F	bro
+1608401467.898931	jNFVoguQOte	192.168.5.164	59973	93.184.220.29	80	active_connection_reuse	-	F	bro
+1608401467.898931	VpgHBykViOf	192.168.5.164	59972	93.184.220.29	80	active_connection_reuse	-	F	bro
+1608401467.907010	lByyjWsYF41	192.168.5.164	59974	93.184.220.29	80	active_connection_reuse	-	F	bro
+1608401467.907010	hAEP1xNEcp2	192.168.5.164	59975	93.184.220.29	80	active_connection_reuse	-	F	bro
+1608401467.907010	Qmd7Etfzej9	192.168.5.164	59976	93.184.220.29	80	active_connection_reuse	-	F	bro
+1608401467.915020	ykdL9zLJBB9	192.168.5.164	59977	93.184.220.29	80	active_connection_reuse	-	F	bro
+1608401467.915020	YUMdNFxo8Wa	192.168.5.164	59978	93.184.220.29	80	active_connection_reuse	-	F	bro
+1608401467.915020	m1jc4vygQq2	192.168.5.164	59979	93.184.220.29	80	active_connection_reuse	-	F	bro
+1608401468.026918	LkUQfeN7fFj	192.168.5.164	42856	35.162.37.53	443	active_connection_reuse	-	F	bro
+1608401468.026918	OdaCYiFKpXc	192.168.5.164	42857	35.162.37.53	443	active_connection_reuse	-	F	bro
+1608401468.026918	kvhHINdEBxb	192.168.5.164	42858	35.162.37.53	443	active_connection_reuse	-	F	bro
+1608401468.026918	1tiTTaSPY7l	192.168.5.164	42859	35.162.37.53	443	active_connection_reuse	-	F	bro
+1608401468.050954	ZS1YSbbbsNj	192.168.5.164	42860	35.162.37.53	443	active_connection_reuse	-	F	bro
+1608401468.050954	F4wP2hgZEA5	192.168.5.164	42861	35.162.37.53	443	active_connection_reuse	-	F	bro
+1608401468.050954	mwYBqxxI8U2	192.168.5.164	42863	35.162.37.53	443	active_connection_reuse	-	F	bro
+1608401468.058948	pFpmEUtFv07	192.168.5.164	42862	35.162.37.53	443	active_connection_reuse	-	F	bro
+1608401469.371024	0EbR6TSkpl2	192.168.5.164	49582	172.217.18.174	443	active_connection_reuse	-	F	bro
+1608401469.371024	RZU7VxUuiZ8	192.168.5.164	49583	172.217.18.174	443	active_connection_reuse	-	F	bro
+1608401469.442996	0D3vrQ6lQ72	192.168.5.164	57653	172.217.18.161	443	active_connection_reuse	-	F	bro
+1608401469.474932	UQkBmDIpN6f	192.168.5.164	53477	52.51.196.181	443	active_connection_reuse	-	F	bro
+1608401469.514937	aDtTFIprzdg	192.168.5.164	37947	185.60.217.35	443	active_connection_reuse	-	F	bro
+1608401469.538950	Pk98wQhf4Mh	192.168.5.164	37946	185.60.217.35	443	active_connection_reuse	-	F	bro
+1608401469.546960	vZ4F6Zt2dzh	192.168.5.164	51617	216.58.210.3	443	active_connection_reuse	-	F	bro
+1608401469.546960	rYWpSeLEcpj	192.168.5.164	51618	216.58.210.3	443	active_connection_reuse	-	F	bro
+1608401469.602920	nJTdd9SwZmj	192.168.5.164	45295	172.217.18.110	80	active_connection_reuse	-	F	bro
+1608401469.626917	0XBb78yAP6b	192.168.5.164	48207	173.194.164.167	80	active_connection_reuse	-	F	bro
+1608401469.715007	4yqWeo0Z7F4	192.168.5.164	52959	74.125.173.43	80	active_connection_reuse	-	F	bro
+1608401472.575008	pQ1NXU9Pq16	192.168.5.164	49593	172.217.18.174	443	active_connection_reuse	-	F	bro
+1608401473.806911	6rOGmZoSoc3	192.168.5.164	43680	172.217.18.2	443	active_connection_reuse	-	F	bro
+1608401473.822920	TbXQ8Adawj7	192.168.5.164	34966	216.58.207.34	443	active_connection_reuse	-	F	bro
+1608401473.830919	PWyNaWcvZY5	192.168.5.164	46841	172.217.16.130	443	active_connection_reuse	-	F	bro
+1608401473.830919	BPjgEL0nXi3	192.168.5.164	46842	172.217.16.130	443	active_connection_reuse	-	F	bro
+1608401473.862910	xnKsvzgFeB4	192.168.5.164	46843	172.217.16.130	443	active_connection_reuse	-	F	bro
+1608401473.894931	CendkgsV006	192.168.5.164	34970	216.58.207.34	443	active_connection_reuse	-	F	bro
+1608401473.894931	IMz1QNk8HQk	192.168.5.164	42416	172.217.21.226	443	active_connection_reuse	-	F	bro
+1608401473.902978	4KlkDCx1vk7	192.168.5.164	46845	172.217.16.130	443	active_connection_reuse	-	F	bro
+1608401473.902978	tpraOEPl6yc	192.168.5.164	46847	172.217.16.130	443	active_connection_reuse	-	F	bro
+1608401473.902978	vNAXGkOFzdb	192.168.5.164	46848	172.217.16.130	443	active_connection_reuse	-	F	bro
+1608401473.926940	wX4xSTM0vIk	192.168.5.164	48610	172.217.18.162	443	active_connection_reuse	-	F	bro
+1608401474.118972	gSC0SJkwydj	192.168.5.164	57674	172.217.18.161	443	active_connection_reuse	-	F	bro
+1608401474.118972	rjFSqLHmycg	192.168.5.164	57676	172.217.18.161	443	active_connection_reuse	-	F	bro
+1608401474.118972	hZl6gL1gKMe	192.168.5.164	57675	172.217.18.161	443	active_connection_reuse	-	F	bro
+1608401474.118972	i93w6tMJbAh	192.168.5.164	57677	172.217.18.161	443	active_connection_reuse	-	F	bro
+1608401474.118972	iMTQbDRoIUi	192.168.5.164	57678	172.217.18.161	443	active_connection_reuse	-	F	bro
+1608401474.142960	KXoR4S2t1e9	192.168.5.164	34529	172.217.18.4	443	active_connection_reuse	-	F	bro
+1608401474.142960	ktigGGE9SDa	192.168.5.164	34528	172.217.18.4	443	active_connection_reuse	-	F	bro
+1608401474.250930	9EkCjgch2mk	192.168.5.164	58703	172.217.21.194	443	active_connection_reuse	-	F	bro
+1608401474.250930	MW0UTem7Jvd	192.168.5.164	58201	35.177.144.113	443	active_connection_reuse	-	F	bro
+1608401474.266955	lT0AgGPw2K7	192.168.5.164	58203	35.177.144.113	443	active_connection_reuse	-	F	bro
+1608401474.282961	mO7WuKprcbc	192.168.5.164	41927	18.233.201.37	443	active_connection_reuse	-	F	bro
+1608401474.322924	vBqlAtFqyp6	192.168.5.164	47463	52.41.52.45	443	active_connection_reuse	-	F	bro
+1608401474.394915	Fp84YoHNMh6	192.168.5.164	47464	52.41.52.45	443	active_connection_reuse	-	F	bro
+1608401474.458909	6B6Ta7IMW22	192.168.5.164	33031	172.217.21.206	443	active_connection_reuse	-	F	bro
+1608401474.458909	piNytSScVT8	192.168.5.164	33032	172.217.21.206	443	active_connection_reuse	-	F	bro
+1608401474.506963	MfphtpVo3K1	192.168.5.164	33033	172.217.21.206	443	active_connection_reuse	-	F	bro
+1608401474.554998	rvBdGzham1a	192.168.5.164	41210	216.58.206.14	443	active_connection_reuse	-	F	bro
+1608401474.563024	9QBm3SCud7i	192.168.5.164	41211	216.58.206.14	443	active_connection_reuse	-	F	bro
+1608401474.563024	tni0lyCPGMg	192.168.5.164	41212	216.58.206.14	443	active_connection_reuse	-	F	bro
+1608401474.579005	y3LdaGvT52e	192.168.5.164	41213	216.58.206.14	443	active_connection_reuse	-	F	bro
+1608401485.690955	ncTrp5jw1U4	192.168.5.164	54591	54.148.41.88	443	active_connection_reuse	-	F	bro
+1608401486.210962	cW8SPDCwKPl	192.168.5.164	42909	35.162.37.53	443	active_connection_reuse	-	F	bro
+1608401486.382929	rt9F8679Dcc	192.168.5.164	42908	35.162.37.53	443	active_connection_reuse	-	F	bro
+1608401486.655031	7iLKPbyNdac	192.168.5.164	38225	34.213.110.255	443	active_connection_reuse	-	F	bro
+1608401486.862939	SHYvjlyO0nk	192.168.5.164	60035	93.184.220.29	80	active_connection_reuse	-	F	bro
+1608401489.750970	9bJYb4mJjH7	192.168.5.164	41370	172.217.16.198	443	active_connection_reuse	-	F	bro
+1608401489.902990	QNxf3vHYXdc	192.168.5.164	46378	52.41.66.223	443	active_connection_reuse	-	F	bro
+1608401489.902990	aWEt3NyD4wd	192.168.5.164	38731	23.42.150.222	443	active_connection_reuse	-	F	bro
+1608401489.911001	1YYKPIFWUtk	192.168.5.164	36263	3.8.13.74	443	active_connection_reuse	-	F	bro
+1608401489.918965	OdNsTqRYxbc	192.168.5.164	38732	23.42.150.222	443	active_connection_reuse	-	F	bro
+1608401489.935010	hJJE4zVCrOl	192.168.5.164	46379	52.41.66.223	443	active_connection_reuse	-	F	bro
+1608401490.250929	EYkgbN5wyrf	192.168.5.164	33886	18.130.186.43	443	active_connection_reuse	-	F	bro
+1608401490.250929	nweZrDW6aug	192.168.5.164	33887	18.130.186.43	443	active_connection_reuse	-	F	bro
+1608401490.290956	eWk5FW1Yc9f	192.168.5.164	44134	18.130.137.141	443	active_connection_reuse	-	F	bro
+1608401490.298978	0t8LMAlxC22	192.168.5.164	44135	18.130.137.141	443	active_connection_reuse	-	F	bro
+1608401490.979020	6leZ4grunK1	192.168.5.164	51267	172.217.14.99	443	active_connection_reuse	-	F	bro
+1608401501.470966	64Ksl482x8i	10.0.0.3	45428	10.0.0.2	7792	bad_TCP_checksum	-	F	bro
diff --git a/wisconsin_build.sh b/wisconsin_build.sh
new file mode 100644
index 0000000..11b31b2
--- /dev/null
+++ b/wisconsin_build.sh
@@ -0,0 +1,13 @@
+#!/bin/bash
+
+BASEDIR="/scratch/${USER}/tools"
+export CFLAGS="-I${BASEDIR}/json-c/include/ -I${BASEDIR}/sdmbn/include/ -g"
+export CXXFLAGS="-I${BASEDIR}/json-c/include/ -I${BASEDIR}/sdmbn/include/ -g"
+export LDFLAGS="-L${BASEDIR}/json-c/lib/ -L${BASEDIR}/sdmbn/lib/ -L/usr/local/lib/ -lsdmbn -ljson-c -lboost_serialization"
+
+export LD_LIBRARY_PATH="${BASEDIR}/json-c/lib:${BASEDIR}/sdmbn/lib" 
+
+./configure --prefix=${BASEDIR}/bro-sdmbn 
+sed -e 's/-lsdmbn -ljson-c -lboost_serialization//' -i build/src/CMakeFiles/bro.dir/link.txt
+sed -e 's/-lcrypto/-lcrypto -lsdmbn -ljson-c -lboost_serialization/' -i build/src/CMakeFiles/bro.dir/link.txt
+make install
